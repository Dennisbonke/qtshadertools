From f9934f7c0866a9d591f06a87dc3f970583eca9be Mon Sep 17 00:00:00 2001
From: Laszlo Agocs <laszlo.agocs@qt.io>
Date: Mon, 15 Aug 2022 19:36:00 +0200
Subject: [PATCH] Change glslang namespace name to avoid problems on INTEGRITY

Change-Id: I84bf75e5197beac4280a36dc723e269786e02f5e
---
 .../glslang/OGLCompilersDLL/InitializeDll.cpp |   20 +-
 .../glslang/OGLCompilersDLL/InitializeDll.h   |    4 +-
 src/3rdparty/glslang/SPIRV/GlslangToSpv.cpp   | 4156 ++++++++---------
 src/3rdparty/glslang/SPIRV/GlslangToSpv.h     |    6 +-
 src/3rdparty/glslang/SPIRV/SpvTools.cpp       |    4 +-
 src/3rdparty/glslang/SPIRV/SpvTools.h         |    4 +-
 src/3rdparty/glslang/SPIRV/disassemble.cpp    |    2 +-
 .../glslang/glslang/HLSL/hlslAttributes.cpp   |    4 +-
 .../glslang/glslang/HLSL/hlslAttributes.h     |    4 +-
 .../glslang/glslang/HLSL/hlslGrammar.cpp      |    4 +-
 .../glslang/glslang/HLSL/hlslGrammar.h        |    4 +-
 .../glslang/glslang/HLSL/hlslOpMap.cpp        |    4 +-
 src/3rdparty/glslang/glslang/HLSL/hlslOpMap.h |    4 +-
 .../glslang/glslang/HLSL/hlslParseHelper.cpp  |    4 +-
 .../glslang/glslang/HLSL/hlslParseHelper.h    |    4 +-
 .../glslang/glslang/HLSL/hlslParseables.cpp   |    4 +-
 .../glslang/glslang/HLSL/hlslParseables.h     |    4 +-
 .../glslang/glslang/HLSL/hlslScanContext.cpp  |    4 +-
 .../glslang/glslang/HLSL/hlslScanContext.h    |    4 +-
 .../glslang/glslang/HLSL/hlslTokenStream.cpp  |    4 +-
 .../glslang/glslang/HLSL/hlslTokenStream.h    |    4 +-
 .../glslang/glslang/HLSL/hlslTokens.h         |    4 +-
 .../glslang/glslang/Include/BaseTypes.h       |    4 +-
 src/3rdparty/glslang/glslang/Include/Common.h |   12 +-
 .../glslang/glslang/Include/ConstantUnion.h   |    4 +-
 .../glslang/glslang/Include/InfoSink.h        |    8 +-
 .../glslang/Include/InitializeGlobals.h       |    4 +-
 .../glslang/glslang/Include/PoolAlloc.h       |    4 +-
 .../glslang/glslang/Include/ShHandle.h        |   10 +-
 .../glslang/glslang/Include/SpirvIntrinsics.h |    4 +-
 src/3rdparty/glslang/glslang/Include/Types.h  |    6 +-
 src/3rdparty/glslang/glslang/Include/arrays.h |    4 +-
 .../glslang/glslang/Include/intermediate.h    |   72 +-
 .../glslang/MachineIndependent/Constant.cpp   |    6 +-
 .../glslang/MachineIndependent/InfoSink.cpp   |    4 +-
 .../glslang/MachineIndependent/Initialize.cpp |    4 +-
 .../glslang/MachineIndependent/Initialize.h   |    4 +-
 .../MachineIndependent/IntermTraverse.cpp     |    4 +-
 .../MachineIndependent/Intermediate.cpp       |    8 +-
 .../MachineIndependent/LiveTraverser.h        |    4 +-
 .../MachineIndependent/ParseContextBase.cpp   |    6 +-
 .../MachineIndependent/ParseHelper.cpp        |   14 +-
 .../glslang/MachineIndependent/ParseHelper.h  |    6 +-
 .../glslang/MachineIndependent/PoolAlloc.cpp  |    4 +-
 .../glslang/MachineIndependent/RemoveTree.cpp |    4 +-
 .../glslang/MachineIndependent/RemoveTree.h   |    4 +-
 .../glslang/MachineIndependent/Scan.cpp       |   14 +-
 .../glslang/glslang/MachineIndependent/Scan.h |    4 +-
 .../glslang/MachineIndependent/ScanContext.h  |    4 +-
 .../glslang/MachineIndependent/ShaderLang.cpp |   40 +-
 .../MachineIndependent/SpirvIntrinsics.cpp    |    4 +-
 .../MachineIndependent/SymbolTable.cpp        |    4 +-
 .../glslang/MachineIndependent/SymbolTable.h  |    4 +-
 .../glslang/MachineIndependent/Versions.cpp   |    4 +-
 .../glslang/MachineIndependent/Versions.h     |    4 +-
 .../glslang/MachineIndependent/attribute.cpp  |    4 +-
 .../glslang/MachineIndependent/attribute.h    |    4 +-
 .../glslang/MachineIndependent/glslang.y      |   40 +-
 .../MachineIndependent/glslang_tab.cpp        |   12 +-
 .../MachineIndependent/glslang_tab.cpp.h      |   40 +-
 .../glslang/MachineIndependent/intermOut.cpp  |    4 +-
 .../glslang/MachineIndependent/iomapper.cpp   |   18 +-
 .../glslang/MachineIndependent/iomapper.h     |   34 +-
 .../glslang/MachineIndependent/limits.cpp     |    4 +-
 .../MachineIndependent/linkValidate.cpp       |   26 +-
 .../MachineIndependent/localintermediate.h    |    4 +-
 .../glslang/MachineIndependent/parseConst.cpp |    4 +-
 .../MachineIndependent/parseVersions.h        |    4 +-
 .../MachineIndependent/preprocessor/Pp.cpp    |    4 +-
 .../preprocessor/PpAtom.cpp                   |    6 +-
 .../preprocessor/PpContext.cpp                |    4 +-
 .../preprocessor/PpContext.h                  |    4 +-
 .../preprocessor/PpScanner.cpp                |    4 +-
 .../preprocessor/PpTokens.cpp                 |    4 +-
 .../preprocessor/PpTokens.h                   |    4 +-
 .../propagateNoContraction.cpp                |  224 +-
 .../propagateNoContraction.h                  |    4 +-
 .../glslang/MachineIndependent/reflection.cpp |    6 +-
 .../glslang/MachineIndependent/reflection.h   |    6 +-
 .../glslang/OSDependent/Unix/ossource.cpp     |    4 +-
 .../glslang/OSDependent/Windows/ossource.cpp  |    4 +-
 .../glslang/glslang/OSDependent/osinclude.h   |    4 +-
 .../glslang/glslang/Public/ShaderLang.h       |   10 +-
 src/shadertools/qspirvcompiler.cpp            |   22 +-
 84 files changed, 2527 insertions(+), 2527 deletions(-)

diff --git a/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.cpp b/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.cpp
index abea9108..6449a261 100644
--- a/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.cpp
+++ b/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.cpp
@@ -41,7 +41,7 @@
 #include "../glslang/Public/ShaderLang.h"
 #include "../glslang/Include/PoolAlloc.h"
 
-namespace glslang {
+namespace qglslang {
 
 OS_TLSIndex ThreadInitializeIndex = OS_INVALID_TLS_INDEX;
 
@@ -51,14 +51,14 @@ OS_TLSIndex ThreadInitializeIndex = OS_INVALID_TLS_INDEX;
 // threads will need to do that explicitly.
 bool InitProcess()
 {
-    glslang::GetGlobalLock();
+    qglslang::GetGlobalLock();
 
     if (ThreadInitializeIndex != OS_INVALID_TLS_INDEX) {
         //
         // Function is re-entrant.
         //
 
-        glslang::ReleaseGlobalLock();
+        qglslang::ReleaseGlobalLock();
         return true;
     }
 
@@ -67,25 +67,25 @@ bool InitProcess()
     if (ThreadInitializeIndex == OS_INVALID_TLS_INDEX) {
         assert(0 && "InitProcess(): Failed to allocate TLS area for init flag");
 
-        glslang::ReleaseGlobalLock();
+        qglslang::ReleaseGlobalLock();
         return false;
     }
 
     if (! InitializePoolIndex()) {
         assert(0 && "InitProcess(): Failed to initialize global pool");
 
-        glslang::ReleaseGlobalLock();
+        qglslang::ReleaseGlobalLock();
         return false;
     }
 
     if (! InitThread()) {
         assert(0 && "InitProcess(): Failed to initialize thread");
 
-        glslang::ReleaseGlobalLock();
+        qglslang::ReleaseGlobalLock();
         return false;
     }
 
-    glslang::ReleaseGlobalLock();
+    qglslang::ReleaseGlobalLock();
     return true;
 }
 
@@ -110,7 +110,7 @@ bool InitThread()
         return false;
     }
 
-    glslang::SetThreadPoolAllocator(nullptr);
+    qglslang::SetThreadPoolAllocator(nullptr);
 
     return true;
 }
@@ -145,7 +145,7 @@ bool DetachThread()
 // This is kept, with memory management removed, to satisfy any exiting
 // calls to it that rely on it.
 //
-// Users of glslang should call shFinalize() or glslang::FinalizeProcess() for
+// Users of glslang should call shFinalize() or qglslang::FinalizeProcess() for
 // process-scoped memory tear down.
 bool DetachProcess()
 {
@@ -162,4 +162,4 @@ bool DetachProcess()
     return success;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.h b/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.h
index 661cee4d..a96784f7 100644
--- a/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.h
+++ b/src/3rdparty/glslang/OGLCompilersDLL/InitializeDll.h
@@ -36,14 +36,14 @@
 
 #include "../glslang/OSDependent/osinclude.h"
 
-namespace glslang {
+namespace qglslang {
 
 bool InitProcess();
 bool InitThread();
 bool DetachThread();  // not called from standalone, perhaps other tools rely on parts of it
 bool DetachProcess(); // not called from standalone, perhaps other tools rely on parts of it
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // __INITIALIZEDLL_H
 
diff --git a/src/3rdparty/glslang/SPIRV/GlslangToSpv.cpp b/src/3rdparty/glslang/SPIRV/GlslangToSpv.cpp
index 63547692..b6938f15 100644
--- a/src/3rdparty/glslang/SPIRV/GlslangToSpv.cpp
+++ b/src/3rdparty/glslang/SPIRV/GlslangToSpv.cpp
@@ -123,21 +123,21 @@ struct OpDecorations {
 //
 // Derives from the AST walking base class.
 //
-class TGlslangToSpvTraverser : public glslang::TIntermTraverser {
+class TGlslangToSpvTraverser : public qglslang::TIntermTraverser {
 public:
-    TGlslangToSpvTraverser(unsigned int spvVersion, const glslang::TIntermediate*, spv::SpvBuildLogger* logger,
-        glslang::SpvOptions& options);
+    TGlslangToSpvTraverser(unsigned int spvVersion, const qglslang::TIntermediate*, spv::SpvBuildLogger* logger,
+        qglslang::SpvOptions& options);
     virtual ~TGlslangToSpvTraverser() { }
 
-    bool visitAggregate(glslang::TVisit, glslang::TIntermAggregate*);
-    bool visitBinary(glslang::TVisit, glslang::TIntermBinary*);
-    void visitConstantUnion(glslang::TIntermConstantUnion*);
-    bool visitSelection(glslang::TVisit, glslang::TIntermSelection*);
-    bool visitSwitch(glslang::TVisit, glslang::TIntermSwitch*);
-    void visitSymbol(glslang::TIntermSymbol* symbol);
-    bool visitUnary(glslang::TVisit, glslang::TIntermUnary*);
-    bool visitLoop(glslang::TVisit, glslang::TIntermLoop*);
-    bool visitBranch(glslang::TVisit visit, glslang::TIntermBranch*);
+    bool visitAggregate(qglslang::TVisit, qglslang::TIntermAggregate*);
+    bool visitBinary(qglslang::TVisit, qglslang::TIntermBinary*);
+    void visitConstantUnion(qglslang::TIntermConstantUnion*);
+    bool visitSelection(qglslang::TVisit, qglslang::TIntermSelection*);
+    bool visitSwitch(qglslang::TVisit, qglslang::TIntermSwitch*);
+    void visitSymbol(qglslang::TIntermSymbol* symbol);
+    bool visitUnary(qglslang::TVisit, qglslang::TIntermUnary*);
+    bool visitLoop(qglslang::TVisit, qglslang::TIntermLoop*);
+    bool visitBranch(qglslang::TVisit visit, qglslang::TIntermBranch*);
 
     void finishSpv();
     void dumpSpv(std::vector<unsigned int>& out);
@@ -146,99 +146,99 @@ protected:
     TGlslangToSpvTraverser(TGlslangToSpvTraverser&);
     TGlslangToSpvTraverser& operator=(TGlslangToSpvTraverser&);
 
-    spv::Decoration TranslateInterpolationDecoration(const glslang::TQualifier& qualifier);
-    spv::Decoration TranslateAuxiliaryStorageDecoration(const glslang::TQualifier& qualifier);
-    spv::Decoration TranslateNonUniformDecoration(const glslang::TQualifier& qualifier);
+    spv::Decoration TranslateInterpolationDecoration(const qglslang::TQualifier& qualifier);
+    spv::Decoration TranslateAuxiliaryStorageDecoration(const qglslang::TQualifier& qualifier);
+    spv::Decoration TranslateNonUniformDecoration(const qglslang::TQualifier& qualifier);
     spv::Decoration TranslateNonUniformDecoration(const spv::Builder::AccessChain::CoherentFlags& coherentFlags);
-    spv::Builder::AccessChain::CoherentFlags TranslateCoherent(const glslang::TType& type);
+    spv::Builder::AccessChain::CoherentFlags TranslateCoherent(const qglslang::TType& type);
     spv::MemoryAccessMask TranslateMemoryAccess(const spv::Builder::AccessChain::CoherentFlags &coherentFlags);
     spv::ImageOperandsMask TranslateImageOperands(const spv::Builder::AccessChain::CoherentFlags &coherentFlags);
     spv::Scope TranslateMemoryScope(const spv::Builder::AccessChain::CoherentFlags &coherentFlags);
-    spv::BuiltIn TranslateBuiltInDecoration(glslang::TBuiltInVariable, bool memberDeclaration);
-    spv::ImageFormat TranslateImageFormat(const glslang::TType& type);
-    spv::SelectionControlMask TranslateSelectionControl(const glslang::TIntermSelection&) const;
-    spv::SelectionControlMask TranslateSwitchControl(const glslang::TIntermSwitch&) const;
-    spv::LoopControlMask TranslateLoopControl(const glslang::TIntermLoop&, std::vector<unsigned int>& operands) const;
-    spv::StorageClass TranslateStorageClass(const glslang::TType&);
-    void TranslateLiterals(const glslang::TVector<const glslang::TIntermConstantUnion*>&, std::vector<unsigned>&) const;
-    void addIndirectionIndexCapabilities(const glslang::TType& baseType, const glslang::TType& indexType);
-    spv::Id createSpvVariable(const glslang::TIntermSymbol*, spv::Id forcedType);
-    spv::Id getSampledType(const glslang::TSampler&);
-    spv::Id getInvertedSwizzleType(const glslang::TIntermTyped&);
-    spv::Id createInvertedSwizzle(spv::Decoration precision, const glslang::TIntermTyped&, spv::Id parentResult);
-    void convertSwizzle(const glslang::TIntermAggregate&, std::vector<unsigned>& swizzle);
-    spv::Id convertGlslangToSpvType(const glslang::TType& type, bool forwardReferenceOnly = false);
-    spv::Id convertGlslangToSpvType(const glslang::TType& type, glslang::TLayoutPacking, const glslang::TQualifier&,
+    spv::BuiltIn TranslateBuiltInDecoration(qglslang::TBuiltInVariable, bool memberDeclaration);
+    spv::ImageFormat TranslateImageFormat(const qglslang::TType& type);
+    spv::SelectionControlMask TranslateSelectionControl(const qglslang::TIntermSelection&) const;
+    spv::SelectionControlMask TranslateSwitchControl(const qglslang::TIntermSwitch&) const;
+    spv::LoopControlMask TranslateLoopControl(const qglslang::TIntermLoop&, std::vector<unsigned int>& operands) const;
+    spv::StorageClass TranslateStorageClass(const qglslang::TType&);
+    void TranslateLiterals(const qglslang::TVector<const qglslang::TIntermConstantUnion*>&, std::vector<unsigned>&) const;
+    void addIndirectionIndexCapabilities(const qglslang::TType& baseType, const qglslang::TType& indexType);
+    spv::Id createSpvVariable(const qglslang::TIntermSymbol*, spv::Id forcedType);
+    spv::Id getSampledType(const qglslang::TSampler&);
+    spv::Id getInvertedSwizzleType(const qglslang::TIntermTyped&);
+    spv::Id createInvertedSwizzle(spv::Decoration precision, const qglslang::TIntermTyped&, spv::Id parentResult);
+    void convertSwizzle(const qglslang::TIntermAggregate&, std::vector<unsigned>& swizzle);
+    spv::Id convertGlslangToSpvType(const qglslang::TType& type, bool forwardReferenceOnly = false);
+    spv::Id convertGlslangToSpvType(const qglslang::TType& type, qglslang::TLayoutPacking, const qglslang::TQualifier&,
         bool lastBufferBlockMember, bool forwardReferenceOnly = false);
-    bool filterMember(const glslang::TType& member);
-    spv::Id convertGlslangStructToSpvType(const glslang::TType&, const glslang::TTypeList* glslangStruct,
-                                          glslang::TLayoutPacking, const glslang::TQualifier&);
-    void decorateStructType(const glslang::TType&, const glslang::TTypeList* glslangStruct, glslang::TLayoutPacking,
-                            const glslang::TQualifier&, spv::Id);
-    spv::Id makeArraySizeId(const glslang::TArraySizes&, int dim);
-    spv::Id accessChainLoad(const glslang::TType& type);
-    void    accessChainStore(const glslang::TType& type, spv::Id rvalue);
-    void multiTypeStore(const glslang::TType&, spv::Id rValue);
-    spv::Id convertLoadedBoolInUniformToUint(const glslang::TType& type, spv::Id nominalTypeId, spv::Id loadedId);
-    glslang::TLayoutPacking getExplicitLayout(const glslang::TType& type) const;
-    int getArrayStride(const glslang::TType& arrayType, glslang::TLayoutPacking, glslang::TLayoutMatrix);
-    int getMatrixStride(const glslang::TType& matrixType, glslang::TLayoutPacking, glslang::TLayoutMatrix);
-    void updateMemberOffset(const glslang::TType& structType, const glslang::TType& memberType, int& currentOffset,
-                            int& nextOffset, glslang::TLayoutPacking, glslang::TLayoutMatrix);
-    void declareUseOfStructMember(const glslang::TTypeList& members, int glslangMember);
-
-    bool isShaderEntryPoint(const glslang::TIntermAggregate* node);
-    bool writableParam(glslang::TStorageQualifier) const;
-    bool originalParam(glslang::TStorageQualifier, const glslang::TType&, bool implicitThisParam);
-    void makeFunctions(const glslang::TIntermSequence&);
-    void makeGlobalInitializers(const glslang::TIntermSequence&);
+    bool filterMember(const qglslang::TType& member);
+    spv::Id convertGlslangStructToSpvType(const qglslang::TType&, const qglslang::TTypeList* glslangStruct,
+                                          qglslang::TLayoutPacking, const qglslang::TQualifier&);
+    void decorateStructType(const qglslang::TType&, const qglslang::TTypeList* glslangStruct, qglslang::TLayoutPacking,
+                            const qglslang::TQualifier&, spv::Id);
+    spv::Id makeArraySizeId(const qglslang::TArraySizes&, int dim);
+    spv::Id accessChainLoad(const qglslang::TType& type);
+    void    accessChainStore(const qglslang::TType& type, spv::Id rvalue);
+    void multiTypeStore(const qglslang::TType&, spv::Id rValue);
+    spv::Id convertLoadedBoolInUniformToUint(const qglslang::TType& type, spv::Id nominalTypeId, spv::Id loadedId);
+    qglslang::TLayoutPacking getExplicitLayout(const qglslang::TType& type) const;
+    int getArrayStride(const qglslang::TType& arrayType, qglslang::TLayoutPacking, qglslang::TLayoutMatrix);
+    int getMatrixStride(const qglslang::TType& matrixType, qglslang::TLayoutPacking, qglslang::TLayoutMatrix);
+    void updateMemberOffset(const qglslang::TType& structType, const qglslang::TType& memberType, int& currentOffset,
+                            int& nextOffset, qglslang::TLayoutPacking, qglslang::TLayoutMatrix);
+    void declareUseOfStructMember(const qglslang::TTypeList& members, int glslangMember);
+
+    bool isShaderEntryPoint(const qglslang::TIntermAggregate* node);
+    bool writableParam(qglslang::TStorageQualifier) const;
+    bool originalParam(qglslang::TStorageQualifier, const qglslang::TType&, bool implicitThisParam);
+    void makeFunctions(const qglslang::TIntermSequence&);
+    void makeGlobalInitializers(const qglslang::TIntermSequence&);
     void collectRayTracingLinkerObjects();
-    void visitFunctions(const glslang::TIntermSequence&);
-    void handleFunctionEntry(const glslang::TIntermAggregate* node);
-    void translateArguments(const glslang::TIntermAggregate& node, std::vector<spv::Id>& arguments,
+    void visitFunctions(const qglslang::TIntermSequence&);
+    void handleFunctionEntry(const qglslang::TIntermAggregate* node);
+    void translateArguments(const qglslang::TIntermAggregate& node, std::vector<spv::Id>& arguments,
         spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags);
-    void translateArguments(glslang::TIntermUnary& node, std::vector<spv::Id>& arguments);
-    spv::Id createImageTextureFunctionCall(glslang::TIntermOperator* node);
-    spv::Id handleUserFunctionCall(const glslang::TIntermAggregate*);
+    void translateArguments(qglslang::TIntermUnary& node, std::vector<spv::Id>& arguments);
+    spv::Id createImageTextureFunctionCall(qglslang::TIntermOperator* node);
+    spv::Id handleUserFunctionCall(const qglslang::TIntermAggregate*);
 
-    spv::Id createBinaryOperation(glslang::TOperator op, OpDecorations&, spv::Id typeId, spv::Id left, spv::Id right,
-                                  glslang::TBasicType typeProxy, bool reduceComparison = true);
+    spv::Id createBinaryOperation(qglslang::TOperator op, OpDecorations&, spv::Id typeId, spv::Id left, spv::Id right,
+                                  qglslang::TBasicType typeProxy, bool reduceComparison = true);
     spv::Id createBinaryMatrixOperation(spv::Op, OpDecorations&, spv::Id typeId, spv::Id left, spv::Id right);
-    spv::Id createUnaryOperation(glslang::TOperator op, OpDecorations&, spv::Id typeId, spv::Id operand,
-                                 glslang::TBasicType typeProxy,
+    spv::Id createUnaryOperation(qglslang::TOperator op, OpDecorations&, spv::Id typeId, spv::Id operand,
+                                 qglslang::TBasicType typeProxy,
                                  const spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags);
     spv::Id createUnaryMatrixOperation(spv::Op op, OpDecorations&, spv::Id typeId, spv::Id operand,
-                                       glslang::TBasicType typeProxy);
-    spv::Id createConversion(glslang::TOperator op, OpDecorations&, spv::Id destTypeId, spv::Id operand,
-                             glslang::TBasicType typeProxy);
-    spv::Id createIntWidthConversion(glslang::TOperator op, spv::Id operand, int vectorSize);
+                                       qglslang::TBasicType typeProxy);
+    spv::Id createConversion(qglslang::TOperator op, OpDecorations&, spv::Id destTypeId, spv::Id operand,
+                             qglslang::TBasicType typeProxy);
+    spv::Id createIntWidthConversion(qglslang::TOperator op, spv::Id operand, int vectorSize);
     spv::Id makeSmearedConstant(spv::Id constant, int vectorSize);
-    spv::Id createAtomicOperation(glslang::TOperator op, spv::Decoration precision, spv::Id typeId,
-        std::vector<spv::Id>& operands, glslang::TBasicType typeProxy,
+    spv::Id createAtomicOperation(qglslang::TOperator op, spv::Decoration precision, spv::Id typeId,
+        std::vector<spv::Id>& operands, qglslang::TBasicType typeProxy,
         const spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags);
-    spv::Id createInvocationsOperation(glslang::TOperator op, spv::Id typeId, std::vector<spv::Id>& operands,
-        glslang::TBasicType typeProxy);
+    spv::Id createInvocationsOperation(qglslang::TOperator op, spv::Id typeId, std::vector<spv::Id>& operands,
+        qglslang::TBasicType typeProxy);
     spv::Id CreateInvocationsVectorOperation(spv::Op op, spv::GroupOperation groupOperation,
         spv::Id typeId, std::vector<spv::Id>& operands);
-    spv::Id createSubgroupOperation(glslang::TOperator op, spv::Id typeId, std::vector<spv::Id>& operands,
-        glslang::TBasicType typeProxy);
-    spv::Id createMiscOperation(glslang::TOperator op, spv::Decoration precision, spv::Id typeId,
-        std::vector<spv::Id>& operands, glslang::TBasicType typeProxy);
-    spv::Id createNoArgOperation(glslang::TOperator op, spv::Decoration precision, spv::Id typeId);
-    spv::Id getSymbolId(const glslang::TIntermSymbol* node);
-    void addMeshNVDecoration(spv::Id id, int member, const glslang::TQualifier & qualifier);
-    spv::Id createSpvConstant(const glslang::TIntermTyped&);
-    spv::Id createSpvConstantFromConstUnionArray(const glslang::TType& type, const glslang::TConstUnionArray&,
+    spv::Id createSubgroupOperation(qglslang::TOperator op, spv::Id typeId, std::vector<spv::Id>& operands,
+        qglslang::TBasicType typeProxy);
+    spv::Id createMiscOperation(qglslang::TOperator op, spv::Decoration precision, spv::Id typeId,
+        std::vector<spv::Id>& operands, qglslang::TBasicType typeProxy);
+    spv::Id createNoArgOperation(qglslang::TOperator op, spv::Decoration precision, spv::Id typeId);
+    spv::Id getSymbolId(const qglslang::TIntermSymbol* node);
+    void addMeshNVDecoration(spv::Id id, int member, const qglslang::TQualifier & qualifier);
+    spv::Id createSpvConstant(const qglslang::TIntermTyped&);
+    spv::Id createSpvConstantFromConstUnionArray(const qglslang::TType& type, const qglslang::TConstUnionArray&,
         int& nextConst, bool specConstant);
-    bool isTrivialLeaf(const glslang::TIntermTyped* node);
-    bool isTrivial(const glslang::TIntermTyped* node);
-    spv::Id createShortCircuit(glslang::TOperator, glslang::TIntermTyped& left, glslang::TIntermTyped& right);
+    bool isTrivialLeaf(const qglslang::TIntermTyped* node);
+    bool isTrivial(const qglslang::TIntermTyped* node);
+    spv::Id createShortCircuit(qglslang::TOperator, qglslang::TIntermTyped& left, qglslang::TIntermTyped& right);
     spv::Id getExtBuiltins(const char* name);
-    std::pair<spv::Id, spv::Id> getForcedType(glslang::TBuiltInVariable builtIn, const glslang::TType&);
+    std::pair<spv::Id, spv::Id> getForcedType(qglslang::TBuiltInVariable builtIn, const qglslang::TType&);
     spv::Id translateForcedType(spv::Id object);
     spv::Id createCompositeConstruct(spv::Id typeId, std::vector<spv::Id> constituents);
 
-    glslang::SpvOptions& options;
+    qglslang::SpvOptions& options;
     spv::Function* shaderEntry;
     spv::Function* currentFunction;
     spv::Instruction* entryPoint;
@@ -253,7 +253,7 @@ protected:
     bool linkageOnly;                  // true when visiting the set of objects in the AST present only for
                                        // establishing interface, whether or not they were statically used
     std::set<spv::Id> iOSet;           // all input/output variables from either static use or declaration of interface
-    const glslang::TIntermediate* glslangIntermediate;
+    const qglslang::TIntermediate* glslangIntermediate;
     bool nanMinMaxClamp;               // true if use NMin/NMax/NClamp instead of FMin/FMax/FClamp
     spv::Id stdBuiltins;
     spv::Id nonSemanticDebugPrintf;
@@ -264,22 +264,22 @@ protected:
     std::unordered_set<long long> rValueParameters;  // set of formal function parameters passed as rValues,
                                                // rather than a pointer
     std::unordered_map<std::string, spv::Function*> functionMap;
-    std::unordered_map<const glslang::TTypeList*, spv::Id> structMap[glslang::ElpCount][glslang::ElmCount];
+    std::unordered_map<const qglslang::TTypeList*, spv::Id> structMap[qglslang::ElpCount][qglslang::ElmCount];
     // for mapping glslang block indices to spv indices (e.g., due to hidden members):
     std::unordered_map<long long, std::vector<int>> memberRemapper;
     // for mapping glslang symbol struct to symbol Id
-    std::unordered_map<const glslang::TTypeList*, long long> glslangTypeToIdMap;
+    std::unordered_map<const qglslang::TTypeList*, long long> glslangTypeToIdMap;
     std::stack<bool> breakForLoop;  // false means break for switch
-    std::unordered_map<std::string, const glslang::TIntermSymbol*> counterOriginator;
+    std::unordered_map<std::string, const qglslang::TIntermSymbol*> counterOriginator;
     // Map pointee types for EbtReference to their forward pointers
-    std::map<const glslang::TType *, spv::Id> forwardPointers;
+    std::map<const qglslang::TType *, spv::Id> forwardPointers;
     // Type forcing, for when SPIR-V wants a different type than the AST,
     // requiring local translation to and from SPIR-V type on every access.
     // Maps <builtin-variable-id -> AST-required-type-id>
     std::unordered_map<spv::Id, spv::Id> forceType;
 
     // Used later for generating OpTraceKHR/OpExecuteCallableKHR
-    std::unordered_map<unsigned int, glslang::TIntermSymbol *> locationToSymbol[2];
+    std::unordered_map<unsigned int, qglslang::TIntermSymbol *> locationToSymbol[2];
 };
 
 //
@@ -287,7 +287,7 @@ protected:
 //
 
 // Translate glslang profile to SPIR-V source language.
-spv::SourceLanguage TranslateSourceLanguage(glslang::EShSource source, EProfile profile)
+spv::SourceLanguage TranslateSourceLanguage(qglslang::EShSource source, EProfile profile)
 {
 #ifdef GLSLANG_WEB
     return spv::SourceLanguageESSL;
@@ -296,7 +296,7 @@ spv::SourceLanguage TranslateSourceLanguage(glslang::EShSource source, EProfile
 #endif
 
     switch (source) {
-    case glslang::EShSourceGlsl:
+    case qglslang::EShSourceGlsl:
         switch (profile) {
         case ENoProfile:
         case ECoreProfile:
@@ -307,7 +307,7 @@ spv::SourceLanguage TranslateSourceLanguage(glslang::EShSource source, EProfile
         default:
             return spv::SourceLanguageUnknown;
         }
-    case glslang::EShSourceHlsl:
+    case qglslang::EShSourceHlsl:
         return spv::SourceLanguageHLSL;
     default:
         return spv::SourceLanguageUnknown;
@@ -341,16 +341,16 @@ spv::ExecutionModel TranslateExecutionModel(EShLanguage stage)
 }
 
 // Translate glslang sampler type to SPIR-V dimensionality.
-spv::Dim TranslateDimensionality(const glslang::TSampler& sampler)
+spv::Dim TranslateDimensionality(const qglslang::TSampler& sampler)
 {
     switch (sampler.dim) {
-    case glslang::Esd1D:      return spv::Dim1D;
-    case glslang::Esd2D:      return spv::Dim2D;
-    case glslang::Esd3D:      return spv::Dim3D;
-    case glslang::EsdCube:    return spv::DimCube;
-    case glslang::EsdRect:    return spv::DimRect;
-    case glslang::EsdBuffer:  return spv::DimBuffer;
-    case glslang::EsdSubpass: return spv::DimSubpassData;
+    case qglslang::Esd1D:      return spv::Dim1D;
+    case qglslang::Esd2D:      return spv::Dim2D;
+    case qglslang::Esd3D:      return spv::Dim3D;
+    case qglslang::EsdCube:    return spv::DimCube;
+    case qglslang::EsdRect:    return spv::DimRect;
+    case qglslang::EsdBuffer:  return spv::DimBuffer;
+    case qglslang::EsdSubpass: return spv::DimSubpassData;
     default:
         assert(0);
         return spv::Dim2D;
@@ -358,38 +358,38 @@ spv::Dim TranslateDimensionality(const glslang::TSampler& sampler)
 }
 
 // Translate glslang precision to SPIR-V precision decorations.
-spv::Decoration TranslatePrecisionDecoration(glslang::TPrecisionQualifier glslangPrecision)
+spv::Decoration TranslatePrecisionDecoration(qglslang::TPrecisionQualifier glslangPrecision)
 {
     switch (glslangPrecision) {
-    case glslang::EpqLow:    return spv::DecorationRelaxedPrecision;
-    case glslang::EpqMedium: return spv::DecorationRelaxedPrecision;
+    case qglslang::EpqLow:    return spv::DecorationRelaxedPrecision;
+    case qglslang::EpqMedium: return spv::DecorationRelaxedPrecision;
     default:
         return spv::NoPrecision;
     }
 }
 
 // Translate glslang type to SPIR-V precision decorations.
-spv::Decoration TranslatePrecisionDecoration(const glslang::TType& type)
+spv::Decoration TranslatePrecisionDecoration(const qglslang::TType& type)
 {
     return TranslatePrecisionDecoration(type.getQualifier().precision);
 }
 
 // Translate glslang type to SPIR-V block decorations.
-spv::Decoration TranslateBlockDecoration(const glslang::TType& type, bool useStorageBuffer)
+spv::Decoration TranslateBlockDecoration(const qglslang::TType& type, bool useStorageBuffer)
 {
-    if (type.getBasicType() == glslang::EbtBlock) {
+    if (type.getBasicType() == qglslang::EbtBlock) {
         switch (type.getQualifier().storage) {
-        case glslang::EvqUniform:      return spv::DecorationBlock;
-        case glslang::EvqBuffer:       return useStorageBuffer ? spv::DecorationBlock : spv::DecorationBufferBlock;
-        case glslang::EvqVaryingIn:    return spv::DecorationBlock;
-        case glslang::EvqVaryingOut:   return spv::DecorationBlock;
-        case glslang::EvqShared:       return spv::DecorationBlock;
+        case qglslang::EvqUniform:      return spv::DecorationBlock;
+        case qglslang::EvqBuffer:       return useStorageBuffer ? spv::DecorationBlock : spv::DecorationBufferBlock;
+        case qglslang::EvqVaryingIn:    return spv::DecorationBlock;
+        case qglslang::EvqVaryingOut:   return spv::DecorationBlock;
+        case qglslang::EvqShared:       return spv::DecorationBlock;
 #ifndef GLSLANG_WEB
-        case glslang::EvqPayload:      return spv::DecorationBlock;
-        case glslang::EvqPayloadIn:    return spv::DecorationBlock;
-        case glslang::EvqHitAttr:      return spv::DecorationBlock;
-        case glslang::EvqCallableData:   return spv::DecorationBlock;
-        case glslang::EvqCallableDataIn: return spv::DecorationBlock;
+        case qglslang::EvqPayload:      return spv::DecorationBlock;
+        case qglslang::EvqPayloadIn:    return spv::DecorationBlock;
+        case qglslang::EvqHitAttr:      return spv::DecorationBlock;
+        case qglslang::EvqCallableData:   return spv::DecorationBlock;
+        case qglslang::EvqCallableDataIn: return spv::DecorationBlock;
 #endif
         default:
             assert(0);
@@ -401,7 +401,7 @@ spv::Decoration TranslateBlockDecoration(const glslang::TType& type, bool useSto
 }
 
 // Translate glslang type to SPIR-V memory decorations.
-void TranslateMemoryDecoration(const glslang::TQualifier& qualifier, std::vector<spv::Decoration>& memory,
+void TranslateMemoryDecoration(const qglslang::TQualifier& qualifier, std::vector<spv::Decoration>& memory,
     bool useVulkanMemoryModel)
 {
     if (!useVulkanMemoryModel) {
@@ -421,13 +421,13 @@ void TranslateMemoryDecoration(const glslang::TQualifier& qualifier, std::vector
 }
 
 // Translate glslang type to SPIR-V layout decorations.
-spv::Decoration TranslateLayoutDecoration(const glslang::TType& type, glslang::TLayoutMatrix matrixLayout)
+spv::Decoration TranslateLayoutDecoration(const qglslang::TType& type, qglslang::TLayoutMatrix matrixLayout)
 {
     if (type.isMatrix()) {
         switch (matrixLayout) {
-        case glslang::ElmRowMajor:
+        case qglslang::ElmRowMajor:
             return spv::DecorationRowMajor;
-        case glslang::ElmColumnMajor:
+        case qglslang::ElmColumnMajor:
             return spv::DecorationColMajor;
         default:
             // opaque layouts don't need a majorness
@@ -438,35 +438,35 @@ spv::Decoration TranslateLayoutDecoration(const glslang::TType& type, glslang::T
         default:
             return spv::DecorationMax;
             break;
-        case glslang::EbtBlock:
+        case qglslang::EbtBlock:
             switch (type.getQualifier().storage) {
-            case glslang::EvqShared:
-            case glslang::EvqUniform:
-            case glslang::EvqBuffer:
+            case qglslang::EvqShared:
+            case qglslang::EvqUniform:
+            case qglslang::EvqBuffer:
                 switch (type.getQualifier().layoutPacking) {
-                case glslang::ElpShared:  return spv::DecorationGLSLShared;
-                case glslang::ElpPacked:  return spv::DecorationGLSLPacked;
+                case qglslang::ElpShared:  return spv::DecorationGLSLShared;
+                case qglslang::ElpPacked:  return spv::DecorationGLSLPacked;
                 default:
                     return spv::DecorationMax;
                 }
-            case glslang::EvqVaryingIn:
-            case glslang::EvqVaryingOut:
+            case qglslang::EvqVaryingIn:
+            case qglslang::EvqVaryingOut:
                 if (type.getQualifier().isTaskMemory()) {
                     switch (type.getQualifier().layoutPacking) {
-                    case glslang::ElpShared:  return spv::DecorationGLSLShared;
-                    case glslang::ElpPacked:  return spv::DecorationGLSLPacked;
+                    case qglslang::ElpShared:  return spv::DecorationGLSLShared;
+                    case qglslang::ElpPacked:  return spv::DecorationGLSLPacked;
                     default: break;
                     }
                 } else {
-                    assert(type.getQualifier().layoutPacking == glslang::ElpNone);
+                    assert(type.getQualifier().layoutPacking == qglslang::ElpNone);
                 }
                 return spv::DecorationMax;
 #ifndef GLSLANG_WEB
-            case glslang::EvqPayload:
-            case glslang::EvqPayloadIn:
-            case glslang::EvqHitAttr:
-            case glslang::EvqCallableData:
-            case glslang::EvqCallableDataIn:
+            case qglslang::EvqPayload:
+            case qglslang::EvqPayloadIn:
+            case qglslang::EvqHitAttr:
+            case qglslang::EvqCallableData:
+            case qglslang::EvqCallableDataIn:
                 return spv::DecorationMax;
 #endif
             default:
@@ -480,7 +480,7 @@ spv::Decoration TranslateLayoutDecoration(const glslang::TType& type, glslang::T
 // Translate glslang type to SPIR-V interpolation decorations.
 // Returns spv::DecorationMax when no decoration
 // should be applied.
-spv::Decoration TGlslangToSpvTraverser::TranslateInterpolationDecoration(const glslang::TQualifier& qualifier)
+spv::Decoration TGlslangToSpvTraverser::TranslateInterpolationDecoration(const qglslang::TQualifier& qualifier)
 {
     if (qualifier.smooth)
         // Smooth decoration doesn't exist in SPIR-V 1.0
@@ -500,7 +500,7 @@ spv::Decoration TGlslangToSpvTraverser::TranslateInterpolationDecoration(const g
 // Translate glslang type to SPIR-V auxiliary storage decorations.
 // Returns spv::DecorationMax when no decoration
 // should be applied.
-spv::Decoration TGlslangToSpvTraverser::TranslateAuxiliaryStorageDecoration(const glslang::TQualifier& qualifier)
+spv::Decoration TGlslangToSpvTraverser::TranslateAuxiliaryStorageDecoration(const qglslang::TQualifier& qualifier)
 {
     if (qualifier.centroid)
         return spv::DecorationCentroid;
@@ -517,7 +517,7 @@ spv::Decoration TGlslangToSpvTraverser::TranslateAuxiliaryStorageDecoration(cons
 }
 
 // If glslang type is invariant, return SPIR-V invariant decoration.
-spv::Decoration TranslateInvariantDecoration(const glslang::TQualifier& qualifier)
+spv::Decoration TranslateInvariantDecoration(const qglslang::TQualifier& qualifier)
 {
     if (qualifier.invariant)
         return spv::DecorationInvariant;
@@ -526,7 +526,7 @@ spv::Decoration TranslateInvariantDecoration(const glslang::TQualifier& qualifie
 }
 
 // If glslang type is noContraction, return SPIR-V NoContraction decoration.
-spv::Decoration TranslateNoContractionDecoration(const glslang::TQualifier& qualifier)
+spv::Decoration TranslateNoContractionDecoration(const qglslang::TQualifier& qualifier)
 {
 #ifndef GLSLANG_WEB
     if (qualifier.isNoContraction())
@@ -537,7 +537,7 @@ spv::Decoration TranslateNoContractionDecoration(const glslang::TQualifier& qual
 }
 
 // If glslang type is nonUniform, return SPIR-V NonUniform decoration.
-spv::Decoration TGlslangToSpvTraverser::TranslateNonUniformDecoration(const glslang::TQualifier& qualifier)
+spv::Decoration TGlslangToSpvTraverser::TranslateNonUniformDecoration(const qglslang::TQualifier& qualifier)
 {
 #ifndef GLSLANG_WEB
     if (qualifier.isNonUniform()) {
@@ -619,7 +619,7 @@ spv::ImageOperandsMask TGlslangToSpvTraverser::TranslateImageOperands(
     return mask;
 }
 
-spv::Builder::AccessChain::CoherentFlags TGlslangToSpvTraverser::TranslateCoherent(const glslang::TType& type)
+spv::Builder::AccessChain::CoherentFlags TGlslangToSpvTraverser::TranslateCoherent(const qglslang::TType& type)
 {
     spv::Builder::AccessChain::CoherentFlags flags = {};
 #ifndef GLSLANG_WEB
@@ -628,7 +628,7 @@ spv::Builder::AccessChain::CoherentFlags TGlslangToSpvTraverser::TranslateCohere
     flags.queuefamilycoherent = type.getQualifier().queuefamilycoherent;
     // shared variables are implicitly workgroupcoherent in GLSL.
     flags.workgroupcoherent = type.getQualifier().workgroupcoherent ||
-                              type.getQualifier().storage == glslang::EvqShared;
+                              type.getQualifier().storage == qglslang::EvqShared;
     flags.subgroupcoherent = type.getQualifier().subgroupcoherent;
     flags.shadercallcoherent = type.getQualifier().shadercallcoherent;
     flags.volatil = type.getQualifier().volatil;
@@ -636,7 +636,7 @@ spv::Builder::AccessChain::CoherentFlags TGlslangToSpvTraverser::TranslateCohere
     flags.nonprivate = type.getQualifier().nonprivate ||
                        flags.anyCoherent() ||
                        flags.volatil;
-    flags.isImage = type.getBasicType() == glslang::EbtSampler;
+    flags.isImage = type.getBasicType() == qglslang::EbtSampler;
 #endif
     flags.nonUniform = type.getQualifier().nonUniform;
     return flags;
@@ -675,11 +675,11 @@ spv::Scope TGlslangToSpvTraverser::TranslateMemoryScope(
 // is generated only when using the variable in an executable instruction, but not when
 // just declaring a struct member variable with it.  This is true for PointSize,
 // ClipDistance, and CullDistance.
-spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltInVariable builtIn,
+spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(qglslang::TBuiltInVariable builtIn,
     bool memberDeclaration)
 {
     switch (builtIn) {
-    case glslang::EbvPointSize:
+    case qglslang::EbvPointSize:
 #ifndef GLSLANG_WEB
         // Defer adding the capability until the built-in is actually used.
         if (! memberDeclaration) {
@@ -698,23 +698,23 @@ spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltI
 #endif
         return spv::BuiltInPointSize;
 
-    case glslang::EbvPosition:             return spv::BuiltInPosition;
-    case glslang::EbvVertexId:             return spv::BuiltInVertexId;
-    case glslang::EbvInstanceId:           return spv::BuiltInInstanceId;
-    case glslang::EbvVertexIndex:          return spv::BuiltInVertexIndex;
-    case glslang::EbvInstanceIndex:        return spv::BuiltInInstanceIndex;
+    case qglslang::EbvPosition:             return spv::BuiltInPosition;
+    case qglslang::EbvVertexId:             return spv::BuiltInVertexId;
+    case qglslang::EbvInstanceId:           return spv::BuiltInInstanceId;
+    case qglslang::EbvVertexIndex:          return spv::BuiltInVertexIndex;
+    case qglslang::EbvInstanceIndex:        return spv::BuiltInInstanceIndex;
 
-    case glslang::EbvFragCoord:            return spv::BuiltInFragCoord;
-    case glslang::EbvPointCoord:           return spv::BuiltInPointCoord;
-    case glslang::EbvFace:                 return spv::BuiltInFrontFacing;
-    case glslang::EbvFragDepth:            return spv::BuiltInFragDepth;
+    case qglslang::EbvFragCoord:            return spv::BuiltInFragCoord;
+    case qglslang::EbvPointCoord:           return spv::BuiltInPointCoord;
+    case qglslang::EbvFace:                 return spv::BuiltInFrontFacing;
+    case qglslang::EbvFragDepth:            return spv::BuiltInFragDepth;
 
-    case glslang::EbvNumWorkGroups:        return spv::BuiltInNumWorkgroups;
-    case glslang::EbvWorkGroupSize:        return spv::BuiltInWorkgroupSize;
-    case glslang::EbvWorkGroupId:          return spv::BuiltInWorkgroupId;
-    case glslang::EbvLocalInvocationId:    return spv::BuiltInLocalInvocationId;
-    case glslang::EbvLocalInvocationIndex: return spv::BuiltInLocalInvocationIndex;
-    case glslang::EbvGlobalInvocationId:   return spv::BuiltInGlobalInvocationId;
+    case qglslang::EbvNumWorkGroups:        return spv::BuiltInNumWorkgroups;
+    case qglslang::EbvWorkGroupSize:        return spv::BuiltInWorkgroupSize;
+    case qglslang::EbvWorkGroupId:          return spv::BuiltInWorkgroupId;
+    case qglslang::EbvLocalInvocationId:    return spv::BuiltInLocalInvocationId;
+    case qglslang::EbvLocalInvocationIndex: return spv::BuiltInLocalInvocationIndex;
+    case qglslang::EbvGlobalInvocationId:   return spv::BuiltInGlobalInvocationId;
 
 #ifndef GLSLANG_WEB
     // These *Distance capabilities logically belong here, but if the member is declared and
@@ -723,17 +723,17 @@ spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltI
     // Potentially, the specification should be more clear what the minimum
     // use needed is to trigger the capability.
     //
-    case glslang::EbvClipDistance:
+    case qglslang::EbvClipDistance:
         if (!memberDeclaration)
             builder.addCapability(spv::CapabilityClipDistance);
         return spv::BuiltInClipDistance;
 
-    case glslang::EbvCullDistance:
+    case qglslang::EbvCullDistance:
         if (!memberDeclaration)
             builder.addCapability(spv::CapabilityCullDistance);
         return spv::BuiltInCullDistance;
 
-    case glslang::EbvViewportIndex:
+    case qglslang::EbvViewportIndex:
         if (glslangIntermediate->getStage() == EShLangGeometry ||
             glslangIntermediate->getStage() == EShLangFragment) {
             builder.addCapability(spv::CapabilityMultiViewport);
@@ -751,18 +751,18 @@ spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltI
         }
         return spv::BuiltInViewportIndex;
 
-    case glslang::EbvSampleId:
+    case qglslang::EbvSampleId:
         builder.addCapability(spv::CapabilitySampleRateShading);
         return spv::BuiltInSampleId;
 
-    case glslang::EbvSamplePosition:
+    case qglslang::EbvSamplePosition:
         builder.addCapability(spv::CapabilitySampleRateShading);
         return spv::BuiltInSamplePosition;
 
-    case glslang::EbvSampleMask:
+    case qglslang::EbvSampleMask:
         return spv::BuiltInSampleMask;
 
-    case glslang::EbvLayer:
+    case qglslang::EbvLayer:
         if (glslangIntermediate->getStage() == EShLangMeshNV) {
             return spv::BuiltInLayer;
         }
@@ -782,237 +782,237 @@ spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltI
         }
         return spv::BuiltInLayer;
 
-    case glslang::EbvBaseVertex:
+    case qglslang::EbvBaseVertex:
         builder.addIncorporatedExtension(spv::E_SPV_KHR_shader_draw_parameters, spv::Spv_1_3);
         builder.addCapability(spv::CapabilityDrawParameters);
         return spv::BuiltInBaseVertex;
 
-    case glslang::EbvBaseInstance:
+    case qglslang::EbvBaseInstance:
         builder.addIncorporatedExtension(spv::E_SPV_KHR_shader_draw_parameters, spv::Spv_1_3);
         builder.addCapability(spv::CapabilityDrawParameters);
         return spv::BuiltInBaseInstance;
 
-    case glslang::EbvDrawId:
+    case qglslang::EbvDrawId:
         builder.addIncorporatedExtension(spv::E_SPV_KHR_shader_draw_parameters, spv::Spv_1_3);
         builder.addCapability(spv::CapabilityDrawParameters);
         return spv::BuiltInDrawIndex;
 
-    case glslang::EbvPrimitiveId:
+    case qglslang::EbvPrimitiveId:
         if (glslangIntermediate->getStage() == EShLangFragment)
             builder.addCapability(spv::CapabilityGeometry);
         return spv::BuiltInPrimitiveId;
 
-    case glslang::EbvFragStencilRef:
+    case qglslang::EbvFragStencilRef:
         builder.addExtension(spv::E_SPV_EXT_shader_stencil_export);
         builder.addCapability(spv::CapabilityStencilExportEXT);
         return spv::BuiltInFragStencilRefEXT;
 
-    case glslang::EbvShadingRateKHR:
+    case qglslang::EbvShadingRateKHR:
         builder.addExtension(spv::E_SPV_KHR_fragment_shading_rate);
         builder.addCapability(spv::CapabilityFragmentShadingRateKHR);
         return spv::BuiltInShadingRateKHR;
 
-    case glslang::EbvPrimitiveShadingRateKHR:
+    case qglslang::EbvPrimitiveShadingRateKHR:
         builder.addExtension(spv::E_SPV_KHR_fragment_shading_rate);
         builder.addCapability(spv::CapabilityFragmentShadingRateKHR);
         return spv::BuiltInPrimitiveShadingRateKHR;
 
-    case glslang::EbvInvocationId:         return spv::BuiltInInvocationId;
-    case glslang::EbvTessLevelInner:       return spv::BuiltInTessLevelInner;
-    case glslang::EbvTessLevelOuter:       return spv::BuiltInTessLevelOuter;
-    case glslang::EbvTessCoord:            return spv::BuiltInTessCoord;
-    case glslang::EbvPatchVertices:        return spv::BuiltInPatchVertices;
-    case glslang::EbvHelperInvocation:     return spv::BuiltInHelperInvocation;
+    case qglslang::EbvInvocationId:         return spv::BuiltInInvocationId;
+    case qglslang::EbvTessLevelInner:       return spv::BuiltInTessLevelInner;
+    case qglslang::EbvTessLevelOuter:       return spv::BuiltInTessLevelOuter;
+    case qglslang::EbvTessCoord:            return spv::BuiltInTessCoord;
+    case qglslang::EbvPatchVertices:        return spv::BuiltInPatchVertices;
+    case qglslang::EbvHelperInvocation:     return spv::BuiltInHelperInvocation;
 
-    case glslang::EbvSubGroupSize:
+    case qglslang::EbvSubGroupSize:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupSize;
 
-    case glslang::EbvSubGroupInvocation:
+    case qglslang::EbvSubGroupInvocation:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupLocalInvocationId;
 
-    case glslang::EbvSubGroupEqMask:
+    case qglslang::EbvSubGroupEqMask:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupEqMask;
 
-    case glslang::EbvSubGroupGeMask:
+    case qglslang::EbvSubGroupGeMask:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupGeMask;
 
-    case glslang::EbvSubGroupGtMask:
+    case qglslang::EbvSubGroupGtMask:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupGtMask;
 
-    case glslang::EbvSubGroupLeMask:
+    case qglslang::EbvSubGroupLeMask:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupLeMask;
 
-    case glslang::EbvSubGroupLtMask:
+    case qglslang::EbvSubGroupLtMask:
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
         return spv::BuiltInSubgroupLtMask;
 
-    case glslang::EbvNumSubgroups:
+    case qglslang::EbvNumSubgroups:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         return spv::BuiltInNumSubgroups;
 
-    case glslang::EbvSubgroupID:
+    case qglslang::EbvSubgroupID:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         return spv::BuiltInSubgroupId;
 
-    case glslang::EbvSubgroupSize2:
+    case qglslang::EbvSubgroupSize2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         return spv::BuiltInSubgroupSize;
 
-    case glslang::EbvSubgroupInvocation2:
+    case qglslang::EbvSubgroupInvocation2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         return spv::BuiltInSubgroupLocalInvocationId;
 
-    case glslang::EbvSubgroupEqMask2:
+    case qglslang::EbvSubgroupEqMask2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformBallot);
         return spv::BuiltInSubgroupEqMask;
 
-    case glslang::EbvSubgroupGeMask2:
+    case qglslang::EbvSubgroupGeMask2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformBallot);
         return spv::BuiltInSubgroupGeMask;
 
-    case glslang::EbvSubgroupGtMask2:
+    case qglslang::EbvSubgroupGtMask2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformBallot);
         return spv::BuiltInSubgroupGtMask;
 
-    case glslang::EbvSubgroupLeMask2:
+    case qglslang::EbvSubgroupLeMask2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformBallot);
         return spv::BuiltInSubgroupLeMask;
 
-    case glslang::EbvSubgroupLtMask2:
+    case qglslang::EbvSubgroupLtMask2:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformBallot);
         return spv::BuiltInSubgroupLtMask;
 
-    case glslang::EbvBaryCoordNoPersp:
+    case qglslang::EbvBaryCoordNoPersp:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordNoPerspAMD;
 
-    case glslang::EbvBaryCoordNoPerspCentroid:
+    case qglslang::EbvBaryCoordNoPerspCentroid:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordNoPerspCentroidAMD;
 
-    case glslang::EbvBaryCoordNoPerspSample:
+    case qglslang::EbvBaryCoordNoPerspSample:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordNoPerspSampleAMD;
 
-    case glslang::EbvBaryCoordSmooth:
+    case qglslang::EbvBaryCoordSmooth:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordSmoothAMD;
 
-    case glslang::EbvBaryCoordSmoothCentroid:
+    case qglslang::EbvBaryCoordSmoothCentroid:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordSmoothCentroidAMD;
 
-    case glslang::EbvBaryCoordSmoothSample:
+    case qglslang::EbvBaryCoordSmoothSample:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordSmoothSampleAMD;
 
-    case glslang::EbvBaryCoordPullModel:
+    case qglslang::EbvBaryCoordPullModel:
         builder.addExtension(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         return spv::BuiltInBaryCoordPullModelAMD;
 
-    case glslang::EbvDeviceIndex:
+    case qglslang::EbvDeviceIndex:
         builder.addIncorporatedExtension(spv::E_SPV_KHR_device_group, spv::Spv_1_3);
         builder.addCapability(spv::CapabilityDeviceGroup);
         return spv::BuiltInDeviceIndex;
 
-    case glslang::EbvViewIndex:
+    case qglslang::EbvViewIndex:
         builder.addIncorporatedExtension(spv::E_SPV_KHR_multiview, spv::Spv_1_3);
         builder.addCapability(spv::CapabilityMultiView);
         return spv::BuiltInViewIndex;
 
-    case glslang::EbvFragSizeEXT:
+    case qglslang::EbvFragSizeEXT:
         builder.addExtension(spv::E_SPV_EXT_fragment_invocation_density);
         builder.addCapability(spv::CapabilityFragmentDensityEXT);
         return spv::BuiltInFragSizeEXT;
 
-    case glslang::EbvFragInvocationCountEXT:
+    case qglslang::EbvFragInvocationCountEXT:
         builder.addExtension(spv::E_SPV_EXT_fragment_invocation_density);
         builder.addCapability(spv::CapabilityFragmentDensityEXT);
         return spv::BuiltInFragInvocationCountEXT;
 
-    case glslang::EbvViewportMaskNV:
+    case qglslang::EbvViewportMaskNV:
         if (!memberDeclaration) {
             builder.addExtension(spv::E_SPV_NV_viewport_array2);
             builder.addCapability(spv::CapabilityShaderViewportMaskNV);
         }
         return spv::BuiltInViewportMaskNV;
-    case glslang::EbvSecondaryPositionNV:
+    case qglslang::EbvSecondaryPositionNV:
         if (!memberDeclaration) {
             builder.addExtension(spv::E_SPV_NV_stereo_view_rendering);
             builder.addCapability(spv::CapabilityShaderStereoViewNV);
         }
         return spv::BuiltInSecondaryPositionNV;
-    case glslang::EbvSecondaryViewportMaskNV:
+    case qglslang::EbvSecondaryViewportMaskNV:
         if (!memberDeclaration) {
             builder.addExtension(spv::E_SPV_NV_stereo_view_rendering);
             builder.addCapability(spv::CapabilityShaderStereoViewNV);
         }
         return spv::BuiltInSecondaryViewportMaskNV;
-    case glslang::EbvPositionPerViewNV:
+    case qglslang::EbvPositionPerViewNV:
         if (!memberDeclaration) {
             builder.addExtension(spv::E_SPV_NVX_multiview_per_view_attributes);
             builder.addCapability(spv::CapabilityPerViewAttributesNV);
         }
         return spv::BuiltInPositionPerViewNV;
-    case glslang::EbvViewportMaskPerViewNV:
+    case qglslang::EbvViewportMaskPerViewNV:
         if (!memberDeclaration) {
             builder.addExtension(spv::E_SPV_NVX_multiview_per_view_attributes);
             builder.addCapability(spv::CapabilityPerViewAttributesNV);
         }
         return spv::BuiltInViewportMaskPerViewNV;
-    case glslang::EbvFragFullyCoveredNV:
+    case qglslang::EbvFragFullyCoveredNV:
         builder.addExtension(spv::E_SPV_EXT_fragment_fully_covered);
         builder.addCapability(spv::CapabilityFragmentFullyCoveredEXT);
         return spv::BuiltInFullyCoveredEXT;
-    case glslang::EbvFragmentSizeNV:
+    case qglslang::EbvFragmentSizeNV:
         builder.addExtension(spv::E_SPV_NV_shading_rate);
         builder.addCapability(spv::CapabilityShadingRateNV);
         return spv::BuiltInFragmentSizeNV;
-    case glslang::EbvInvocationsPerPixelNV:
+    case qglslang::EbvInvocationsPerPixelNV:
         builder.addExtension(spv::E_SPV_NV_shading_rate);
         builder.addCapability(spv::CapabilityShadingRateNV);
         return spv::BuiltInInvocationsPerPixelNV;
 
     // ray tracing
-    case glslang::EbvLaunchId:
+    case qglslang::EbvLaunchId:
         return spv::BuiltInLaunchIdKHR;
-    case glslang::EbvLaunchSize:
+    case qglslang::EbvLaunchSize:
         return spv::BuiltInLaunchSizeKHR;
-    case glslang::EbvWorldRayOrigin:
+    case qglslang::EbvWorldRayOrigin:
         return spv::BuiltInWorldRayOriginKHR;
-    case glslang::EbvWorldRayDirection:
+    case qglslang::EbvWorldRayDirection:
         return spv::BuiltInWorldRayDirectionKHR;
-    case glslang::EbvObjectRayOrigin:
+    case qglslang::EbvObjectRayOrigin:
         return spv::BuiltInObjectRayOriginKHR;
-    case glslang::EbvObjectRayDirection:
+    case qglslang::EbvObjectRayDirection:
         return spv::BuiltInObjectRayDirectionKHR;
-    case glslang::EbvRayTmin:
+    case qglslang::EbvRayTmin:
         return spv::BuiltInRayTminKHR;
-    case glslang::EbvRayTmax:
+    case qglslang::EbvRayTmax:
         return spv::BuiltInRayTmaxKHR;
-    case glslang::EbvCullMask:
+    case qglslang::EbvCullMask:
         return spv::BuiltInCullMaskKHR;
-    case glslang::EbvInstanceCustomIndex:
+    case qglslang::EbvInstanceCustomIndex:
         return spv::BuiltInInstanceCustomIndexKHR;
-    case glslang::EbvHitT:
+    case qglslang::EbvHitT:
         {
             // this is a GLSL alias of RayTmax
             // in SPV_NV_ray_tracing it has a dedicated builtin
@@ -1024,74 +1024,74 @@ spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltI
                 return spv::BuiltInRayTmaxKHR;
             }
         }
-    case glslang::EbvHitKind:
+    case qglslang::EbvHitKind:
         return spv::BuiltInHitKindKHR;
-    case glslang::EbvObjectToWorld:
-    case glslang::EbvObjectToWorld3x4:
+    case qglslang::EbvObjectToWorld:
+    case qglslang::EbvObjectToWorld3x4:
         return spv::BuiltInObjectToWorldKHR;
-    case glslang::EbvWorldToObject:
-    case glslang::EbvWorldToObject3x4:
+    case qglslang::EbvWorldToObject:
+    case qglslang::EbvWorldToObject3x4:
         return spv::BuiltInWorldToObjectKHR;
-    case glslang::EbvIncomingRayFlags:
+    case qglslang::EbvIncomingRayFlags:
         return spv::BuiltInIncomingRayFlagsKHR;
-    case glslang::EbvGeometryIndex:
+    case qglslang::EbvGeometryIndex:
         return spv::BuiltInRayGeometryIndexKHR;
-    case glslang::EbvCurrentRayTimeNV:
+    case qglslang::EbvCurrentRayTimeNV:
         builder.addExtension(spv::E_SPV_NV_ray_tracing_motion_blur);
         builder.addCapability(spv::CapabilityRayTracingMotionBlurNV);
         return spv::BuiltInCurrentRayTimeNV;
 
     // barycentrics
-    case glslang::EbvBaryCoordNV:
+    case qglslang::EbvBaryCoordNV:
         builder.addExtension(spv::E_SPV_NV_fragment_shader_barycentric);
         builder.addCapability(spv::CapabilityFragmentBarycentricNV);
         return spv::BuiltInBaryCoordNV;
-    case glslang::EbvBaryCoordNoPerspNV:
+    case qglslang::EbvBaryCoordNoPerspNV:
         builder.addExtension(spv::E_SPV_NV_fragment_shader_barycentric);
         builder.addCapability(spv::CapabilityFragmentBarycentricNV);
         return spv::BuiltInBaryCoordNoPerspNV;
 
-    case glslang::EbvBaryCoordEXT:
+    case qglslang::EbvBaryCoordEXT:
         builder.addExtension(spv::E_SPV_KHR_fragment_shader_barycentric);
         builder.addCapability(spv::CapabilityFragmentBarycentricKHR);
         return spv::BuiltInBaryCoordKHR;
-    case glslang::EbvBaryCoordNoPerspEXT:
+    case qglslang::EbvBaryCoordNoPerspEXT:
         builder.addExtension(spv::E_SPV_KHR_fragment_shader_barycentric);
         builder.addCapability(spv::CapabilityFragmentBarycentricKHR);
         return spv::BuiltInBaryCoordNoPerspKHR;
 
     // mesh shaders
-    case glslang::EbvTaskCountNV:
+    case qglslang::EbvTaskCountNV:
         return spv::BuiltInTaskCountNV;
-    case glslang::EbvPrimitiveCountNV:
+    case qglslang::EbvPrimitiveCountNV:
         return spv::BuiltInPrimitiveCountNV;
-    case glslang::EbvPrimitiveIndicesNV:
+    case qglslang::EbvPrimitiveIndicesNV:
         return spv::BuiltInPrimitiveIndicesNV;
-    case glslang::EbvClipDistancePerViewNV:
+    case qglslang::EbvClipDistancePerViewNV:
         return spv::BuiltInClipDistancePerViewNV;
-    case glslang::EbvCullDistancePerViewNV:
+    case qglslang::EbvCullDistancePerViewNV:
         return spv::BuiltInCullDistancePerViewNV;
-    case glslang::EbvLayerPerViewNV:
+    case qglslang::EbvLayerPerViewNV:
         return spv::BuiltInLayerPerViewNV;
-    case glslang::EbvMeshViewCountNV:
+    case qglslang::EbvMeshViewCountNV:
         return spv::BuiltInMeshViewCountNV;
-    case glslang::EbvMeshViewIndicesNV:
+    case qglslang::EbvMeshViewIndicesNV:
         return spv::BuiltInMeshViewIndicesNV;
 
     // sm builtins
-    case glslang::EbvWarpsPerSM:
+    case qglslang::EbvWarpsPerSM:
         builder.addExtension(spv::E_SPV_NV_shader_sm_builtins);
         builder.addCapability(spv::CapabilityShaderSMBuiltinsNV);
         return spv::BuiltInWarpsPerSMNV;
-    case glslang::EbvSMCount:
+    case qglslang::EbvSMCount:
         builder.addExtension(spv::E_SPV_NV_shader_sm_builtins);
         builder.addCapability(spv::CapabilityShaderSMBuiltinsNV);
         return spv::BuiltInSMCountNV;
-    case glslang::EbvWarpID:
+    case qglslang::EbvWarpID:
         builder.addExtension(spv::E_SPV_NV_shader_sm_builtins);
         builder.addCapability(spv::CapabilityShaderSMBuiltinsNV);
         return spv::BuiltInWarpIDNV;
-    case glslang::EbvSMID:
+    case qglslang::EbvSMID:
         builder.addExtension(spv::E_SPV_NV_shader_sm_builtins);
         builder.addCapability(spv::CapabilityShaderSMBuiltinsNV);
         return spv::BuiltInSMIDNV;
@@ -1103,9 +1103,9 @@ spv::BuiltIn TGlslangToSpvTraverser::TranslateBuiltInDecoration(glslang::TBuiltI
 }
 
 // Translate glslang image layout format to SPIR-V image format.
-spv::ImageFormat TGlslangToSpvTraverser::TranslateImageFormat(const glslang::TType& type)
+spv::ImageFormat TGlslangToSpvTraverser::TranslateImageFormat(const qglslang::TType& type)
 {
-    assert(type.getBasicType() == glslang::EbtSampler);
+    assert(type.getBasicType() == qglslang::EbtSampler);
 
 #ifdef GLSLANG_WEB
     return spv::ImageFormatUnknown;
@@ -1113,39 +1113,39 @@ spv::ImageFormat TGlslangToSpvTraverser::TranslateImageFormat(const glslang::TTy
 
     // Check for capabilities
     switch (type.getQualifier().getFormat()) {
-    case glslang::ElfRg32f:
-    case glslang::ElfRg16f:
-    case glslang::ElfR11fG11fB10f:
-    case glslang::ElfR16f:
-    case glslang::ElfRgba16:
-    case glslang::ElfRgb10A2:
-    case glslang::ElfRg16:
-    case glslang::ElfRg8:
-    case glslang::ElfR16:
-    case glslang::ElfR8:
-    case glslang::ElfRgba16Snorm:
-    case glslang::ElfRg16Snorm:
-    case glslang::ElfRg8Snorm:
-    case glslang::ElfR16Snorm:
-    case glslang::ElfR8Snorm:
-
-    case glslang::ElfRg32i:
-    case glslang::ElfRg16i:
-    case glslang::ElfRg8i:
-    case glslang::ElfR16i:
-    case glslang::ElfR8i:
-
-    case glslang::ElfRgb10a2ui:
-    case glslang::ElfRg32ui:
-    case glslang::ElfRg16ui:
-    case glslang::ElfRg8ui:
-    case glslang::ElfR16ui:
-    case glslang::ElfR8ui:
+    case qglslang::ElfRg32f:
+    case qglslang::ElfRg16f:
+    case qglslang::ElfR11fG11fB10f:
+    case qglslang::ElfR16f:
+    case qglslang::ElfRgba16:
+    case qglslang::ElfRgb10A2:
+    case qglslang::ElfRg16:
+    case qglslang::ElfRg8:
+    case qglslang::ElfR16:
+    case qglslang::ElfR8:
+    case qglslang::ElfRgba16Snorm:
+    case qglslang::ElfRg16Snorm:
+    case qglslang::ElfRg8Snorm:
+    case qglslang::ElfR16Snorm:
+    case qglslang::ElfR8Snorm:
+
+    case qglslang::ElfRg32i:
+    case qglslang::ElfRg16i:
+    case qglslang::ElfRg8i:
+    case qglslang::ElfR16i:
+    case qglslang::ElfR8i:
+
+    case qglslang::ElfRgb10a2ui:
+    case qglslang::ElfRg32ui:
+    case qglslang::ElfRg16ui:
+    case qglslang::ElfRg8ui:
+    case qglslang::ElfR16ui:
+    case qglslang::ElfR8ui:
         builder.addCapability(spv::CapabilityStorageImageExtendedFormats);
         break;
 
-    case glslang::ElfR64ui:
-    case glslang::ElfR64i:
+    case qglslang::ElfR64ui:
+    case qglslang::ElfR64i:
         builder.addExtension(spv::E_SPV_EXT_shader_image_int64);
         builder.addCapability(spv::CapabilityInt64ImageEXT);
     default:
@@ -1154,54 +1154,54 @@ spv::ImageFormat TGlslangToSpvTraverser::TranslateImageFormat(const glslang::TTy
 
     // do the translation
     switch (type.getQualifier().getFormat()) {
-    case glslang::ElfNone:          return spv::ImageFormatUnknown;
-    case glslang::ElfRgba32f:       return spv::ImageFormatRgba32f;
-    case glslang::ElfRgba16f:       return spv::ImageFormatRgba16f;
-    case glslang::ElfR32f:          return spv::ImageFormatR32f;
-    case glslang::ElfRgba8:         return spv::ImageFormatRgba8;
-    case glslang::ElfRgba8Snorm:    return spv::ImageFormatRgba8Snorm;
-    case glslang::ElfRg32f:         return spv::ImageFormatRg32f;
-    case glslang::ElfRg16f:         return spv::ImageFormatRg16f;
-    case glslang::ElfR11fG11fB10f:  return spv::ImageFormatR11fG11fB10f;
-    case glslang::ElfR16f:          return spv::ImageFormatR16f;
-    case glslang::ElfRgba16:        return spv::ImageFormatRgba16;
-    case glslang::ElfRgb10A2:       return spv::ImageFormatRgb10A2;
-    case glslang::ElfRg16:          return spv::ImageFormatRg16;
-    case glslang::ElfRg8:           return spv::ImageFormatRg8;
-    case glslang::ElfR16:           return spv::ImageFormatR16;
-    case glslang::ElfR8:            return spv::ImageFormatR8;
-    case glslang::ElfRgba16Snorm:   return spv::ImageFormatRgba16Snorm;
-    case glslang::ElfRg16Snorm:     return spv::ImageFormatRg16Snorm;
-    case glslang::ElfRg8Snorm:      return spv::ImageFormatRg8Snorm;
-    case glslang::ElfR16Snorm:      return spv::ImageFormatR16Snorm;
-    case glslang::ElfR8Snorm:       return spv::ImageFormatR8Snorm;
-    case glslang::ElfRgba32i:       return spv::ImageFormatRgba32i;
-    case glslang::ElfRgba16i:       return spv::ImageFormatRgba16i;
-    case glslang::ElfRgba8i:        return spv::ImageFormatRgba8i;
-    case glslang::ElfR32i:          return spv::ImageFormatR32i;
-    case glslang::ElfRg32i:         return spv::ImageFormatRg32i;
-    case glslang::ElfRg16i:         return spv::ImageFormatRg16i;
-    case glslang::ElfRg8i:          return spv::ImageFormatRg8i;
-    case glslang::ElfR16i:          return spv::ImageFormatR16i;
-    case glslang::ElfR8i:           return spv::ImageFormatR8i;
-    case glslang::ElfRgba32ui:      return spv::ImageFormatRgba32ui;
-    case glslang::ElfRgba16ui:      return spv::ImageFormatRgba16ui;
-    case glslang::ElfRgba8ui:       return spv::ImageFormatRgba8ui;
-    case glslang::ElfR32ui:         return spv::ImageFormatR32ui;
-    case glslang::ElfRg32ui:        return spv::ImageFormatRg32ui;
-    case glslang::ElfRg16ui:        return spv::ImageFormatRg16ui;
-    case glslang::ElfRgb10a2ui:     return spv::ImageFormatRgb10a2ui;
-    case glslang::ElfRg8ui:         return spv::ImageFormatRg8ui;
-    case glslang::ElfR16ui:         return spv::ImageFormatR16ui;
-    case glslang::ElfR8ui:          return spv::ImageFormatR8ui;
-    case glslang::ElfR64ui:         return spv::ImageFormatR64ui;
-    case glslang::ElfR64i:          return spv::ImageFormatR64i;
+    case qglslang::ElfNone:          return spv::ImageFormatUnknown;
+    case qglslang::ElfRgba32f:       return spv::ImageFormatRgba32f;
+    case qglslang::ElfRgba16f:       return spv::ImageFormatRgba16f;
+    case qglslang::ElfR32f:          return spv::ImageFormatR32f;
+    case qglslang::ElfRgba8:         return spv::ImageFormatRgba8;
+    case qglslang::ElfRgba8Snorm:    return spv::ImageFormatRgba8Snorm;
+    case qglslang::ElfRg32f:         return spv::ImageFormatRg32f;
+    case qglslang::ElfRg16f:         return spv::ImageFormatRg16f;
+    case qglslang::ElfR11fG11fB10f:  return spv::ImageFormatR11fG11fB10f;
+    case qglslang::ElfR16f:          return spv::ImageFormatR16f;
+    case qglslang::ElfRgba16:        return spv::ImageFormatRgba16;
+    case qglslang::ElfRgb10A2:       return spv::ImageFormatRgb10A2;
+    case qglslang::ElfRg16:          return spv::ImageFormatRg16;
+    case qglslang::ElfRg8:           return spv::ImageFormatRg8;
+    case qglslang::ElfR16:           return spv::ImageFormatR16;
+    case qglslang::ElfR8:            return spv::ImageFormatR8;
+    case qglslang::ElfRgba16Snorm:   return spv::ImageFormatRgba16Snorm;
+    case qglslang::ElfRg16Snorm:     return spv::ImageFormatRg16Snorm;
+    case qglslang::ElfRg8Snorm:      return spv::ImageFormatRg8Snorm;
+    case qglslang::ElfR16Snorm:      return spv::ImageFormatR16Snorm;
+    case qglslang::ElfR8Snorm:       return spv::ImageFormatR8Snorm;
+    case qglslang::ElfRgba32i:       return spv::ImageFormatRgba32i;
+    case qglslang::ElfRgba16i:       return spv::ImageFormatRgba16i;
+    case qglslang::ElfRgba8i:        return spv::ImageFormatRgba8i;
+    case qglslang::ElfR32i:          return spv::ImageFormatR32i;
+    case qglslang::ElfRg32i:         return spv::ImageFormatRg32i;
+    case qglslang::ElfRg16i:         return spv::ImageFormatRg16i;
+    case qglslang::ElfRg8i:          return spv::ImageFormatRg8i;
+    case qglslang::ElfR16i:          return spv::ImageFormatR16i;
+    case qglslang::ElfR8i:           return spv::ImageFormatR8i;
+    case qglslang::ElfRgba32ui:      return spv::ImageFormatRgba32ui;
+    case qglslang::ElfRgba16ui:      return spv::ImageFormatRgba16ui;
+    case qglslang::ElfRgba8ui:       return spv::ImageFormatRgba8ui;
+    case qglslang::ElfR32ui:         return spv::ImageFormatR32ui;
+    case qglslang::ElfRg32ui:        return spv::ImageFormatRg32ui;
+    case qglslang::ElfRg16ui:        return spv::ImageFormatRg16ui;
+    case qglslang::ElfRgb10a2ui:     return spv::ImageFormatRgb10a2ui;
+    case qglslang::ElfRg8ui:         return spv::ImageFormatRg8ui;
+    case qglslang::ElfR16ui:         return spv::ImageFormatR16ui;
+    case qglslang::ElfR8ui:          return spv::ImageFormatR8ui;
+    case qglslang::ElfR64ui:         return spv::ImageFormatR64ui;
+    case qglslang::ElfR64i:          return spv::ImageFormatR64i;
     default:                        return spv::ImageFormatMax;
     }
 }
 
 spv::SelectionControlMask TGlslangToSpvTraverser::TranslateSelectionControl(
-    const glslang::TIntermSelection& selectionNode) const
+    const qglslang::TIntermSelection& selectionNode) const
 {
     if (selectionNode.getFlatten())
         return spv::SelectionControlFlattenMask;
@@ -1210,7 +1210,7 @@ spv::SelectionControlMask TGlslangToSpvTraverser::TranslateSelectionControl(
     return spv::SelectionControlMaskNone;
 }
 
-spv::SelectionControlMask TGlslangToSpvTraverser::TranslateSwitchControl(const glslang::TIntermSwitch& switchNode)
+spv::SelectionControlMask TGlslangToSpvTraverser::TranslateSwitchControl(const qglslang::TIntermSwitch& switchNode)
     const
 {
     if (switchNode.getFlatten())
@@ -1221,7 +1221,7 @@ spv::SelectionControlMask TGlslangToSpvTraverser::TranslateSwitchControl(const g
 }
 
 // return a non-0 dependency if the dependency argument must be set
-spv::LoopControlMask TGlslangToSpvTraverser::TranslateLoopControl(const glslang::TIntermLoop& loopNode,
+spv::LoopControlMask TGlslangToSpvTraverser::TranslateLoopControl(const qglslang::TIntermLoop& loopNode,
     std::vector<unsigned int>& operands) const
 {
     spv::LoopControlMask control = spv::LoopControlMaskNone;
@@ -1230,18 +1230,18 @@ spv::LoopControlMask TGlslangToSpvTraverser::TranslateLoopControl(const glslang:
         control = control | spv::LoopControlDontUnrollMask;
     if (loopNode.getUnroll())
         control = control | spv::LoopControlUnrollMask;
-    if (unsigned(loopNode.getLoopDependency()) == glslang::TIntermLoop::dependencyInfinite)
+    if (unsigned(loopNode.getLoopDependency()) == qglslang::TIntermLoop::dependencyInfinite)
         control = control | spv::LoopControlDependencyInfiniteMask;
     else if (loopNode.getLoopDependency() > 0) {
         control = control | spv::LoopControlDependencyLengthMask;
         operands.push_back((unsigned int)loopNode.getLoopDependency());
     }
-    if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_4) {
+    if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_4) {
         if (loopNode.getMinIterations() > 0) {
             control = control | spv::LoopControlMinIterationsMask;
             operands.push_back(loopNode.getMinIterations());
         }
-        if (loopNode.getMaxIterations() < glslang::TIntermLoop::iterationsInfinite) {
+        if (loopNode.getMaxIterations() < qglslang::TIntermLoop::iterationsInfinite) {
             control = control | spv::LoopControlMaxIterationsMask;
             operands.push_back(loopNode.getMaxIterations());
         }
@@ -1263,9 +1263,9 @@ spv::LoopControlMask TGlslangToSpvTraverser::TranslateLoopControl(const glslang:
 }
 
 // Translate glslang type to SPIR-V storage class.
-spv::StorageClass TGlslangToSpvTraverser::TranslateStorageClass(const glslang::TType& type)
+spv::StorageClass TGlslangToSpvTraverser::TranslateStorageClass(const qglslang::TType& type)
 {
-    if (type.getBasicType() == glslang::EbtRayQuery)
+    if (type.getBasicType() == qglslang::EbtRayQuery)
         return spv::StorageClassPrivate;
 #ifndef GLSLANG_WEB
     if (type.getQualifier().isSpirvByReference()) {
@@ -1278,8 +1278,8 @@ spv::StorageClass TGlslangToSpvTraverser::TranslateStorageClass(const glslang::T
     if (type.getQualifier().isPipeOutput())
         return spv::StorageClassOutput;
 
-    if (glslangIntermediate->getSource() != glslang::EShSourceHlsl ||
-            type.getQualifier().storage == glslang::EvqUniform) {
+    if (glslangIntermediate->getSource() != qglslang::EShSourceHlsl ||
+            type.getQualifier().storage == qglslang::EvqUniform) {
         if (type.isAtomic())
             return spv::StorageClassAtomicCounter;
         if (type.containsOpaque())
@@ -1291,7 +1291,7 @@ spv::StorageClass TGlslangToSpvTraverser::TranslateStorageClass(const glslang::T
         return spv::StorageClassShaderRecordBufferKHR;
     }
 
-    if (glslangIntermediate->usingStorageBuffer() && type.getQualifier().storage == glslang::EvqBuffer) {
+    if (glslangIntermediate->usingStorageBuffer() && type.getQualifier().storage == qglslang::EvqBuffer) {
         builder.addIncorporatedExtension(spv::E_SPV_KHR_storage_buffer_storage_class, spv::Spv_1_3);
         return spv::StorageClassStorageBuffer;
     }
@@ -1299,29 +1299,29 @@ spv::StorageClass TGlslangToSpvTraverser::TranslateStorageClass(const glslang::T
     if (type.getQualifier().isUniformOrBuffer()) {
         if (type.getQualifier().isPushConstant())
             return spv::StorageClassPushConstant;
-        if (type.getBasicType() == glslang::EbtBlock)
+        if (type.getBasicType() == qglslang::EbtBlock)
             return spv::StorageClassUniform;
         return spv::StorageClassUniformConstant;
     }
 
-    if (type.getQualifier().storage == glslang::EvqShared && type.getBasicType() == glslang::EbtBlock) {
+    if (type.getQualifier().storage == qglslang::EvqShared && type.getBasicType() == qglslang::EbtBlock) {
         builder.addExtension(spv::E_SPV_KHR_workgroup_memory_explicit_layout);
         builder.addCapability(spv::CapabilityWorkgroupMemoryExplicitLayoutKHR);
         return spv::StorageClassWorkgroup;
     }
 
     switch (type.getQualifier().storage) {
-    case glslang::EvqGlobal:        return spv::StorageClassPrivate;
-    case glslang::EvqConstReadOnly: return spv::StorageClassFunction;
-    case glslang::EvqTemporary:     return spv::StorageClassFunction;
-    case glslang::EvqShared:           return spv::StorageClassWorkgroup;
+    case qglslang::EvqGlobal:        return spv::StorageClassPrivate;
+    case qglslang::EvqConstReadOnly: return spv::StorageClassFunction;
+    case qglslang::EvqTemporary:     return spv::StorageClassFunction;
+    case qglslang::EvqShared:           return spv::StorageClassWorkgroup;
 #ifndef GLSLANG_WEB
-    case glslang::EvqPayload:        return spv::StorageClassRayPayloadKHR;
-    case glslang::EvqPayloadIn:      return spv::StorageClassIncomingRayPayloadKHR;
-    case glslang::EvqHitAttr:        return spv::StorageClassHitAttributeKHR;
-    case glslang::EvqCallableData:   return spv::StorageClassCallableDataKHR;
-    case glslang::EvqCallableDataIn: return spv::StorageClassIncomingCallableDataKHR;
-    case glslang::EvqSpirvStorageClass: return static_cast<spv::StorageClass>(type.getQualifier().spirvStorageClass);
+    case qglslang::EvqPayload:        return spv::StorageClassRayPayloadKHR;
+    case qglslang::EvqPayloadIn:      return spv::StorageClassIncomingRayPayloadKHR;
+    case qglslang::EvqHitAttr:        return spv::StorageClassHitAttributeKHR;
+    case qglslang::EvqCallableData:   return spv::StorageClassCallableDataKHR;
+    case qglslang::EvqCallableDataIn: return spv::StorageClassIncomingCallableDataKHR;
+    case qglslang::EvqSpirvStorageClass: return static_cast<spv::StorageClass>(type.getQualifier().spirvStorageClass);
 #endif
     default:
         assert(0);
@@ -1332,24 +1332,24 @@ spv::StorageClass TGlslangToSpvTraverser::TranslateStorageClass(const glslang::T
 }
 
 // Translate glslang constants to SPIR-V literals
-void TGlslangToSpvTraverser::TranslateLiterals(const glslang::TVector<const glslang::TIntermConstantUnion*>& constants,
+void TGlslangToSpvTraverser::TranslateLiterals(const qglslang::TVector<const qglslang::TIntermConstantUnion*>& constants,
                                                std::vector<unsigned>& literals) const
 {
     for (auto constant : constants) {
-        if (constant->getBasicType() == glslang::EbtFloat) {
+        if (constant->getBasicType() == qglslang::EbtFloat) {
             float floatValue = static_cast<float>(constant->getConstArray()[0].getDConst());
             unsigned literal = *reinterpret_cast<unsigned*>(&floatValue);
             literals.push_back(literal);
-        } else if (constant->getBasicType() == glslang::EbtInt) {
+        } else if (constant->getBasicType() == qglslang::EbtInt) {
             unsigned literal = constant->getConstArray()[0].getIConst();
             literals.push_back(literal);
-        } else if (constant->getBasicType() == glslang::EbtUint) {
+        } else if (constant->getBasicType() == qglslang::EbtUint) {
             unsigned literal = constant->getConstArray()[0].getUConst();
             literals.push_back(literal);
-        } else if (constant->getBasicType() == glslang::EbtBool) {
+        } else if (constant->getBasicType() == qglslang::EbtBool) {
             unsigned literal = constant->getConstArray()[0].getBConst();
             literals.push_back(literal);
-        } else if (constant->getBasicType() == glslang::EbtString) {
+        } else if (constant->getBasicType() == qglslang::EbtString) {
             auto str = constant->getConstArray()[0].getSConst()->c_str();
             unsigned literal = 0;
             char* literalPtr = reinterpret_cast<char*>(&literal);
@@ -1378,14 +1378,14 @@ void TGlslangToSpvTraverser::TranslateLiterals(const glslang::TVector<const glsl
 }
 
 // Add capabilities pertaining to how an array is indexed.
-void TGlslangToSpvTraverser::addIndirectionIndexCapabilities(const glslang::TType& baseType,
-                                                             const glslang::TType& indexType)
+void TGlslangToSpvTraverser::addIndirectionIndexCapabilities(const qglslang::TType& baseType,
+                                                             const qglslang::TType& indexType)
 {
 #ifndef GLSLANG_WEB
     if (indexType.getQualifier().isNonUniform()) {
         // deal with an asserted non-uniform index
         // SPV_EXT_descriptor_indexing already added in TranslateNonUniformDecoration
-        if (baseType.getBasicType() == glslang::EbtSampler) {
+        if (baseType.getBasicType() == qglslang::EbtSampler) {
             if (baseType.getQualifier().hasAttachment())
                 builder.addCapability(spv::CapabilityInputAttachmentArrayNonUniformIndexingEXT);
             else if (baseType.isImage() && baseType.getSampler().isBuffer())
@@ -1396,15 +1396,15 @@ void TGlslangToSpvTraverser::addIndirectionIndexCapabilities(const glslang::TTyp
                 builder.addCapability(spv::CapabilityStorageImageArrayNonUniformIndexingEXT);
             else if (baseType.isTexture())
                 builder.addCapability(spv::CapabilitySampledImageArrayNonUniformIndexingEXT);
-        } else if (baseType.getBasicType() == glslang::EbtBlock) {
-            if (baseType.getQualifier().storage == glslang::EvqBuffer)
+        } else if (baseType.getBasicType() == qglslang::EbtBlock) {
+            if (baseType.getQualifier().storage == qglslang::EvqBuffer)
                 builder.addCapability(spv::CapabilityStorageBufferArrayNonUniformIndexingEXT);
-            else if (baseType.getQualifier().storage == glslang::EvqUniform)
+            else if (baseType.getQualifier().storage == qglslang::EvqUniform)
                 builder.addCapability(spv::CapabilityUniformBufferArrayNonUniformIndexingEXT);
         }
     } else {
         // assume a dynamically uniform index
-        if (baseType.getBasicType() == glslang::EbtSampler) {
+        if (baseType.getBasicType() == qglslang::EbtSampler) {
             if (baseType.getQualifier().hasAttachment()) {
                 builder.addIncorporatedExtension("SPV_EXT_descriptor_indexing", spv::Spv_1_5);
                 builder.addCapability(spv::CapabilityInputAttachmentArrayDynamicIndexingEXT);
@@ -1422,10 +1422,10 @@ void TGlslangToSpvTraverser::addIndirectionIndexCapabilities(const glslang::TTyp
 
 // Return whether or not the given type is something that should be tied to a
 // descriptor set.
-bool IsDescriptorResource(const glslang::TType& type)
+bool IsDescriptorResource(const qglslang::TType& type)
 {
     // uniform and buffer blocks are included, unless it is a push_constant
-    if (type.getBasicType() == glslang::EbtBlock)
+    if (type.getBasicType() == qglslang::EbtBlock)
         return type.getQualifier().isUniformOrBuffer() &&
         ! type.getQualifier().isShaderRecord() &&
         ! type.getQualifier().isPushConstant();
@@ -1434,17 +1434,17 @@ bool IsDescriptorResource(const glslang::TType& type)
     // basically samplerXXX/subpass/sampler/texture are all included
     // if they are the global-scope-class, not the function parameter
     // (or local, if they ever exist) class.
-    if (type.getBasicType() == glslang::EbtSampler ||
-        type.getBasicType() == glslang::EbtAccStruct)
+    if (type.getBasicType() == qglslang::EbtSampler ||
+        type.getBasicType() == qglslang::EbtAccStruct)
         return type.getQualifier().isUniformOrBuffer();
 
     // None of the above.
     return false;
 }
 
-void InheritQualifiers(glslang::TQualifier& child, const glslang::TQualifier& parent)
+void InheritQualifiers(qglslang::TQualifier& child, const qglslang::TQualifier& parent)
 {
-    if (child.layoutMatrix == glslang::ElmNone)
+    if (child.layoutMatrix == qglslang::ElmNone)
         child.layoutMatrix = parent.layoutMatrix;
 
     if (parent.invariant)
@@ -1495,7 +1495,7 @@ void InheritQualifiers(glslang::TQualifier& child, const glslang::TQualifier& pa
         child.nonUniform = true;
 }
 
-bool HasNonLayoutQualifiers(const glslang::TType& type, const glslang::TQualifier& qualifier)
+bool HasNonLayoutQualifiers(const qglslang::TType& type, const qglslang::TQualifier& qualifier)
 {
     // This should list qualifiers that simultaneous satisfy:
     // - struct members might inherit from a struct declaration
@@ -1505,7 +1505,7 @@ bool HasNonLayoutQualifiers(const glslang::TType& type, const glslang::TQualifie
     //     (note smooth does not, and expecting something like volatile
     //      to effect the whole object)
     // - are not part of the offset/st430/etc or row/column-major layout
-    return qualifier.invariant || (qualifier.hasLocation() && type.getBasicType() == glslang::EbtBlock);
+    return qualifier.invariant || (qualifier.hasLocation() && type.getBasicType() == qglslang::EbtBlock);
 }
 
 //
@@ -1513,13 +1513,13 @@ bool HasNonLayoutQualifiers(const glslang::TType& type, const glslang::TQualifie
 //
 
 TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
-    const glslang::TIntermediate* glslangIntermediate,
-    spv::SpvBuildLogger* buildLogger, glslang::SpvOptions& options) :
+    const qglslang::TIntermediate* glslangIntermediate,
+    spv::SpvBuildLogger* buildLogger, qglslang::SpvOptions& options) :
         TIntermTraverser(true, false, true),
         options(options),
         shaderEntry(nullptr), currentFunction(nullptr),
         sequenceDepth(0), logger(buildLogger),
-        builder(spvVersion, (glslang::GetKhronosToolId() << 16) | glslang::GetSpirvGeneratorVersion(), logger),
+        builder(spvVersion, (qglslang::GetKhronosToolId() << 16) | qglslang::GetSpirvGeneratorVersion(), logger),
         inEntryPoint(false), entryPointTerminated(false), linkageOnly(false),
         glslangIntermediate(glslangIntermediate),
         nanMinMaxClamp(glslangIntermediate->getNanMinMaxClamp()),
@@ -1541,14 +1541,14 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
         std::string text;
         const std::vector<std::string>& processes = glslangIntermediate->getProcesses();
         for (int p = 0; p < (int)processes.size(); ++p) {
-            if (glslangIntermediate->getSpv().spv < glslang::EShTargetSpv_1_1) {
+            if (glslangIntermediate->getSpv().spv < qglslang::EShTargetSpv_1_1) {
                 text.append("// OpModuleProcessed ");
                 text.append(processes[p]);
                 text.append("\n");
             } else
                 builder.addModuleProcessed(processes[p]);
         }
-        if (glslangIntermediate->getSpv().spv < glslang::EShTargetSpv_1_1 && (int)processes.size() > 0)
+        if (glslangIntermediate->getSpv().spv < qglslang::EShTargetSpv_1_1 && (int)processes.size() > 0)
             text.append("#line 1\n");
         text.append(glslangIntermediate->getSourceText());
         builder.setSourceText(text);
@@ -1635,25 +1635,25 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
 #ifndef GLSLANG_WEB
 
         switch(glslangIntermediate->getDepth()) {
-        case glslang::EldGreater:   mode = spv::ExecutionModeDepthGreater;   break;
-        case glslang::EldLess:      mode = spv::ExecutionModeDepthLess;      break;
-        case glslang::EldUnchanged: mode = spv::ExecutionModeDepthUnchanged; break;
+        case qglslang::EldGreater:   mode = spv::ExecutionModeDepthGreater;   break;
+        case qglslang::EldLess:      mode = spv::ExecutionModeDepthLess;      break;
+        case qglslang::EldUnchanged: mode = spv::ExecutionModeDepthUnchanged; break;
         default:                    mode = spv::ExecutionModeMax;            break;
         }
         if (mode != spv::ExecutionModeMax)
             builder.addExecutionMode(shaderEntry, (spv::ExecutionMode)mode);
         switch (glslangIntermediate->getInterlockOrdering()) {
-        case glslang::EioPixelInterlockOrdered:         mode = spv::ExecutionModePixelInterlockOrderedEXT;
+        case qglslang::EioPixelInterlockOrdered:         mode = spv::ExecutionModePixelInterlockOrderedEXT;
             break;
-        case glslang::EioPixelInterlockUnordered:       mode = spv::ExecutionModePixelInterlockUnorderedEXT;
+        case qglslang::EioPixelInterlockUnordered:       mode = spv::ExecutionModePixelInterlockUnorderedEXT;
             break;
-        case glslang::EioSampleInterlockOrdered:        mode = spv::ExecutionModeSampleInterlockOrderedEXT;
+        case qglslang::EioSampleInterlockOrdered:        mode = spv::ExecutionModeSampleInterlockOrderedEXT;
             break;
-        case glslang::EioSampleInterlockUnordered:      mode = spv::ExecutionModeSampleInterlockUnorderedEXT;
+        case qglslang::EioSampleInterlockUnordered:      mode = spv::ExecutionModeSampleInterlockUnorderedEXT;
             break;
-        case glslang::EioShadingRateInterlockOrdered:   mode = spv::ExecutionModeShadingRateInterlockOrderedEXT;
+        case qglslang::EioShadingRateInterlockOrdered:   mode = spv::ExecutionModeShadingRateInterlockOrderedEXT;
             break;
-        case glslang::EioShadingRateInterlockUnordered: mode = spv::ExecutionModeShadingRateInterlockUnorderedEXT;
+        case qglslang::EioShadingRateInterlockUnordered: mode = spv::ExecutionModeShadingRateInterlockUnorderedEXT;
             break;
         default:                                        mode = spv::ExecutionModeMax;
             break;
@@ -1676,10 +1676,10 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
 
     case EShLangCompute:
         builder.addCapability(spv::CapabilityShader);
-        if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_6) {
+        if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_6) {
           std::vector<spv::Id> dimConstId;
           for (int dim = 0; dim < 3; ++dim) {
-            bool specConst = (glslangIntermediate->getLocalSizeSpecId(dim) != glslang::TQualifier::layoutNotSet);
+            bool specConst = (glslangIntermediate->getLocalSizeSpecId(dim) != qglslang::TQualifier::layoutNotSet);
             dimConstId.push_back(builder.makeUintConstant(glslangIntermediate->getLocalSize(dim), specConst));
             if (specConst) {
                 builder.addDecoration(dimConstId.back(), spv::DecorationSpecId,
@@ -1692,11 +1692,11 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
                                                                              glslangIntermediate->getLocalSize(1),
                                                                              glslangIntermediate->getLocalSize(2));
         }
-        if (glslangIntermediate->getLayoutDerivativeModeNone() == glslang::LayoutDerivativeGroupQuads) {
+        if (glslangIntermediate->getLayoutDerivativeModeNone() == qglslang::LayoutDerivativeGroupQuads) {
             builder.addCapability(spv::CapabilityComputeDerivativeGroupQuadsNV);
             builder.addExecutionMode(shaderEntry, spv::ExecutionModeDerivativeGroupQuadsNV);
             builder.addExtension(spv::E_SPV_NV_compute_shader_derivatives);
-        } else if (glslangIntermediate->getLayoutDerivativeModeNone() == glslang::LayoutDerivativeGroupLinear) {
+        } else if (glslangIntermediate->getLayoutDerivativeModeNone() == qglslang::LayoutDerivativeGroupLinear) {
             builder.addCapability(spv::CapabilityComputeDerivativeGroupLinearNV);
             builder.addExecutionMode(shaderEntry, spv::ExecutionModeDerivativeGroupLinearNV);
             builder.addExtension(spv::E_SPV_NV_compute_shader_derivatives);
@@ -1707,7 +1707,7 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
     case EShLangTessControl:
         builder.addCapability(spv::CapabilityTessellation);
 
-        glslang::TLayoutGeometry primitive;
+        qglslang::TLayoutGeometry primitive;
 
         if (glslangIntermediate->getStage() == EShLangTessControl) {
             builder.addExecutionMode(shaderEntry, spv::ExecutionModeOutputVertices,
@@ -1718,26 +1718,26 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
         }
 
         switch (primitive) {
-        case glslang::ElgTriangles:           mode = spv::ExecutionModeTriangles;     break;
-        case glslang::ElgQuads:               mode = spv::ExecutionModeQuads;         break;
-        case glslang::ElgIsolines:            mode = spv::ExecutionModeIsolines;      break;
+        case qglslang::ElgTriangles:           mode = spv::ExecutionModeTriangles;     break;
+        case qglslang::ElgQuads:               mode = spv::ExecutionModeQuads;         break;
+        case qglslang::ElgIsolines:            mode = spv::ExecutionModeIsolines;      break;
         default:                              mode = spv::ExecutionModeMax;           break;
         }
         if (mode != spv::ExecutionModeMax)
             builder.addExecutionMode(shaderEntry, (spv::ExecutionMode)mode);
 
         switch (glslangIntermediate->getVertexSpacing()) {
-        case glslang::EvsEqual:            mode = spv::ExecutionModeSpacingEqual;          break;
-        case glslang::EvsFractionalEven:   mode = spv::ExecutionModeSpacingFractionalEven; break;
-        case glslang::EvsFractionalOdd:    mode = spv::ExecutionModeSpacingFractionalOdd;  break;
+        case qglslang::EvsEqual:            mode = spv::ExecutionModeSpacingEqual;          break;
+        case qglslang::EvsFractionalEven:   mode = spv::ExecutionModeSpacingFractionalEven; break;
+        case qglslang::EvsFractionalOdd:    mode = spv::ExecutionModeSpacingFractionalOdd;  break;
         default:                           mode = spv::ExecutionModeMax;                   break;
         }
         if (mode != spv::ExecutionModeMax)
             builder.addExecutionMode(shaderEntry, (spv::ExecutionMode)mode);
 
         switch (glslangIntermediate->getVertexOrder()) {
-        case glslang::EvoCw:     mode = spv::ExecutionModeVertexOrderCw;  break;
-        case glslang::EvoCcw:    mode = spv::ExecutionModeVertexOrderCcw; break;
+        case qglslang::EvoCw:     mode = spv::ExecutionModeVertexOrderCw;  break;
+        case qglslang::EvoCcw:    mode = spv::ExecutionModeVertexOrderCcw; break;
         default:                 mode = spv::ExecutionModeMax;            break;
         }
         if (mode != spv::ExecutionModeMax)
@@ -1750,11 +1750,11 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
     case EShLangGeometry:
         builder.addCapability(spv::CapabilityGeometry);
         switch (glslangIntermediate->getInputPrimitive()) {
-        case glslang::ElgPoints:             mode = spv::ExecutionModeInputPoints;             break;
-        case glslang::ElgLines:              mode = spv::ExecutionModeInputLines;              break;
-        case glslang::ElgLinesAdjacency:     mode = spv::ExecutionModeInputLinesAdjacency;     break;
-        case glslang::ElgTriangles:          mode = spv::ExecutionModeTriangles;               break;
-        case glslang::ElgTrianglesAdjacency: mode = spv::ExecutionModeInputTrianglesAdjacency; break;
+        case qglslang::ElgPoints:             mode = spv::ExecutionModeInputPoints;             break;
+        case qglslang::ElgLines:              mode = spv::ExecutionModeInputLines;              break;
+        case qglslang::ElgLinesAdjacency:     mode = spv::ExecutionModeInputLinesAdjacency;     break;
+        case qglslang::ElgTriangles:          mode = spv::ExecutionModeTriangles;               break;
+        case qglslang::ElgTrianglesAdjacency: mode = spv::ExecutionModeInputTrianglesAdjacency; break;
         default:                             mode = spv::ExecutionModeMax;                     break;
         }
         if (mode != spv::ExecutionModeMax)
@@ -1763,9 +1763,9 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
         builder.addExecutionMode(shaderEntry, spv::ExecutionModeInvocations, glslangIntermediate->getInvocations());
 
         switch (glslangIntermediate->getOutputPrimitive()) {
-        case glslang::ElgPoints:        mode = spv::ExecutionModeOutputPoints;                 break;
-        case glslang::ElgLineStrip:     mode = spv::ExecutionModeOutputLineStrip;              break;
-        case glslang::ElgTriangleStrip: mode = spv::ExecutionModeOutputTriangleStrip;          break;
+        case qglslang::ElgPoints:        mode = spv::ExecutionModeOutputPoints;                 break;
+        case qglslang::ElgLineStrip:     mode = spv::ExecutionModeOutputLineStrip;              break;
+        case qglslang::ElgTriangleStrip: mode = spv::ExecutionModeOutputTriangleStrip;          break;
         default:                        mode = spv::ExecutionModeMax;                          break;
         }
         if (mode != spv::ExecutionModeMax)
@@ -1802,10 +1802,10 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
     case EShLangMeshNV:
         builder.addCapability(spv::CapabilityMeshShadingNV);
         builder.addExtension(spv::E_SPV_NV_mesh_shader);
-        if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_6) {
+        if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_6) {
             std::vector<spv::Id> dimConstId;
             for (int dim = 0; dim < 3; ++dim) {
-                bool specConst = (glslangIntermediate->getLocalSizeSpecId(dim) != glslang::TQualifier::layoutNotSet);
+                bool specConst = (glslangIntermediate->getLocalSizeSpecId(dim) != qglslang::TQualifier::layoutNotSet);
                 dimConstId.push_back(builder.makeUintConstant(glslangIntermediate->getLocalSize(dim), specConst));
                 if (specConst) {
                     builder.addDecoration(dimConstId.back(), spv::DecorationSpecId,
@@ -1825,9 +1825,9 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
                 glslangIntermediate->getPrimitives());
 
             switch (glslangIntermediate->getOutputPrimitive()) {
-            case glslang::ElgPoints:        mode = spv::ExecutionModeOutputPoints;      break;
-            case glslang::ElgLines:         mode = spv::ExecutionModeOutputLinesNV;     break;
-            case glslang::ElgTriangles:     mode = spv::ExecutionModeOutputTrianglesNV; break;
+            case qglslang::ElgPoints:        mode = spv::ExecutionModeOutputPoints;      break;
+            case qglslang::ElgLines:         mode = spv::ExecutionModeOutputLinesNV;     break;
+            case qglslang::ElgTriangles:     mode = spv::ExecutionModeOutputTrianglesNV; break;
             default:                        mode = spv::ExecutionModeMax;               break;
             }
             if (mode != spv::ExecutionModeMax)
@@ -1845,7 +1845,7 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
     // Add SPIR-V requirements (GL_EXT_spirv_intrinsics)
     //
     if (glslangIntermediate->hasSpirvRequirement()) {
-        const glslang::TSpirvRequirement& spirvRequirement = glslangIntermediate->getSpirvRequirement();
+        const qglslang::TSpirvRequirement& spirvRequirement = glslangIntermediate->getSpirvRequirement();
 
         // Add SPIR-V extension requirement
         for (auto& extension : spirvRequirement.extensions)
@@ -1860,7 +1860,7 @@ TGlslangToSpvTraverser::TGlslangToSpvTraverser(unsigned int spvVersion,
     // Add SPIR-V execution mode qualifiers (GL_EXT_spirv_intrinsics)
     //
     if (glslangIntermediate->hasSpirvExecutionMode()) {
-        const glslang::TSpirvExecutionMode spirvExecutionMode = glslangIntermediate->getSpirvExecutionMode();
+        const qglslang::TSpirvExecutionMode spirvExecutionMode = glslangIntermediate->getSpirvExecutionMode();
 
         // Add spirv_execution_mode
         for (auto& mode : spirvExecutionMode.modes) {
@@ -1929,7 +1929,7 @@ void TGlslangToSpvTraverser::dumpSpv(std::vector<unsigned int>& out)
 //  - complex lvalue base setups:  foo.bar[3]....  , where we see foo and start up an access chain
 //  - something simple that degenerates into the last bullet
 //
-void TGlslangToSpvTraverser::visitSymbol(glslang::TIntermSymbol* symbol)
+void TGlslangToSpvTraverser::visitSymbol(qglslang::TIntermSymbol* symbol)
 {
     SpecConstantOpModeGuard spec_constant_op_mode_setter(&builder);
     if (symbol->getType().isStruct())
@@ -1940,7 +1940,7 @@ void TGlslangToSpvTraverser::visitSymbol(glslang::TIntermSymbol* symbol)
 
 #ifdef ENABLE_HLSL
     // Skip symbol handling if it is string-typed
-    if (symbol->getBasicType() == glslang::EbtString)
+    if (symbol->getBasicType() == qglslang::EbtString)
         return;
 #endif
 
@@ -1958,7 +1958,7 @@ void TGlslangToSpvTraverser::visitSymbol(glslang::TIntermSymbol* symbol)
                 spv::StorageClass sc = builder.getStorageClass(id);
                 // Before SPIR-V 1.4, we only want to include Input and Output.
                 // Starting with SPIR-V 1.4, we want all globals.
-                if ((glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_4 && builder.isGlobalStorage(id)) ||
+                if ((glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_4 && builder.isGlobalStorage(id)) ||
                     (sc == spv::StorageClassInput || sc == spv::StorageClassOutput)) {
                     iOSet.insert(id);
                 }
@@ -1971,7 +1971,7 @@ void TGlslangToSpvTraverser::visitSymbol(glslang::TIntermSymbol* symbol)
         // operation.
         // Note this turns it from an l-value to an r-value.
         // Currently, all symbols needing this are inputs; avoid the map lookup when non-input.
-        if (symbol->getType().getQualifier().storage == glslang::EvqVaryingIn)
+        if (symbol->getType().getQualifier().storage == qglslang::EvqVaryingIn)
             id = translateForcedType(id);
     }
 
@@ -1991,7 +1991,7 @@ void TGlslangToSpvTraverser::visitSymbol(glslang::TIntermSymbol* symbol)
         // B) Specialization constants (normal constants don't even come in as a variable),
         //    These are also pure R-values.
         // C) R-Values from type translation, see above call to translateForcedType()
-        glslang::TQualifier qualifier = symbol->getQualifier();
+        qglslang::TQualifier qualifier = symbol->getQualifier();
         if (qualifier.isSpecConstant() || rValueParameters.find(symbol->getId()) != rValueParameters.end() ||
             !builder.isPointerType(builder.getTypeId(id)))
             builder.setAccessChainRValue(id);
@@ -2034,7 +2034,7 @@ void TGlslangToSpvTraverser::visitSymbol(glslang::TIntermSymbol* symbol)
 #endif
 }
 
-bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::TIntermBinary* node)
+bool TGlslangToSpvTraverser::visitBinary(qglslang::TVisit /* visit */, qglslang::TIntermBinary* node)
 {
     builder.setLine(node->getLoc().line, node->getLoc().getFilename());
     if (node->getLeft()->getAsSymbolNode() != nullptr && node->getLeft()->getType().isStruct()) {
@@ -2050,21 +2050,21 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
 
     // First, handle special cases
     switch (node->getOp()) {
-    case glslang::EOpAssign:
-    case glslang::EOpAddAssign:
-    case glslang::EOpSubAssign:
-    case glslang::EOpMulAssign:
-    case glslang::EOpVectorTimesMatrixAssign:
-    case glslang::EOpVectorTimesScalarAssign:
-    case glslang::EOpMatrixTimesScalarAssign:
-    case glslang::EOpMatrixTimesMatrixAssign:
-    case glslang::EOpDivAssign:
-    case glslang::EOpModAssign:
-    case glslang::EOpAndAssign:
-    case glslang::EOpInclusiveOrAssign:
-    case glslang::EOpExclusiveOrAssign:
-    case glslang::EOpLeftShiftAssign:
-    case glslang::EOpRightShiftAssign:
+    case qglslang::EOpAssign:
+    case qglslang::EOpAddAssign:
+    case qglslang::EOpSubAssign:
+    case qglslang::EOpMulAssign:
+    case qglslang::EOpVectorTimesMatrixAssign:
+    case qglslang::EOpVectorTimesScalarAssign:
+    case qglslang::EOpMatrixTimesScalarAssign:
+    case qglslang::EOpMatrixTimesMatrixAssign:
+    case qglslang::EOpDivAssign:
+    case qglslang::EOpModAssign:
+    case qglslang::EOpAndAssign:
+    case qglslang::EOpInclusiveOrAssign:
+    case qglslang::EOpExclusiveOrAssign:
+    case qglslang::EOpLeftShiftAssign:
+    case qglslang::EOpRightShiftAssign:
         // A bin-op assign "a += b" means the same thing as "a = a + b"
         // where a is evaluated before b. For a simple assignment, GLSL
         // says to evaluate the left before the right.  So, always, left
@@ -2080,7 +2080,7 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
             node->getRight()->traverse(this);
             spv::Id rValue = accessChainLoad(node->getRight()->getType());
 
-            if (node->getOp() != glslang::EOpAssign) {
+            if (node->getOp() != qglslang::EOpAssign) {
                 // the left is also an r-value
                 builder.setAccessChain(lValue);
                 spv::Id leftRValue = accessChainLoad(node->getLeft()->getType());
@@ -2108,8 +2108,8 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
             builder.setAccessChainRValue(rValue);
         }
         return false;
-    case glslang::EOpIndexDirect:
-    case glslang::EOpIndexDirectStruct:
+    case qglslang::EOpIndexDirect:
+    case qglslang::EOpIndexDirectStruct:
         {
             // Structure, array, matrix, or vector indirection with statically known index.
             // Get the left part of the access chain.
@@ -2120,7 +2120,7 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
             const int glslangIndex = node->getRight()->getAsConstantUnion()->getConstArray()[0].getIConst();
             if (! node->getLeft()->getType().isArray() &&
                 node->getLeft()->getType().isVector() &&
-                node->getOp() == glslang::EOpIndexDirect) {
+                node->getOp() == qglslang::EOpIndexDirect) {
                 // Swizzle is uniform so propagate uniform into access chain
                 spv::Builder::AccessChain::CoherentFlags coherentFlags = TranslateCoherent(node->getLeft()->getType());
                 coherentFlags.nonUniform = 0;
@@ -2140,7 +2140,7 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
                 // do a load and reset the access chain.
                 if (node->getLeft()->isReference() &&
                     !node->getLeft()->getType().isArray() &&
-                    node->getOp() == glslang::EOpIndexDirectStruct)
+                    node->getOp() == qglslang::EOpIndexDirectStruct)
                 {
                     spv::Id left = accessChainLoad(node->getLeft()->getType());
                     builder.clearAccessChain();
@@ -2148,8 +2148,8 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
                 }
 
                 int spvIndex = glslangIndex;
-                if (node->getLeft()->getBasicType() == glslang::EbtBlock &&
-                    node->getOp() == glslang::EOpIndexDirectStruct)
+                if (node->getLeft()->getBasicType() == qglslang::EbtBlock &&
+                    node->getOp() == qglslang::EOpIndexDirectStruct)
                 {
                     // This may be, e.g., an anonymous block-member selection, which generally need
                     // index remapping due to hidden members in anonymous blocks.
@@ -2178,7 +2178,7 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
             }
         }
         return false;
-    case glslang::EOpIndexIndirect:
+    case qglslang::EOpIndexIndirect:
         {
             // Array, matrix, or vector indirection with variable index.
             // Will use native SPIR-V access-chain for and array indirection;
@@ -2218,7 +2218,7 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
                                         node->getLeft()->getType().getBufferReferenceAlignment());
         }
         return false;
-    case glslang::EOpVectorSwizzle:
+    case qglslang::EOpVectorSwizzle:
         {
             node->getLeft()->traverse(this);
             std::vector<unsigned> swizzle;
@@ -2230,11 +2230,11 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
                                                dummySize));
         }
         return false;
-    case glslang::EOpMatrixSwizzle:
+    case qglslang::EOpMatrixSwizzle:
         logger->missingFunctionality("matrix swizzle");
         return true;
-    case glslang::EOpLogicalOr:
-    case glslang::EOpLogicalAnd:
+    case qglslang::EOpLogicalOr:
+    case qglslang::EOpLogicalAnd:
         {
 
             // These may require short circuiting, but can sometimes be done as straight
@@ -2283,7 +2283,7 @@ bool TGlslangToSpvTraverser::visitBinary(glslang::TVisit /* visit */, glslang::T
     }
 }
 
-spv::Id TGlslangToSpvTraverser::convertLoadedBoolInUniformToUint(const glslang::TType& type,
+spv::Id TGlslangToSpvTraverser::convertLoadedBoolInUniformToUint(const qglslang::TType& type,
                                                                  spv::Id nominalTypeId,
                                                                  spv::Id loadedId)
 {
@@ -2305,10 +2305,10 @@ spv::Id TGlslangToSpvTraverser::convertLoadedBoolInUniformToUint(const glslang::
         if (nominalTypeId != boolArrayTypeId)
         {
             // Use OpCopyLogical from SPIR-V 1.4 if available.
-            if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_4)
+            if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_4)
                 return builder.createUnaryOp(spv::OpCopyLogical, boolArrayTypeId, loadedId);
 
-            glslang::TType glslangElementType(type, 0);
+            qglslang::TType glslangElementType(type, 0);
             spv::Id elementNominalTypeId = builder.getContainedTypeId(nominalTypeId);
             std::vector<spv::Id> constituents;
             for (int index = 0; index < type.getOuterArraySize(); ++index) {
@@ -2329,16 +2329,16 @@ spv::Id TGlslangToSpvTraverser::convertLoadedBoolInUniformToUint(const glslang::
 // Figure out what, if any, type changes are needed when accessing a specific built-in.
 // Returns <the type SPIR-V requires for declarion, the type to translate to on use>.
 // Also see comment for 'forceType', regarding tracking SPIR-V-required types.
-std::pair<spv::Id, spv::Id> TGlslangToSpvTraverser::getForcedType(glslang::TBuiltInVariable glslangBuiltIn,
-    const glslang::TType& glslangType)
+std::pair<spv::Id, spv::Id> TGlslangToSpvTraverser::getForcedType(qglslang::TBuiltInVariable glslangBuiltIn,
+    const qglslang::TType& glslangType)
 {
     switch(glslangBuiltIn)
     {
-        case glslang::EbvSubGroupEqMask:
-        case glslang::EbvSubGroupGeMask:
-        case glslang::EbvSubGroupGtMask:
-        case glslang::EbvSubGroupLeMask:
-        case glslang::EbvSubGroupLtMask: {
+        case qglslang::EbvSubGroupEqMask:
+        case qglslang::EbvSubGroupGeMask:
+        case qglslang::EbvSubGroupGtMask:
+        case qglslang::EbvSubGroupLeMask:
+        case qglslang::EbvSubGroupLtMask: {
             // these require changing a 64-bit scaler -> a vector of 32-bit components
             if (glslangType.isVector())
                 break;
@@ -2349,8 +2349,8 @@ std::pair<spv::Id, spv::Id> TGlslangToSpvTraverser::getForcedType(glslang::TBuil
         }
         // There are no SPIR-V builtins defined for these and map onto original non-transposed
         // builtins. During visitBinary we insert a transpose
-        case glslang::EbvWorldToObject3x4:
-        case glslang::EbvObjectToWorld3x4: {
+        case qglslang::EbvWorldToObject3x4:
+        case qglslang::EbvObjectToWorld3x4: {
             spv::Id mat43 = builder.makeMatrixType(builder.makeFloatType(32), 4, 3);
             spv::Id mat34 = builder.makeMatrixType(builder.makeFloatType(32), 3, 4);
             std::pair<spv::Id, spv::Id> ret(mat43, mat34);
@@ -2409,7 +2409,7 @@ spv::Id TGlslangToSpvTraverser::translateForcedType(spv::Id object)
     return object;
 }
 
-bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TIntermUnary* node)
+bool TGlslangToSpvTraverser::visitUnary(qglslang::TVisit /* visit */, qglslang::TIntermUnary* node)
 {
     builder.setLine(node->getLoc().line, node->getLoc().getFilename());
 
@@ -2430,7 +2430,7 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
 
     // Non-texturing.
 
-    if (node->getOp() == glslang::EOpArrayLength) {
+    if (node->getOp() == qglslang::EOpArrayLength) {
         // Quite special; won't want to evaluate the operand.
 
         // Currently, the front-end does not allow .length() on an array until it is sized,
@@ -2451,7 +2451,7 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
 
             length = builder.createCooperativeMatrixLength(typeId);
         } else {
-            glslang::TIntermTyped* block = node->getOperand()->getAsBinaryNode()->getLeft();
+            qglslang::TIntermTyped* block = node->getOperand()->getAsBinaryNode()->getLeft();
             block->traverse(this);
             unsigned int member = node->getOperand()->getAsBinaryNode()->getRight()->getAsConstantUnion()
                 ->getConstArray()[0].getUConst();
@@ -2461,7 +2461,7 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
         // GLSL semantics say the result of .length() is an int, while SPIR-V says
         // signedness must be 0. So, convert from SPIR-V unsigned back to GLSL's
         // AST expectation of a signed result.
-        if (glslangIntermediate->getSource() == glslang::EShSourceGlsl) {
+        if (glslangIntermediate->getSource() == qglslang::EShSourceGlsl) {
             if (builder.isInSpecConstCodeGenMode()) {
                 length = builder.createBinOp(spv::OpIAdd, builder.makeIntType(32), length, builder.makeIntConstant(0));
             } else {
@@ -2482,7 +2482,7 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
     spv::Id invertedType = spv::NoType;
     auto resultType = [&invertedType, &node, this](){ return invertedType != spv::NoType ?
         invertedType : convertGlslangToSpvType(node->getType()); };
-    if (node->getOp() == glslang::EOpInterpolateAtCentroid)
+    if (node->getOp() == qglslang::EOpInterpolateAtCentroid)
         invertedType = getInvertedSwizzleType(*node->getOperand());
 
     builder.clearAccessChain();
@@ -2499,20 +2499,20 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
     spv::Builder::AccessChain::CoherentFlags lvalueCoherentFlags;
 
 #ifndef GLSLANG_WEB
-    if (node->getOp() == glslang::EOpAtomicCounterIncrement ||
-        node->getOp() == glslang::EOpAtomicCounterDecrement ||
-        node->getOp() == glslang::EOpAtomicCounter          ||
-        (node->getOp() == glslang::EOpInterpolateAtCentroid &&
-          glslangIntermediate->getSource() != glslang::EShSourceHlsl)  ||
-        node->getOp() == glslang::EOpRayQueryProceed        ||
-        node->getOp() == glslang::EOpRayQueryGetRayTMin     ||
-        node->getOp() == glslang::EOpRayQueryGetRayFlags    ||
-        node->getOp() == glslang::EOpRayQueryGetWorldRayOrigin ||
-        node->getOp() == glslang::EOpRayQueryGetWorldRayDirection ||
-        node->getOp() == glslang::EOpRayQueryGetIntersectionCandidateAABBOpaque ||
-        node->getOp() == glslang::EOpRayQueryTerminate ||
-        node->getOp() == glslang::EOpRayQueryConfirmIntersection ||
-        (node->getOp() == glslang::EOpSpirvInst && operandNode->getAsTyped()->getQualifier().isSpirvByReference())) {
+    if (node->getOp() == qglslang::EOpAtomicCounterIncrement ||
+        node->getOp() == qglslang::EOpAtomicCounterDecrement ||
+        node->getOp() == qglslang::EOpAtomicCounter          ||
+        (node->getOp() == qglslang::EOpInterpolateAtCentroid &&
+          glslangIntermediate->getSource() != qglslang::EShSourceHlsl)  ||
+        node->getOp() == qglslang::EOpRayQueryProceed        ||
+        node->getOp() == qglslang::EOpRayQueryGetRayTMin     ||
+        node->getOp() == qglslang::EOpRayQueryGetRayFlags    ||
+        node->getOp() == qglslang::EOpRayQueryGetWorldRayOrigin ||
+        node->getOp() == qglslang::EOpRayQueryGetWorldRayDirection ||
+        node->getOp() == qglslang::EOpRayQueryGetIntersectionCandidateAABBOpaque ||
+        node->getOp() == qglslang::EOpRayQueryTerminate ||
+        node->getOp() == qglslang::EOpRayQueryConfirmIntersection ||
+        (node->getOp() == qglslang::EOpSpirvInst && operandNode->getAsTyped()->getQualifier().isSpirvByReference())) {
         operand = builder.accessChainGetLValue(); // Special case l-value operands
         lvalueCoherentFlags = builder.getAccessChain().coherentFlags;
         lvalueCoherentFlags |= TranslateCoherent(operandNode->getAsTyped()->getType());
@@ -2542,20 +2542,20 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
 #ifndef GLSLANG_WEB
     // it could be attached to a SPIR-V intruction
     if (!result) {
-        if (node->getOp() == glslang::EOpSpirvInst) {
+        if (node->getOp() == qglslang::EOpSpirvInst) {
             const auto& spirvInst = node->getSpirvInstruction();
             if (spirvInst.set == "") {
                 spv::IdImmediate idImmOp = {true, operand};
                 if (operandNode->getAsTyped()->getQualifier().isSpirvLiteral()) {
                     // Translate the constant to a literal value
                     std::vector<unsigned> literals;
-                    glslang::TVector<const glslang::TIntermConstantUnion*> constants;
+                    qglslang::TVector<const qglslang::TIntermConstantUnion*> constants;
                     constants.push_back(operandNode->getAsConstantUnion());
                     TranslateLiterals(constants, literals);
                     idImmOp = {false, literals[0]};
                 }
 
-                if (node->getBasicType() == glslang::EbtVoid)
+                if (node->getBasicType() == qglslang::EbtVoid)
                     builder.createNoResultOp(static_cast<spv::Op>(spirvInst.id), {idImmOp});
                 else
                     result = builder.createOp(static_cast<spv::Op>(spirvInst.id), resultType(), {idImmOp});
@@ -2565,7 +2565,7 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
                     spirvInst.id, {operand});
             }
 
-            if (node->getBasicType() == glslang::EbtVoid)
+            if (node->getBasicType() == qglslang::EbtVoid)
                 return false; // done with this node
         }
     }
@@ -2585,35 +2585,35 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
 
     // it must be a special case, check...
     switch (node->getOp()) {
-    case glslang::EOpPostIncrement:
-    case glslang::EOpPostDecrement:
-    case glslang::EOpPreIncrement:
-    case glslang::EOpPreDecrement:
+    case qglslang::EOpPostIncrement:
+    case qglslang::EOpPostDecrement:
+    case qglslang::EOpPreIncrement:
+    case qglslang::EOpPreDecrement:
         {
             // we need the integer value "1" or the floating point "1.0" to add/subtract
             spv::Id one = 0;
-            if (node->getBasicType() == glslang::EbtFloat)
+            if (node->getBasicType() == qglslang::EbtFloat)
                 one = builder.makeFloatConstant(1.0F);
 #ifndef GLSLANG_WEB
-            else if (node->getBasicType() == glslang::EbtDouble)
+            else if (node->getBasicType() == qglslang::EbtDouble)
                 one = builder.makeDoubleConstant(1.0);
-            else if (node->getBasicType() == glslang::EbtFloat16)
+            else if (node->getBasicType() == qglslang::EbtFloat16)
                 one = builder.makeFloat16Constant(1.0F);
-            else if (node->getBasicType() == glslang::EbtInt8  || node->getBasicType() == glslang::EbtUint8)
+            else if (node->getBasicType() == qglslang::EbtInt8  || node->getBasicType() == qglslang::EbtUint8)
                 one = builder.makeInt8Constant(1);
-            else if (node->getBasicType() == glslang::EbtInt16 || node->getBasicType() == glslang::EbtUint16)
+            else if (node->getBasicType() == qglslang::EbtInt16 || node->getBasicType() == qglslang::EbtUint16)
                 one = builder.makeInt16Constant(1);
-            else if (node->getBasicType() == glslang::EbtInt64 || node->getBasicType() == glslang::EbtUint64)
+            else if (node->getBasicType() == qglslang::EbtInt64 || node->getBasicType() == qglslang::EbtUint64)
                 one = builder.makeInt64Constant(1);
 #endif
             else
                 one = builder.makeIntConstant(1);
-            glslang::TOperator op;
-            if (node->getOp() == glslang::EOpPreIncrement ||
-                node->getOp() == glslang::EOpPostIncrement)
-                op = glslang::EOpAdd;
+            qglslang::TOperator op;
+            if (node->getOp() == qglslang::EOpPreIncrement ||
+                node->getOp() == qglslang::EOpPostIncrement)
+                op = qglslang::EOpAdd;
             else
-                op = glslang::EOpSub;
+                op = qglslang::EOpSub;
 
             spv::Id result = createBinaryOperation(op, decorations,
                                                    convertGlslangToSpvType(node->getType()), operand, one,
@@ -2625,8 +2625,8 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
             builder.accessChainStore(result,
                                      TranslateNonUniformDecoration(builder.getAccessChain().coherentFlags));
             builder.clearAccessChain();
-            if (node->getOp() == glslang::EOpPreIncrement ||
-                node->getOp() == glslang::EOpPreDecrement)
+            if (node->getOp() == qglslang::EOpPreIncrement ||
+                node->getOp() == qglslang::EOpPreDecrement)
                 builder.setAccessChainRValue(result);
             else
                 builder.setAccessChainRValue(operand);
@@ -2635,16 +2635,16 @@ bool TGlslangToSpvTraverser::visitUnary(glslang::TVisit /* visit */, glslang::TI
         return false;
 
 #ifndef GLSLANG_WEB
-    case glslang::EOpEmitStreamVertex:
+    case qglslang::EOpEmitStreamVertex:
         builder.createNoResultOp(spv::OpEmitStreamVertex, operand);
         return false;
-    case glslang::EOpEndStreamPrimitive:
+    case qglslang::EOpEndStreamPrimitive:
         builder.createNoResultOp(spv::OpEndStreamPrimitive, operand);
         return false;
-    case glslang::EOpRayQueryTerminate:
+    case qglslang::EOpRayQueryTerminate:
         builder.createNoResultOp(spv::OpRayQueryTerminateKHR, operand);
         return false;
-    case glslang::EOpRayQueryConfirmIntersection:
+    case qglslang::EOpRayQueryConfirmIntersection:
         builder.createNoResultOp(spv::OpRayQueryConfirmIntersectionKHR, operand);
         return false;
 #endif
@@ -2663,7 +2663,7 @@ spv::Id TGlslangToSpvTraverser::createCompositeConstruct(spv::Id resultTypeId, s
         spv::Id lType = builder.getContainedTypeId(resultTypeId, c);
         spv::Id rType = builder.getTypeId(constituent);
         if (lType != rType) {
-            if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_4) {
+            if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_4) {
                 constituent = builder.createUnaryOp(spv::OpCopyLogical, lType, constituent);
             } else if (builder.isStructType(rType)) {
                 std::vector<spv::Id> rTypeConstituents;
@@ -2689,7 +2689,7 @@ spv::Id TGlslangToSpvTraverser::createCompositeConstruct(spv::Id resultTypeId, s
     return builder.createCompositeConstruct(resultTypeId, constituents);
 }
 
-bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TIntermAggregate* node)
+bool TGlslangToSpvTraverser::visitAggregate(qglslang::TVisit visit, qglslang::TIntermAggregate* node)
 {
     SpecConstantOpModeGuard spec_constant_op_mode_setter(&builder);
     if (node->getType().getQualifier().isSpecConstant())
@@ -2714,15 +2714,15 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
         return false;
     }
 #ifndef GLSLANG_WEB
-    else if (node->getOp() == glslang::EOpImageStore ||
-        node->getOp() == glslang::EOpImageStoreLod ||
-        node->getOp() == glslang::EOpImageAtomicStore) {
+    else if (node->getOp() == qglslang::EOpImageStore ||
+        node->getOp() == qglslang::EOpImageStoreLod ||
+        node->getOp() == qglslang::EOpImageAtomicStore) {
         // "imageStore" is a special case, which has no result
         return false;
     }
 #endif
 
-    glslang::TOperator binOp = glslang::EOpNull;
+    qglslang::TOperator binOp = qglslang::EOpNull;
     bool reduceComparison = true;
     bool isMatrix = false;
     bool noReturnValue = false;
@@ -2735,7 +2735,7 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
     spv::Decoration precision = TranslatePrecisionDecoration(node->getOperationPrecision());
 
     switch (node->getOp()) {
-    case glslang::EOpSequence:
+    case qglslang::EOpSequence:
     {
         if (preVisit)
             ++sequenceDepth;
@@ -2765,27 +2765,27 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
 
         return true;
     }
-    case glslang::EOpLinkerObjects:
+    case qglslang::EOpLinkerObjects:
     {
-        if (visit == glslang::EvPreVisit)
+        if (visit == qglslang::EvPreVisit)
             linkageOnly = true;
         else
             linkageOnly = false;
 
         return true;
     }
-    case glslang::EOpComma:
+    case qglslang::EOpComma:
     {
         // processing from left to right naturally leaves the right-most
         // lying around in the access chain
-        glslang::TIntermSequence& glslangOperands = node->getSequence();
+        qglslang::TIntermSequence& glslangOperands = node->getSequence();
         for (int i = 0; i < (int)glslangOperands.size(); ++i)
             glslangOperands[i]->traverse(this);
 
         return false;
     }
-    case glslang::EOpFunction:
-        if (visit == glslang::EvPreVisit) {
+    case qglslang::EOpFunction:
+        if (visit == qglslang::EvPreVisit) {
             if (isShaderEntryPoint(node)) {
                 inEntryPoint = true;
                 builder.setBuildPoint(shaderEntry->getLastBlock());
@@ -2805,12 +2805,12 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
         }
 
         return true;
-    case glslang::EOpParameters:
+    case qglslang::EOpParameters:
         // Parameters will have been consumed by EOpFunction processing, but not
         // the body, so we still visited the function node's children, making this
         // child redundant.
         return false;
-    case glslang::EOpFunctionCall:
+    case qglslang::EOpFunctionCall:
     {
         builder.setLine(node->getLoc().line, node->getLoc().getFilename());
         if (node->isUserDefined())
@@ -2823,123 +2823,123 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
 
         return false;
     }
-    case glslang::EOpConstructMat2x2:
-    case glslang::EOpConstructMat2x3:
-    case glslang::EOpConstructMat2x4:
-    case glslang::EOpConstructMat3x2:
-    case glslang::EOpConstructMat3x3:
-    case glslang::EOpConstructMat3x4:
-    case glslang::EOpConstructMat4x2:
-    case glslang::EOpConstructMat4x3:
-    case glslang::EOpConstructMat4x4:
-    case glslang::EOpConstructDMat2x2:
-    case glslang::EOpConstructDMat2x3:
-    case glslang::EOpConstructDMat2x4:
-    case glslang::EOpConstructDMat3x2:
-    case glslang::EOpConstructDMat3x3:
-    case glslang::EOpConstructDMat3x4:
-    case glslang::EOpConstructDMat4x2:
-    case glslang::EOpConstructDMat4x3:
-    case glslang::EOpConstructDMat4x4:
-    case glslang::EOpConstructIMat2x2:
-    case glslang::EOpConstructIMat2x3:
-    case glslang::EOpConstructIMat2x4:
-    case glslang::EOpConstructIMat3x2:
-    case glslang::EOpConstructIMat3x3:
-    case glslang::EOpConstructIMat3x4:
-    case glslang::EOpConstructIMat4x2:
-    case glslang::EOpConstructIMat4x3:
-    case glslang::EOpConstructIMat4x4:
-    case glslang::EOpConstructUMat2x2:
-    case glslang::EOpConstructUMat2x3:
-    case glslang::EOpConstructUMat2x4:
-    case glslang::EOpConstructUMat3x2:
-    case glslang::EOpConstructUMat3x3:
-    case glslang::EOpConstructUMat3x4:
-    case glslang::EOpConstructUMat4x2:
-    case glslang::EOpConstructUMat4x3:
-    case glslang::EOpConstructUMat4x4:
-    case glslang::EOpConstructBMat2x2:
-    case glslang::EOpConstructBMat2x3:
-    case glslang::EOpConstructBMat2x4:
-    case glslang::EOpConstructBMat3x2:
-    case glslang::EOpConstructBMat3x3:
-    case glslang::EOpConstructBMat3x4:
-    case glslang::EOpConstructBMat4x2:
-    case glslang::EOpConstructBMat4x3:
-    case glslang::EOpConstructBMat4x4:
-    case glslang::EOpConstructF16Mat2x2:
-    case glslang::EOpConstructF16Mat2x3:
-    case glslang::EOpConstructF16Mat2x4:
-    case glslang::EOpConstructF16Mat3x2:
-    case glslang::EOpConstructF16Mat3x3:
-    case glslang::EOpConstructF16Mat3x4:
-    case glslang::EOpConstructF16Mat4x2:
-    case glslang::EOpConstructF16Mat4x3:
-    case glslang::EOpConstructF16Mat4x4:
+    case qglslang::EOpConstructMat2x2:
+    case qglslang::EOpConstructMat2x3:
+    case qglslang::EOpConstructMat2x4:
+    case qglslang::EOpConstructMat3x2:
+    case qglslang::EOpConstructMat3x3:
+    case qglslang::EOpConstructMat3x4:
+    case qglslang::EOpConstructMat4x2:
+    case qglslang::EOpConstructMat4x3:
+    case qglslang::EOpConstructMat4x4:
+    case qglslang::EOpConstructDMat2x2:
+    case qglslang::EOpConstructDMat2x3:
+    case qglslang::EOpConstructDMat2x4:
+    case qglslang::EOpConstructDMat3x2:
+    case qglslang::EOpConstructDMat3x3:
+    case qglslang::EOpConstructDMat3x4:
+    case qglslang::EOpConstructDMat4x2:
+    case qglslang::EOpConstructDMat4x3:
+    case qglslang::EOpConstructDMat4x4:
+    case qglslang::EOpConstructIMat2x2:
+    case qglslang::EOpConstructIMat2x3:
+    case qglslang::EOpConstructIMat2x4:
+    case qglslang::EOpConstructIMat3x2:
+    case qglslang::EOpConstructIMat3x3:
+    case qglslang::EOpConstructIMat3x4:
+    case qglslang::EOpConstructIMat4x2:
+    case qglslang::EOpConstructIMat4x3:
+    case qglslang::EOpConstructIMat4x4:
+    case qglslang::EOpConstructUMat2x2:
+    case qglslang::EOpConstructUMat2x3:
+    case qglslang::EOpConstructUMat2x4:
+    case qglslang::EOpConstructUMat3x2:
+    case qglslang::EOpConstructUMat3x3:
+    case qglslang::EOpConstructUMat3x4:
+    case qglslang::EOpConstructUMat4x2:
+    case qglslang::EOpConstructUMat4x3:
+    case qglslang::EOpConstructUMat4x4:
+    case qglslang::EOpConstructBMat2x2:
+    case qglslang::EOpConstructBMat2x3:
+    case qglslang::EOpConstructBMat2x4:
+    case qglslang::EOpConstructBMat3x2:
+    case qglslang::EOpConstructBMat3x3:
+    case qglslang::EOpConstructBMat3x4:
+    case qglslang::EOpConstructBMat4x2:
+    case qglslang::EOpConstructBMat4x3:
+    case qglslang::EOpConstructBMat4x4:
+    case qglslang::EOpConstructF16Mat2x2:
+    case qglslang::EOpConstructF16Mat2x3:
+    case qglslang::EOpConstructF16Mat2x4:
+    case qglslang::EOpConstructF16Mat3x2:
+    case qglslang::EOpConstructF16Mat3x3:
+    case qglslang::EOpConstructF16Mat3x4:
+    case qglslang::EOpConstructF16Mat4x2:
+    case qglslang::EOpConstructF16Mat4x3:
+    case qglslang::EOpConstructF16Mat4x4:
         isMatrix = true;
         // fall through
-    case glslang::EOpConstructFloat:
-    case glslang::EOpConstructVec2:
-    case glslang::EOpConstructVec3:
-    case glslang::EOpConstructVec4:
-    case glslang::EOpConstructDouble:
-    case glslang::EOpConstructDVec2:
-    case glslang::EOpConstructDVec3:
-    case glslang::EOpConstructDVec4:
-    case glslang::EOpConstructFloat16:
-    case glslang::EOpConstructF16Vec2:
-    case glslang::EOpConstructF16Vec3:
-    case glslang::EOpConstructF16Vec4:
-    case glslang::EOpConstructBool:
-    case glslang::EOpConstructBVec2:
-    case glslang::EOpConstructBVec3:
-    case glslang::EOpConstructBVec4:
-    case glslang::EOpConstructInt8:
-    case glslang::EOpConstructI8Vec2:
-    case glslang::EOpConstructI8Vec3:
-    case glslang::EOpConstructI8Vec4:
-    case glslang::EOpConstructUint8:
-    case glslang::EOpConstructU8Vec2:
-    case glslang::EOpConstructU8Vec3:
-    case glslang::EOpConstructU8Vec4:
-    case glslang::EOpConstructInt16:
-    case glslang::EOpConstructI16Vec2:
-    case glslang::EOpConstructI16Vec3:
-    case glslang::EOpConstructI16Vec4:
-    case glslang::EOpConstructUint16:
-    case glslang::EOpConstructU16Vec2:
-    case glslang::EOpConstructU16Vec3:
-    case glslang::EOpConstructU16Vec4:
-    case glslang::EOpConstructInt:
-    case glslang::EOpConstructIVec2:
-    case glslang::EOpConstructIVec3:
-    case glslang::EOpConstructIVec4:
-    case glslang::EOpConstructUint:
-    case glslang::EOpConstructUVec2:
-    case glslang::EOpConstructUVec3:
-    case glslang::EOpConstructUVec4:
-    case glslang::EOpConstructInt64:
-    case glslang::EOpConstructI64Vec2:
-    case glslang::EOpConstructI64Vec3:
-    case glslang::EOpConstructI64Vec4:
-    case glslang::EOpConstructUint64:
-    case glslang::EOpConstructU64Vec2:
-    case glslang::EOpConstructU64Vec3:
-    case glslang::EOpConstructU64Vec4:
-    case glslang::EOpConstructStruct:
-    case glslang::EOpConstructTextureSampler:
-    case glslang::EOpConstructReference:
-    case glslang::EOpConstructCooperativeMatrix:
+    case qglslang::EOpConstructFloat:
+    case qglslang::EOpConstructVec2:
+    case qglslang::EOpConstructVec3:
+    case qglslang::EOpConstructVec4:
+    case qglslang::EOpConstructDouble:
+    case qglslang::EOpConstructDVec2:
+    case qglslang::EOpConstructDVec3:
+    case qglslang::EOpConstructDVec4:
+    case qglslang::EOpConstructFloat16:
+    case qglslang::EOpConstructF16Vec2:
+    case qglslang::EOpConstructF16Vec3:
+    case qglslang::EOpConstructF16Vec4:
+    case qglslang::EOpConstructBool:
+    case qglslang::EOpConstructBVec2:
+    case qglslang::EOpConstructBVec3:
+    case qglslang::EOpConstructBVec4:
+    case qglslang::EOpConstructInt8:
+    case qglslang::EOpConstructI8Vec2:
+    case qglslang::EOpConstructI8Vec3:
+    case qglslang::EOpConstructI8Vec4:
+    case qglslang::EOpConstructUint8:
+    case qglslang::EOpConstructU8Vec2:
+    case qglslang::EOpConstructU8Vec3:
+    case qglslang::EOpConstructU8Vec4:
+    case qglslang::EOpConstructInt16:
+    case qglslang::EOpConstructI16Vec2:
+    case qglslang::EOpConstructI16Vec3:
+    case qglslang::EOpConstructI16Vec4:
+    case qglslang::EOpConstructUint16:
+    case qglslang::EOpConstructU16Vec2:
+    case qglslang::EOpConstructU16Vec3:
+    case qglslang::EOpConstructU16Vec4:
+    case qglslang::EOpConstructInt:
+    case qglslang::EOpConstructIVec2:
+    case qglslang::EOpConstructIVec3:
+    case qglslang::EOpConstructIVec4:
+    case qglslang::EOpConstructUint:
+    case qglslang::EOpConstructUVec2:
+    case qglslang::EOpConstructUVec3:
+    case qglslang::EOpConstructUVec4:
+    case qglslang::EOpConstructInt64:
+    case qglslang::EOpConstructI64Vec2:
+    case qglslang::EOpConstructI64Vec3:
+    case qglslang::EOpConstructI64Vec4:
+    case qglslang::EOpConstructUint64:
+    case qglslang::EOpConstructU64Vec2:
+    case qglslang::EOpConstructU64Vec3:
+    case qglslang::EOpConstructU64Vec4:
+    case qglslang::EOpConstructStruct:
+    case qglslang::EOpConstructTextureSampler:
+    case qglslang::EOpConstructReference:
+    case qglslang::EOpConstructCooperativeMatrix:
     {
         builder.setLine(node->getLoc().line, node->getLoc().getFilename());
         std::vector<spv::Id> arguments;
         translateArguments(*node, arguments, lvalueCoherentFlags);
         spv::Id constructed;
-        if (node->getOp() == glslang::EOpConstructTextureSampler)
+        if (node->getOp() == qglslang::EOpConstructTextureSampler)
             constructed = builder.createOp(spv::OpSampledImage, resultType(), arguments);
-        else if (node->getOp() == glslang::EOpConstructStruct ||
-                 node->getOp() == glslang::EOpConstructCooperativeMatrix ||
+        else if (node->getOp() == qglslang::EOpConstructStruct ||
+                 node->getOp() == qglslang::EOpConstructCooperativeMatrix ||
                  node->getType().isArray()) {
             std::vector<spv::Id> constituents;
             for (int c = 0; c < (int)arguments.size(); ++c)
@@ -2962,166 +2962,166 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
 
     // These six are component-wise compares with component-wise results.
     // Forward on to createBinaryOperation(), requesting a vector result.
-    case glslang::EOpLessThan:
-    case glslang::EOpGreaterThan:
-    case glslang::EOpLessThanEqual:
-    case glslang::EOpGreaterThanEqual:
-    case glslang::EOpVectorEqual:
-    case glslang::EOpVectorNotEqual:
+    case qglslang::EOpLessThan:
+    case qglslang::EOpGreaterThan:
+    case qglslang::EOpLessThanEqual:
+    case qglslang::EOpGreaterThanEqual:
+    case qglslang::EOpVectorEqual:
+    case qglslang::EOpVectorNotEqual:
     {
         // Map the operation to a binary
         binOp = node->getOp();
         reduceComparison = false;
         switch (node->getOp()) {
-        case glslang::EOpVectorEqual:     binOp = glslang::EOpVectorEqual;      break;
-        case glslang::EOpVectorNotEqual:  binOp = glslang::EOpVectorNotEqual;   break;
+        case qglslang::EOpVectorEqual:     binOp = qglslang::EOpVectorEqual;      break;
+        case qglslang::EOpVectorNotEqual:  binOp = qglslang::EOpVectorNotEqual;   break;
         default:                          binOp = node->getOp();                break;
         }
 
         break;
     }
-    case glslang::EOpMul:
+    case qglslang::EOpMul:
         // component-wise matrix multiply
-        binOp = glslang::EOpMul;
+        binOp = qglslang::EOpMul;
         break;
-    case glslang::EOpOuterProduct:
+    case qglslang::EOpOuterProduct:
         // two vectors multiplied to make a matrix
-        binOp = glslang::EOpOuterProduct;
+        binOp = qglslang::EOpOuterProduct;
         break;
-    case glslang::EOpDot:
+    case qglslang::EOpDot:
     {
         // for scalar dot product, use multiply
-        glslang::TIntermSequence& glslangOperands = node->getSequence();
+        qglslang::TIntermSequence& glslangOperands = node->getSequence();
         if (glslangOperands[0]->getAsTyped()->getVectorSize() == 1)
-            binOp = glslang::EOpMul;
+            binOp = qglslang::EOpMul;
         break;
     }
-    case glslang::EOpMod:
+    case qglslang::EOpMod:
         // when an aggregate, this is the floating-point mod built-in function,
         // which can be emitted by the one in createBinaryOperation()
-        binOp = glslang::EOpMod;
-        break;
-
-    case glslang::EOpEmitVertex:
-    case glslang::EOpEndPrimitive:
-    case glslang::EOpBarrier:
-    case glslang::EOpMemoryBarrier:
-    case glslang::EOpMemoryBarrierAtomicCounter:
-    case glslang::EOpMemoryBarrierBuffer:
-    case glslang::EOpMemoryBarrierImage:
-    case glslang::EOpMemoryBarrierShared:
-    case glslang::EOpGroupMemoryBarrier:
-    case glslang::EOpDeviceMemoryBarrier:
-    case glslang::EOpAllMemoryBarrierWithGroupSync:
-    case glslang::EOpDeviceMemoryBarrierWithGroupSync:
-    case glslang::EOpWorkgroupMemoryBarrier:
-    case glslang::EOpWorkgroupMemoryBarrierWithGroupSync:
-    case glslang::EOpSubgroupBarrier:
-    case glslang::EOpSubgroupMemoryBarrier:
-    case glslang::EOpSubgroupMemoryBarrierBuffer:
-    case glslang::EOpSubgroupMemoryBarrierImage:
-    case glslang::EOpSubgroupMemoryBarrierShared:
+        binOp = qglslang::EOpMod;
+        break;
+
+    case qglslang::EOpEmitVertex:
+    case qglslang::EOpEndPrimitive:
+    case qglslang::EOpBarrier:
+    case qglslang::EOpMemoryBarrier:
+    case qglslang::EOpMemoryBarrierAtomicCounter:
+    case qglslang::EOpMemoryBarrierBuffer:
+    case qglslang::EOpMemoryBarrierImage:
+    case qglslang::EOpMemoryBarrierShared:
+    case qglslang::EOpGroupMemoryBarrier:
+    case qglslang::EOpDeviceMemoryBarrier:
+    case qglslang::EOpAllMemoryBarrierWithGroupSync:
+    case qglslang::EOpDeviceMemoryBarrierWithGroupSync:
+    case qglslang::EOpWorkgroupMemoryBarrier:
+    case qglslang::EOpWorkgroupMemoryBarrierWithGroupSync:
+    case qglslang::EOpSubgroupBarrier:
+    case qglslang::EOpSubgroupMemoryBarrier:
+    case qglslang::EOpSubgroupMemoryBarrierBuffer:
+    case qglslang::EOpSubgroupMemoryBarrierImage:
+    case qglslang::EOpSubgroupMemoryBarrierShared:
         noReturnValue = true;
         // These all have 0 operands and will naturally finish up in the code below for 0 operands
         break;
 
-    case glslang::EOpAtomicAdd:
-    case glslang::EOpAtomicSubtract:
-    case glslang::EOpAtomicMin:
-    case glslang::EOpAtomicMax:
-    case glslang::EOpAtomicAnd:
-    case glslang::EOpAtomicOr:
-    case glslang::EOpAtomicXor:
-    case glslang::EOpAtomicExchange:
-    case glslang::EOpAtomicCompSwap:
+    case qglslang::EOpAtomicAdd:
+    case qglslang::EOpAtomicSubtract:
+    case qglslang::EOpAtomicMin:
+    case qglslang::EOpAtomicMax:
+    case qglslang::EOpAtomicAnd:
+    case qglslang::EOpAtomicOr:
+    case qglslang::EOpAtomicXor:
+    case qglslang::EOpAtomicExchange:
+    case qglslang::EOpAtomicCompSwap:
         atomic = true;
         break;
 
 #ifndef GLSLANG_WEB
-    case glslang::EOpAtomicStore:
+    case qglslang::EOpAtomicStore:
         noReturnValue = true;
         // fallthrough
-    case glslang::EOpAtomicLoad:
+    case qglslang::EOpAtomicLoad:
         atomic = true;
         break;
 
-    case glslang::EOpAtomicCounterAdd:
-    case glslang::EOpAtomicCounterSubtract:
-    case glslang::EOpAtomicCounterMin:
-    case glslang::EOpAtomicCounterMax:
-    case glslang::EOpAtomicCounterAnd:
-    case glslang::EOpAtomicCounterOr:
-    case glslang::EOpAtomicCounterXor:
-    case glslang::EOpAtomicCounterExchange:
-    case glslang::EOpAtomicCounterCompSwap:
+    case qglslang::EOpAtomicCounterAdd:
+    case qglslang::EOpAtomicCounterSubtract:
+    case qglslang::EOpAtomicCounterMin:
+    case qglslang::EOpAtomicCounterMax:
+    case qglslang::EOpAtomicCounterAnd:
+    case qglslang::EOpAtomicCounterOr:
+    case qglslang::EOpAtomicCounterXor:
+    case qglslang::EOpAtomicCounterExchange:
+    case qglslang::EOpAtomicCounterCompSwap:
         builder.addExtension("SPV_KHR_shader_atomic_counter_ops");
         builder.addCapability(spv::CapabilityAtomicStorageOps);
         atomic = true;
         break;
 
-    case glslang::EOpAbsDifference:
-    case glslang::EOpAddSaturate:
-    case glslang::EOpSubSaturate:
-    case glslang::EOpAverage:
-    case glslang::EOpAverageRounded:
-    case glslang::EOpMul32x16:
+    case qglslang::EOpAbsDifference:
+    case qglslang::EOpAddSaturate:
+    case qglslang::EOpSubSaturate:
+    case qglslang::EOpAverage:
+    case qglslang::EOpAverageRounded:
+    case qglslang::EOpMul32x16:
         builder.addCapability(spv::CapabilityIntegerFunctions2INTEL);
         builder.addExtension("SPV_INTEL_shader_integer_functions2");
         binOp = node->getOp();
         break;
 
-    case glslang::EOpIgnoreIntersectionNV:
-    case glslang::EOpTerminateRayNV:
-    case glslang::EOpTraceNV:
-    case glslang::EOpTraceRayMotionNV:
-    case glslang::EOpTraceKHR:
-    case glslang::EOpExecuteCallableNV:
-    case glslang::EOpExecuteCallableKHR:
-    case glslang::EOpWritePackedPrimitiveIndices4x8NV:
+    case qglslang::EOpIgnoreIntersectionNV:
+    case qglslang::EOpTerminateRayNV:
+    case qglslang::EOpTraceNV:
+    case qglslang::EOpTraceRayMotionNV:
+    case qglslang::EOpTraceKHR:
+    case qglslang::EOpExecuteCallableNV:
+    case qglslang::EOpExecuteCallableKHR:
+    case qglslang::EOpWritePackedPrimitiveIndices4x8NV:
         noReturnValue = true;
         break;
-    case glslang::EOpRayQueryInitialize:
-    case glslang::EOpRayQueryTerminate:
-    case glslang::EOpRayQueryGenerateIntersection:
-    case glslang::EOpRayQueryConfirmIntersection:
+    case qglslang::EOpRayQueryInitialize:
+    case qglslang::EOpRayQueryTerminate:
+    case qglslang::EOpRayQueryGenerateIntersection:
+    case qglslang::EOpRayQueryConfirmIntersection:
         builder.addExtension("SPV_KHR_ray_query");
         builder.addCapability(spv::CapabilityRayQueryKHR);
         noReturnValue = true;
         break;
-    case glslang::EOpRayQueryProceed:
-    case glslang::EOpRayQueryGetIntersectionType:
-    case glslang::EOpRayQueryGetRayTMin:
-    case glslang::EOpRayQueryGetRayFlags:
-    case glslang::EOpRayQueryGetIntersectionT:
-    case glslang::EOpRayQueryGetIntersectionInstanceCustomIndex:
-    case glslang::EOpRayQueryGetIntersectionInstanceId:
-    case glslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset:
-    case glslang::EOpRayQueryGetIntersectionGeometryIndex:
-    case glslang::EOpRayQueryGetIntersectionPrimitiveIndex:
-    case glslang::EOpRayQueryGetIntersectionBarycentrics:
-    case glslang::EOpRayQueryGetIntersectionFrontFace:
-    case glslang::EOpRayQueryGetIntersectionCandidateAABBOpaque:
-    case glslang::EOpRayQueryGetIntersectionObjectRayDirection:
-    case glslang::EOpRayQueryGetIntersectionObjectRayOrigin:
-    case glslang::EOpRayQueryGetWorldRayDirection:
-    case glslang::EOpRayQueryGetWorldRayOrigin:
-    case glslang::EOpRayQueryGetIntersectionObjectToWorld:
-    case glslang::EOpRayQueryGetIntersectionWorldToObject:
+    case qglslang::EOpRayQueryProceed:
+    case qglslang::EOpRayQueryGetIntersectionType:
+    case qglslang::EOpRayQueryGetRayTMin:
+    case qglslang::EOpRayQueryGetRayFlags:
+    case qglslang::EOpRayQueryGetIntersectionT:
+    case qglslang::EOpRayQueryGetIntersectionInstanceCustomIndex:
+    case qglslang::EOpRayQueryGetIntersectionInstanceId:
+    case qglslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset:
+    case qglslang::EOpRayQueryGetIntersectionGeometryIndex:
+    case qglslang::EOpRayQueryGetIntersectionPrimitiveIndex:
+    case qglslang::EOpRayQueryGetIntersectionBarycentrics:
+    case qglslang::EOpRayQueryGetIntersectionFrontFace:
+    case qglslang::EOpRayQueryGetIntersectionCandidateAABBOpaque:
+    case qglslang::EOpRayQueryGetIntersectionObjectRayDirection:
+    case qglslang::EOpRayQueryGetIntersectionObjectRayOrigin:
+    case qglslang::EOpRayQueryGetWorldRayDirection:
+    case qglslang::EOpRayQueryGetWorldRayOrigin:
+    case qglslang::EOpRayQueryGetIntersectionObjectToWorld:
+    case qglslang::EOpRayQueryGetIntersectionWorldToObject:
         builder.addExtension("SPV_KHR_ray_query");
         builder.addCapability(spv::CapabilityRayQueryKHR);
         break;
-    case glslang::EOpCooperativeMatrixLoad:
-    case glslang::EOpCooperativeMatrixStore:
+    case qglslang::EOpCooperativeMatrixLoad:
+    case qglslang::EOpCooperativeMatrixStore:
         noReturnValue = true;
         break;
-    case glslang::EOpBeginInvocationInterlock:
-    case glslang::EOpEndInvocationInterlock:
+    case qglslang::EOpBeginInvocationInterlock:
+    case qglslang::EOpEndInvocationInterlock:
         builder.addExtension(spv::E_SPV_EXT_fragment_shader_interlock);
         noReturnValue = true;
         break;
 #endif
 
-    case glslang::EOpDebugPrintf:
+    case qglslang::EOpDebugPrintf:
         noReturnValue = true;
         break;
 
@@ -3132,9 +3132,9 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
     //
     // See if it maps to a regular operation.
     //
-    if (binOp != glslang::EOpNull) {
-        glslang::TIntermTyped* left = node->getSequence()[0]->getAsTyped();
-        glslang::TIntermTyped* right = node->getSequence()[1]->getAsTyped();
+    if (binOp != qglslang::EOpNull) {
+        qglslang::TIntermTyped* left = node->getSequence()[0]->getAsTyped();
+        qglslang::TIntermTyped* right = node->getSequence()[1]->getAsTyped();
         assert(left && right);
 
         builder.clearAccessChain();
@@ -3164,61 +3164,61 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
     //
     // Create the list of operands.
     //
-    glslang::TIntermSequence& glslangOperands = node->getSequence();
+    qglslang::TIntermSequence& glslangOperands = node->getSequence();
     std::vector<spv::Id> operands;
     std::vector<spv::IdImmediate> memoryAccessOperands;
     for (int arg = 0; arg < (int)glslangOperands.size(); ++arg) {
         // special case l-value operands; there are just a few
         bool lvalue = false;
         switch (node->getOp()) {
-        case glslang::EOpModf:
+        case qglslang::EOpModf:
             if (arg == 1)
                 lvalue = true;
             break;
 
-        case glslang::EOpRayQueryInitialize:
-        case glslang::EOpRayQueryTerminate:
-        case glslang::EOpRayQueryConfirmIntersection:
-        case glslang::EOpRayQueryProceed:
-        case glslang::EOpRayQueryGenerateIntersection:
-        case glslang::EOpRayQueryGetIntersectionType:
-        case glslang::EOpRayQueryGetIntersectionT:
-        case glslang::EOpRayQueryGetIntersectionInstanceCustomIndex:
-        case glslang::EOpRayQueryGetIntersectionInstanceId:
-        case glslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset:
-        case glslang::EOpRayQueryGetIntersectionGeometryIndex:
-        case glslang::EOpRayQueryGetIntersectionPrimitiveIndex:
-        case glslang::EOpRayQueryGetIntersectionBarycentrics:
-        case glslang::EOpRayQueryGetIntersectionFrontFace:
-        case glslang::EOpRayQueryGetIntersectionObjectRayDirection:
-        case glslang::EOpRayQueryGetIntersectionObjectRayOrigin:
-        case glslang::EOpRayQueryGetIntersectionObjectToWorld:
-        case glslang::EOpRayQueryGetIntersectionWorldToObject:
+        case qglslang::EOpRayQueryInitialize:
+        case qglslang::EOpRayQueryTerminate:
+        case qglslang::EOpRayQueryConfirmIntersection:
+        case qglslang::EOpRayQueryProceed:
+        case qglslang::EOpRayQueryGenerateIntersection:
+        case qglslang::EOpRayQueryGetIntersectionType:
+        case qglslang::EOpRayQueryGetIntersectionT:
+        case qglslang::EOpRayQueryGetIntersectionInstanceCustomIndex:
+        case qglslang::EOpRayQueryGetIntersectionInstanceId:
+        case qglslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset:
+        case qglslang::EOpRayQueryGetIntersectionGeometryIndex:
+        case qglslang::EOpRayQueryGetIntersectionPrimitiveIndex:
+        case qglslang::EOpRayQueryGetIntersectionBarycentrics:
+        case qglslang::EOpRayQueryGetIntersectionFrontFace:
+        case qglslang::EOpRayQueryGetIntersectionObjectRayDirection:
+        case qglslang::EOpRayQueryGetIntersectionObjectRayOrigin:
+        case qglslang::EOpRayQueryGetIntersectionObjectToWorld:
+        case qglslang::EOpRayQueryGetIntersectionWorldToObject:
             if (arg == 0)
                 lvalue = true;
             break;
 
-        case glslang::EOpAtomicAdd:
-        case glslang::EOpAtomicSubtract:
-        case glslang::EOpAtomicMin:
-        case glslang::EOpAtomicMax:
-        case glslang::EOpAtomicAnd:
-        case glslang::EOpAtomicOr:
-        case glslang::EOpAtomicXor:
-        case glslang::EOpAtomicExchange:
-        case glslang::EOpAtomicCompSwap:
+        case qglslang::EOpAtomicAdd:
+        case qglslang::EOpAtomicSubtract:
+        case qglslang::EOpAtomicMin:
+        case qglslang::EOpAtomicMax:
+        case qglslang::EOpAtomicAnd:
+        case qglslang::EOpAtomicOr:
+        case qglslang::EOpAtomicXor:
+        case qglslang::EOpAtomicExchange:
+        case qglslang::EOpAtomicCompSwap:
             if (arg == 0)
                 lvalue = true;
             break;
 
 #ifndef GLSLANG_WEB
-        case glslang::EOpFrexp:
+        case qglslang::EOpFrexp:
             if (arg == 1)
                 lvalue = true;
             break;
-        case glslang::EOpInterpolateAtSample:
-        case glslang::EOpInterpolateAtOffset:
-        case glslang::EOpInterpolateAtVertex:
+        case qglslang::EOpInterpolateAtSample:
+        case qglslang::EOpInterpolateAtOffset:
+        case qglslang::EOpInterpolateAtVertex:
             if (arg == 0) {
                 // If GLSL, use the address of the interpolant argument.
                 // If HLSL, use an internal version of OpInterolates that takes
@@ -3226,7 +3226,7 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
                 // legalization will remove the OpLoad and convert to an lvalue.
                 // Had to do this because legalization will only propagate a
                 // builtin into an rvalue.
-                lvalue = glslangIntermediate->getSource() != glslang::EShSourceHlsl;
+                lvalue = glslangIntermediate->getSource() != qglslang::EShSourceHlsl;
 
                 // Does it need a swizzle inversion?  If so, evaluation is inverted;
                 // operate first on the swizzle base, then apply the swizzle.
@@ -3235,44 +3235,44 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
                 //    interpolate(v.zy)  ->  interpolate(v).zy
                 //
                 if (glslangOperands[0]->getAsOperator() &&
-                    glslangOperands[0]->getAsOperator()->getOp() == glslang::EOpVectorSwizzle)
+                    glslangOperands[0]->getAsOperator()->getOp() == qglslang::EOpVectorSwizzle)
                     invertedType = convertGlslangToSpvType(
                         glslangOperands[0]->getAsBinaryNode()->getLeft()->getType());
             }
             break;
-        case glslang::EOpAtomicLoad:
-        case glslang::EOpAtomicStore:
-        case glslang::EOpAtomicCounterAdd:
-        case glslang::EOpAtomicCounterSubtract:
-        case glslang::EOpAtomicCounterMin:
-        case glslang::EOpAtomicCounterMax:
-        case glslang::EOpAtomicCounterAnd:
-        case glslang::EOpAtomicCounterOr:
-        case glslang::EOpAtomicCounterXor:
-        case glslang::EOpAtomicCounterExchange:
-        case glslang::EOpAtomicCounterCompSwap:
+        case qglslang::EOpAtomicLoad:
+        case qglslang::EOpAtomicStore:
+        case qglslang::EOpAtomicCounterAdd:
+        case qglslang::EOpAtomicCounterSubtract:
+        case qglslang::EOpAtomicCounterMin:
+        case qglslang::EOpAtomicCounterMax:
+        case qglslang::EOpAtomicCounterAnd:
+        case qglslang::EOpAtomicCounterOr:
+        case qglslang::EOpAtomicCounterXor:
+        case qglslang::EOpAtomicCounterExchange:
+        case qglslang::EOpAtomicCounterCompSwap:
             if (arg == 0)
                 lvalue = true;
             break;
-        case glslang::EOpAddCarry:
-        case glslang::EOpSubBorrow:
+        case qglslang::EOpAddCarry:
+        case qglslang::EOpSubBorrow:
             if (arg == 2)
                 lvalue = true;
             break;
-        case glslang::EOpUMulExtended:
-        case glslang::EOpIMulExtended:
+        case qglslang::EOpUMulExtended:
+        case qglslang::EOpIMulExtended:
             if (arg >= 2)
                 lvalue = true;
             break;
-        case glslang::EOpCooperativeMatrixLoad:
+        case qglslang::EOpCooperativeMatrixLoad:
             if (arg == 0 || arg == 1)
                 lvalue = true;
             break;
-        case glslang::EOpCooperativeMatrixStore:
+        case qglslang::EOpCooperativeMatrixStore:
             if (arg == 1)
                 lvalue = true;
             break;
-        case glslang::EOpSpirvInst:
+        case qglslang::EOpSpirvInst:
             if (glslangOperands[arg]->getAsTyped()->getQualifier().isSpirvByReference())
                 lvalue = true;
             break;
@@ -3287,8 +3287,8 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
             glslangOperands[arg]->traverse(this);
 
 #ifndef GLSLANG_WEB
-        if (node->getOp() == glslang::EOpCooperativeMatrixLoad ||
-            node->getOp() == glslang::EOpCooperativeMatrixStore) {
+        if (node->getOp() == qglslang::EOpCooperativeMatrixLoad ||
+            node->getOp() == qglslang::EOpCooperativeMatrixStore) {
 
             if (arg == 1) {
                 // fold "element" parameter into the access chain
@@ -3309,9 +3309,9 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
                 unsigned int alignment = builder.getAccessChain().alignment;
 
                 int memoryAccess = TranslateMemoryAccess(coherentFlags);
-                if (node->getOp() == glslang::EOpCooperativeMatrixLoad)
+                if (node->getOp() == qglslang::EOpCooperativeMatrixLoad)
                     memoryAccess &= ~spv::MemoryAccessMakePointerAvailableKHRMask;
-                if (node->getOp() == glslang::EOpCooperativeMatrixStore)
+                if (node->getOp() == qglslang::EOpCooperativeMatrixStore)
                     memoryAccess &= ~spv::MemoryAccessMakePointerVisibleKHRMask;
                 if (builder.getStorageClass(builder.getAccessChain().base) ==
                     spv::StorageClassPhysicalStorageBufferEXT) {
@@ -3354,29 +3354,29 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
             lvalueCoherentFlags |= TranslateCoherent(glslangOperands[arg]->getAsTyped()->getType());
         } else {
             builder.setLine(node->getLoc().line, node->getLoc().getFilename());
-             glslang::TOperator glslangOp = node->getOp();
+             qglslang::TOperator glslangOp = node->getOp();
              if (arg == 1 &&
-                (glslangOp == glslang::EOpRayQueryGetIntersectionType ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionT ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionInstanceCustomIndex ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionInstanceId ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionGeometryIndex ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionPrimitiveIndex ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionBarycentrics ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionFrontFace ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionObjectRayDirection ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionObjectRayOrigin ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionObjectToWorld ||
-                 glslangOp == glslang::EOpRayQueryGetIntersectionWorldToObject
+                (glslangOp == qglslang::EOpRayQueryGetIntersectionType ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionT ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionInstanceCustomIndex ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionInstanceId ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionGeometryIndex ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionPrimitiveIndex ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionBarycentrics ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionFrontFace ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionObjectRayDirection ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionObjectRayOrigin ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionObjectToWorld ||
+                 glslangOp == qglslang::EOpRayQueryGetIntersectionWorldToObject
                     )) {
                 bool cond = glslangOperands[arg]->getAsConstantUnion()->getConstArray()[0].getBConst();
                 operands.push_back(builder.makeIntConstant(cond ? 1 : 0));
-             } else if ((arg == 10 && glslangOp == glslang::EOpTraceKHR) ||
-                        (arg == 11 && glslangOp == glslang::EOpTraceRayMotionNV) ||
-                        (arg == 1  && glslangOp == glslang::EOpExecuteCallableKHR)) {
-                 const int opdNum = glslangOp == glslang::EOpTraceKHR ? 10 : (glslangOp == glslang::EOpTraceRayMotionNV ? 11 : 1);
-                 const int set = glslangOp == glslang::EOpExecuteCallableKHR ? 1 : 0;
+             } else if ((arg == 10 && glslangOp == qglslang::EOpTraceKHR) ||
+                        (arg == 11 && glslangOp == qglslang::EOpTraceRayMotionNV) ||
+                        (arg == 1  && glslangOp == qglslang::EOpExecuteCallableKHR)) {
+                 const int opdNum = glslangOp == qglslang::EOpTraceKHR ? 10 : (glslangOp == qglslang::EOpTraceRayMotionNV ? 11 : 1);
+                 const int set = glslangOp == qglslang::EOpExecuteCallableKHR ? 1 : 0;
 
                  const int location = glslangOperands[opdNum]->getAsConstantUnion()->getConstArray()[0].getUConst();
                  auto itNode = locationToSymbol[set].find(location);
@@ -3396,7 +3396,7 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
 
     builder.setLine(node->getLoc().line, node->getLoc().getFilename());
 #ifndef GLSLANG_WEB
-    if (node->getOp() == glslang::EOpCooperativeMatrixLoad) {
+    if (node->getOp() == qglslang::EOpCooperativeMatrixLoad) {
         std::vector<spv::IdImmediate> idImmOps;
 
         idImmOps.push_back(spv::IdImmediate(true, operands[1])); // buf
@@ -3411,7 +3411,7 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
         // store the result to the pointer (out param 'm')
         builder.createStore(result, operands[0]);
         result = 0;
-    } else if (node->getOp() == glslang::EOpCooperativeMatrixStore) {
+    } else if (node->getOp() == qglslang::EOpCooperativeMatrixStore) {
         std::vector<spv::IdImmediate> idImmOps;
 
         idImmOps.push_back(spv::IdImmediate(true, operands[1])); // buf
@@ -3426,12 +3426,12 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
 #endif
     if (atomic) {
         // Handle all atomics
-        glslang::TBasicType typeProxy = (node->getOp() == glslang::EOpAtomicStore)
+        qglslang::TBasicType typeProxy = (node->getOp() == qglslang::EOpAtomicStore)
             ? node->getSequence()[0]->getAsTyped()->getBasicType() : node->getBasicType();
         result = createAtomicOperation(node->getOp(), precision, resultType(), operands, typeProxy,
             lvalueCoherentFlags);
 #ifndef GLSLANG_WEB
-    } else if (node->getOp() == glslang::EOpSpirvInst) {
+    } else if (node->getOp() == qglslang::EOpSpirvInst) {
         const auto& spirvInst = node->getSpirvInstruction();
         if (spirvInst.set == "") {
             std::vector<spv::IdImmediate> idImmOps;
@@ -3439,7 +3439,7 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
                 if (glslangOperands[i]->getAsTyped()->getQualifier().isSpirvLiteral()) {
                     // Translate the constant to a literal value
                     std::vector<unsigned> literals;
-                    glslang::TVector<const glslang::TIntermConstantUnion*> constants;
+                    qglslang::TVector<const qglslang::TIntermConstantUnion*> constants;
                     constants.push_back(glslangOperands[i]->getAsConstantUnion());
                     TranslateLiterals(constants, literals);
                     idImmOps.push_back({false, literals[0]});
@@ -3447,7 +3447,7 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
                     idImmOps.push_back({true, operands[i]});
             }
 
-            if (node->getBasicType() == glslang::EbtVoid)
+            if (node->getBasicType() == qglslang::EbtVoid)
                 builder.createNoResultOp(static_cast<spv::Op>(spirvInst.id), idImmOps);
             else
                 result = builder.createOp(static_cast<spv::Op>(spirvInst.id), resultType(), idImmOps);
@@ -3456,9 +3456,9 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
                 resultType(), spirvInst.set == "GLSL.std.450" ? stdBuiltins : getExtBuiltins(spirvInst.set.c_str()),
                 spirvInst.id, operands);
         }
-        noReturnValue = node->getBasicType() == glslang::EbtVoid;
+        noReturnValue = node->getBasicType() == qglslang::EbtVoid;
 #endif
-    } else if (node->getOp() == glslang::EOpDebugPrintf) {
+    } else if (node->getOp() == qglslang::EOpDebugPrintf) {
         if (!nonSemanticDebugPrintf) {
             nonSemanticDebugPrintf = builder.import("NonSemantic.DebugPrintf");
         }
@@ -3518,14 +3518,14 @@ bool TGlslangToSpvTraverser::visitAggregate(glslang::TVisit visit, glslang::TInt
 // if we have an l-value, that can be more efficient if it will
 // become the base of a complex r-value expression, because the
 // next layer copies r-values into memory to use the access-chain mechanism
-bool TGlslangToSpvTraverser::visitSelection(glslang::TVisit /* visit */, glslang::TIntermSelection* node)
+bool TGlslangToSpvTraverser::visitSelection(qglslang::TVisit /* visit */, qglslang::TIntermSelection* node)
 {
     // see if OpSelect can handle it
     const auto isOpSelectable = [&]() {
-        if (node->getBasicType() == glslang::EbtVoid)
+        if (node->getBasicType() == qglslang::EbtVoid)
             return false;
         // OpSelect can do all other types starting with SPV 1.4
-        if (glslangIntermediate->getSpv().spv < glslang::EShTargetSpv_1_4) {
+        if (glslangIntermediate->getSpv().spv < qglslang::EShTargetSpv_1_4) {
             // pre-1.4, only scalars and vectors can be handled
             if ((!node->getType().isScalar() && !node->getType().isVector()))
                 return false;
@@ -3558,7 +3558,7 @@ bool TGlslangToSpvTraverser::visitSelection(glslang::TVisit /* visit */, glslang
                node->getType() == node->getFalseBlock()->getAsTyped()->getType());
 
         // return true if a single operand to ? : is okay for OpSelect
-        const auto operandOkay = [](glslang::TIntermTyped* node) {
+        const auto operandOkay = [](qglslang::TIntermTyped* node) {
             return node->getAsSymbolNode() || node->getType().getQualifier().isConstant();
         };
 
@@ -3582,7 +3582,7 @@ bool TGlslangToSpvTraverser::visitSelection(glslang::TVisit /* visit */, glslang
         builder.setLine(node->getLoc().line, node->getLoc().getFilename());
 
         // done if void
-        if (node->getBasicType() == glslang::EbtVoid)
+        if (node->getBasicType() == qglslang::EbtVoid)
             return;
 
         // emit code to select between trueValue and falseValue
@@ -3593,7 +3593,7 @@ bool TGlslangToSpvTraverser::visitSelection(glslang::TVisit /* visit */, glslang
 
             // smear condition to vector, if necessary (AST is always scalar)
             // Before 1.4, smear like for mix(), starting with 1.4, keep it scalar
-            if (glslangIntermediate->getSpv().spv < glslang::EShTargetSpv_1_4 && builder.isVector(trueValue)) {
+            if (glslangIntermediate->getSpv().spv < qglslang::EShTargetSpv_1_4 && builder.isVector(trueValue)) {
                 condition = builder.smearScalar(spv::NoPrecision, condition, 
                                                 builder.makeVectorType(builder.makeBoolType(),
                                                                        builder.getNumComponents(trueValue)));
@@ -3635,7 +3635,7 @@ bool TGlslangToSpvTraverser::visitSelection(glslang::TVisit /* visit */, glslang
     // Execute the one side needed, as per the condition
     const auto executeOneSide = [&]() {
         // Always emit control flow.
-        if (node->getBasicType() != glslang::EbtVoid) {
+        if (node->getBasicType() != qglslang::EbtVoid) {
             result = builder.createVariable(TranslatePrecisionDecoration(node->getType()), spv::StorageClassFunction,
                 convertGlslangToSpvType(node->getType()));
         }
@@ -3682,7 +3682,7 @@ bool TGlslangToSpvTraverser::visitSelection(glslang::TVisit /* visit */, glslang
     return false;
 }
 
-bool TGlslangToSpvTraverser::visitSwitch(glslang::TVisit /* visit */, glslang::TIntermSwitch* node)
+bool TGlslangToSpvTraverser::visitSwitch(qglslang::TVisit /* visit */, qglslang::TIntermSwitch* node)
 {
     // emit and get the condition before doing anything with switch
     node->getCondition()->traverse(this);
@@ -3694,14 +3694,14 @@ bool TGlslangToSpvTraverser::visitSwitch(glslang::TVisit /* visit */, glslang::T
     // browse the children to sort out code segments
     int defaultSegment = -1;
     std::vector<TIntermNode*> codeSegments;
-    glslang::TIntermSequence& sequence = node->getBody()->getSequence();
+    qglslang::TIntermSequence& sequence = node->getBody()->getSequence();
     std::vector<int> caseValues;
     std::vector<int> valueIndexToSegment(sequence.size());  // note: probably not all are used, it is an overestimate
-    for (glslang::TIntermSequence::iterator c = sequence.begin(); c != sequence.end(); ++c) {
+    for (qglslang::TIntermSequence::iterator c = sequence.begin(); c != sequence.end(); ++c) {
         TIntermNode* child = *c;
-        if (child->getAsBranchNode() && child->getAsBranchNode()->getFlowOp() == glslang::EOpDefault)
+        if (child->getAsBranchNode() && child->getAsBranchNode()->getFlowOp() == qglslang::EOpDefault)
             defaultSegment = (int)codeSegments.size();
-        else if (child->getAsBranchNode() && child->getAsBranchNode()->getFlowOp() == glslang::EOpCase) {
+        else if (child->getAsBranchNode() && child->getAsBranchNode()->getFlowOp() == qglslang::EOpCase) {
             valueIndexToSegment[caseValues.size()] = (int)codeSegments.size();
             caseValues.push_back(child->getAsBranchNode()->getExpression()->getAsConstantUnion()
                 ->getConstArray()[0].getIConst());
@@ -3736,7 +3736,7 @@ bool TGlslangToSpvTraverser::visitSwitch(glslang::TVisit /* visit */, glslang::T
     return false;
 }
 
-void TGlslangToSpvTraverser::visitConstantUnion(glslang::TIntermConstantUnion* node)
+void TGlslangToSpvTraverser::visitConstantUnion(qglslang::TIntermConstantUnion* node)
 {
 #ifndef GLSLANG_WEB
     if (node->getQualifier().isSpirvLiteral())
@@ -3750,7 +3750,7 @@ void TGlslangToSpvTraverser::visitConstantUnion(glslang::TIntermConstantUnion* n
     builder.setAccessChainRValue(constant);
 }
 
-bool TGlslangToSpvTraverser::visitLoop(glslang::TVisit /* visit */, glslang::TIntermLoop* node)
+bool TGlslangToSpvTraverser::visitLoop(qglslang::TVisit /* visit */, qglslang::TIntermLoop* node)
 {
     auto blocks = builder.makeNewLoop();
     builder.createBranch(&blocks.head);
@@ -3819,7 +3819,7 @@ bool TGlslangToSpvTraverser::visitLoop(glslang::TVisit /* visit */, glslang::TIn
     return false;
 }
 
-bool TGlslangToSpvTraverser::visitBranch(glslang::TVisit /* visit */, glslang::TIntermBranch* node)
+bool TGlslangToSpvTraverser::visitBranch(qglslang::TVisit /* visit */, qglslang::TIntermBranch* node)
 {
     if (node->getExpression())
         node->getExpression()->traverse(this);
@@ -3827,9 +3827,9 @@ bool TGlslangToSpvTraverser::visitBranch(glslang::TVisit /* visit */, glslang::T
     builder.setLine(node->getLoc().line, node->getLoc().getFilename());
 
     switch (node->getFlowOp()) {
-    case glslang::EOpKill:
-        if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_6) {
-            if (glslangIntermediate->getSource() == glslang::EShSourceHlsl) {
+    case qglslang::EOpKill:
+        if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_6) {
+            if (glslangIntermediate->getSource() == qglslang::EShSourceHlsl) {
               builder.addCapability(spv::CapabilityDemoteToHelperInvocation);
               builder.createNoResultOp(spv::OpDemoteToHelperInvocationEXT);
             } else {
@@ -3839,22 +3839,22 @@ bool TGlslangToSpvTraverser::visitBranch(glslang::TVisit /* visit */, glslang::T
             builder.makeStatementTerminator(spv::OpKill, "post-discard");
         }
         break;
-    case glslang::EOpTerminateInvocation:
+    case qglslang::EOpTerminateInvocation:
         builder.addExtension(spv::E_SPV_KHR_terminate_invocation);
         builder.makeStatementTerminator(spv::OpTerminateInvocation, "post-terminate-invocation");
         break;
-    case glslang::EOpBreak:
+    case qglslang::EOpBreak:
         if (breakForLoop.top())
             builder.createLoopExit();
         else
             builder.addSwitchBreak();
         break;
-    case glslang::EOpContinue:
+    case qglslang::EOpContinue:
         builder.createLoopContinue();
         break;
-    case glslang::EOpReturn:
+    case qglslang::EOpReturn:
         if (node->getExpression() != nullptr) {
-            const glslang::TType& glslangReturnType = node->getExpression()->getType();
+            const qglslang::TType& glslangReturnType = node->getExpression()->getType();
             spv::Id returnId = accessChainLoad(glslangReturnType);
             if (builder.getTypeId(returnId) != currentFunction->getReturnType() ||
                 TranslatePrecisionDecoration(glslangReturnType) != currentFunction->getReturnPrecision()) {
@@ -3873,15 +3873,15 @@ bool TGlslangToSpvTraverser::visitBranch(glslang::TVisit /* visit */, glslang::T
         break;
 
 #ifndef GLSLANG_WEB
-    case glslang::EOpDemote:
+    case qglslang::EOpDemote:
         builder.createNoResultOp(spv::OpDemoteToHelperInvocationEXT);
         builder.addExtension(spv::E_SPV_EXT_demote_to_helper_invocation);
         builder.addCapability(spv::CapabilityDemoteToHelperInvocationEXT);
         break;
-    case glslang::EOpTerminateRayKHR:
+    case qglslang::EOpTerminateRayKHR:
         builder.makeStatementTerminator(spv::OpTerminateRayKHR, "post-terminateRayKHR");
         break;
-    case glslang::EOpIgnoreIntersectionKHR:
+    case qglslang::EOpIgnoreIntersectionKHR:
         builder.makeStatementTerminator(spv::OpIgnoreIntersectionKHR, "post-ignoreIntersectionKHR");
         break;
 #endif
@@ -3894,7 +3894,7 @@ bool TGlslangToSpvTraverser::visitBranch(glslang::TVisit /* visit */, glslang::T
     return false;
 }
 
-spv::Id TGlslangToSpvTraverser::createSpvVariable(const glslang::TIntermSymbol* node, spv::Id forcedType)
+spv::Id TGlslangToSpvTraverser::createSpvVariable(const qglslang::TIntermSymbol* node, spv::Id forcedType)
 {
     // First, steer off constants, which are not SPIR-V variables, but
     // can still have a mapping to a SPIR-V Id.
@@ -3921,7 +3921,7 @@ spv::Id TGlslangToSpvTraverser::createSpvVariable(const glslang::TIntermSymbol*
             break;
         case spv::StorageClassUniform:
             builder.addIncorporatedExtension(spv::E_SPV_KHR_16bit_storage, spv::Spv_1_3);
-            if (node->getType().getQualifier().storage == glslang::EvqBuffer)
+            if (node->getType().getQualifier().storage == qglslang::EvqBuffer)
                 builder.addCapability(spv::CapabilityStorageUniformBufferBlock16);
             else
                 builder.addCapability(spv::CapabilityStorageUniform16);
@@ -3939,7 +3939,7 @@ spv::Id TGlslangToSpvTraverser::createSpvVariable(const glslang::TIntermSymbol*
 #endif
         default:
             if (storageClass == spv::StorageClassWorkgroup &&
-                node->getType().getBasicType() == glslang::EbtBlock) {
+                node->getType().getBasicType() == qglslang::EbtBlock) {
                 builder.addCapability(spv::CapabilityWorkgroupMemoryExplicitLayout16BitAccessKHR);
                 break;
             }
@@ -3962,7 +3962,7 @@ spv::Id TGlslangToSpvTraverser::createSpvVariable(const glslang::TIntermSymbol*
             builder.addIncorporatedExtension(spv::E_SPV_KHR_8bit_storage, spv::Spv_1_5);
             builder.addCapability(spv::CapabilityStorageBuffer8BitAccess);
         } else if (storageClass == spv::StorageClassWorkgroup &&
-                   node->getType().getBasicType() == glslang::EbtBlock) {
+                   node->getType().getBasicType() == qglslang::EbtBlock) {
             builder.addCapability(spv::CapabilityWorkgroupMemoryExplicitLayout8BitAccessKHR);
         } else {
             builder.addCapability(spv::CapabilityInt8);
@@ -3970,12 +3970,12 @@ spv::Id TGlslangToSpvTraverser::createSpvVariable(const glslang::TIntermSymbol*
     }
 
     const char* name = node->getName().c_str();
-    if (glslang::IsAnonymous(name))
+    if (qglslang::IsAnonymous(name))
         name = "";
 
     spv::Id initializer = spv::NoResult;
 
-    if (node->getType().getQualifier().storage == glslang::EvqUniform && !node->getConstArray().empty()) {
+    if (node->getType().getQualifier().storage == qglslang::EvqUniform && !node->getConstArray().empty()) {
         int nextConst = 0;
         initializer = createSpvConstantFromConstUnionArray(node->getType(),
                                                            node->getConstArray(),
@@ -3989,22 +3989,22 @@ spv::Id TGlslangToSpvTraverser::createSpvVariable(const glslang::TIntermSymbol*
 }
 
 // Return type Id of the sampled type.
-spv::Id TGlslangToSpvTraverser::getSampledType(const glslang::TSampler& sampler)
+spv::Id TGlslangToSpvTraverser::getSampledType(const qglslang::TSampler& sampler)
 {
     switch (sampler.type) {
-        case glslang::EbtInt:      return builder.makeIntType(32);
-        case glslang::EbtUint:     return builder.makeUintType(32);
-        case glslang::EbtFloat:    return builder.makeFloatType(32);
+        case qglslang::EbtInt:      return builder.makeIntType(32);
+        case qglslang::EbtUint:     return builder.makeUintType(32);
+        case qglslang::EbtFloat:    return builder.makeFloatType(32);
 #ifndef GLSLANG_WEB
-        case glslang::EbtFloat16:
+        case qglslang::EbtFloat16:
             builder.addExtension(spv::E_SPV_AMD_gpu_shader_half_float_fetch);
             builder.addCapability(spv::CapabilityFloat16ImageAMD);
             return builder.makeFloatType(16);
-        case glslang::EbtInt64:
+        case qglslang::EbtInt64:
             builder.addExtension(spv::E_SPV_EXT_shader_image_int64);
             builder.addCapability(spv::CapabilityInt64ImageEXT);
             return builder.makeIntType(64);
-        case glslang::EbtUint64:
+        case qglslang::EbtUint64:
             builder.addExtension(spv::E_SPV_EXT_shader_image_int64);
             builder.addCapability(spv::CapabilityInt64ImageEXT);
             return builder.makeUintType(64);
@@ -4018,10 +4018,10 @@ spv::Id TGlslangToSpvTraverser::getSampledType(const glslang::TSampler& sampler)
 // If node is a swizzle operation, return the type that should be used if
 // the swizzle base is first consumed by another operation, before the swizzle
 // is applied.
-spv::Id TGlslangToSpvTraverser::getInvertedSwizzleType(const glslang::TIntermTyped& node)
+spv::Id TGlslangToSpvTraverser::getInvertedSwizzleType(const qglslang::TIntermTyped& node)
 {
     if (node.getAsOperator() &&
-        node.getAsOperator()->getOp() == glslang::EOpVectorSwizzle)
+        node.getAsOperator()->getOp() == qglslang::EOpVectorSwizzle)
         return convertGlslangToSpvType(node.getAsBinaryNode()->getLeft()->getType());
     else
         return spv::NoType;
@@ -4029,7 +4029,7 @@ spv::Id TGlslangToSpvTraverser::getInvertedSwizzleType(const glslang::TIntermTyp
 
 // When inverting a swizzle with a parent op, this function
 // will apply the swizzle operation to a completed parent operation.
-spv::Id TGlslangToSpvTraverser::createInvertedSwizzle(spv::Decoration precision, const glslang::TIntermTyped& node,
+spv::Id TGlslangToSpvTraverser::createInvertedSwizzle(spv::Decoration precision, const qglslang::TIntermTyped& node,
     spv::Id parentResult)
 {
     std::vector<unsigned> swizzle;
@@ -4038,9 +4038,9 @@ spv::Id TGlslangToSpvTraverser::createInvertedSwizzle(spv::Decoration precision,
 }
 
 // Convert a glslang AST swizzle node to a swizzle vector for building SPIR-V.
-void TGlslangToSpvTraverser::convertSwizzle(const glslang::TIntermAggregate& node, std::vector<unsigned>& swizzle)
+void TGlslangToSpvTraverser::convertSwizzle(const qglslang::TIntermAggregate& node, std::vector<unsigned>& swizzle)
 {
-    const glslang::TIntermSequence& swizzleSequence = node.getSequence();
+    const qglslang::TIntermSequence& swizzleSequence = node.getSequence();
     for (int i = 0; i < (int)swizzleSequence.size(); ++i)
         swizzle.push_back(swizzleSequence[i]->getAsConstantUnion()->getConstArray()[0].getIConst());
 }
@@ -4048,7 +4048,7 @@ void TGlslangToSpvTraverser::convertSwizzle(const glslang::TIntermAggregate& nod
 // Convert from a glslang type to an SPV type, by calling into a
 // recursive version of this function. This establishes the inherited
 // layout state rooted from the top-level type.
-spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& type, bool forwardReferenceOnly)
+spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const qglslang::TType& type, bool forwardReferenceOnly)
 {
     return convertGlslangToSpvType(type, getExplicitLayout(type), type.getQualifier(), false, forwardReferenceOnly);
 }
@@ -4056,64 +4056,64 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
 // Do full recursive conversion of an arbitrary glslang type to a SPIR-V Id.
 // explicitLayout can be kept the same throughout the hierarchical recursive walk.
 // Mutually recursive with convertGlslangStructToSpvType().
-spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& type,
-    glslang::TLayoutPacking explicitLayout, const glslang::TQualifier& qualifier,
+spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const qglslang::TType& type,
+    qglslang::TLayoutPacking explicitLayout, const qglslang::TQualifier& qualifier,
     bool lastBufferBlockMember, bool forwardReferenceOnly)
 {
     spv::Id spvType = spv::NoResult;
 
     switch (type.getBasicType()) {
-    case glslang::EbtVoid:
+    case qglslang::EbtVoid:
         spvType = builder.makeVoidType();
         assert (! type.isArray());
         break;
-    case glslang::EbtBool:
+    case qglslang::EbtBool:
         // "transparent" bool doesn't exist in SPIR-V.  The GLSL convention is
         // a 32-bit int where non-0 means true.
-        if (explicitLayout != glslang::ElpNone)
+        if (explicitLayout != qglslang::ElpNone)
             spvType = builder.makeUintType(32);
         else
             spvType = builder.makeBoolType();
         break;
-    case glslang::EbtInt:
+    case qglslang::EbtInt:
         spvType = builder.makeIntType(32);
         break;
-    case glslang::EbtUint:
+    case qglslang::EbtUint:
         spvType = builder.makeUintType(32);
         break;
-    case glslang::EbtFloat:
+    case qglslang::EbtFloat:
         spvType = builder.makeFloatType(32);
         break;
 #ifndef GLSLANG_WEB
-    case glslang::EbtDouble:
+    case qglslang::EbtDouble:
         spvType = builder.makeFloatType(64);
         break;
-    case glslang::EbtFloat16:
+    case qglslang::EbtFloat16:
         spvType = builder.makeFloatType(16);
         break;
-    case glslang::EbtInt8:
+    case qglslang::EbtInt8:
         spvType = builder.makeIntType(8);
         break;
-    case glslang::EbtUint8:
+    case qglslang::EbtUint8:
         spvType = builder.makeUintType(8);
         break;
-    case glslang::EbtInt16:
+    case qglslang::EbtInt16:
         spvType = builder.makeIntType(16);
         break;
-    case glslang::EbtUint16:
+    case qglslang::EbtUint16:
         spvType = builder.makeUintType(16);
         break;
-    case glslang::EbtInt64:
+    case qglslang::EbtInt64:
         spvType = builder.makeIntType(64);
         break;
-    case glslang::EbtUint64:
+    case qglslang::EbtUint64:
         spvType = builder.makeUintType(64);
         break;
-    case glslang::EbtAtomicUint:
+    case qglslang::EbtAtomicUint:
         builder.addCapability(spv::CapabilityAtomicStorage);
         spvType = builder.makeUintType(32);
         break;
-    case glslang::EbtAccStruct:
+    case qglslang::EbtAccStruct:
         switch (glslangIntermediate->getStage()) {
         case EShLangRayGen:
         case EShLangIntersect:
@@ -4135,7 +4135,7 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
         }
         spvType = builder.makeAccelerationStructureType();
         break;
-    case glslang::EbtRayQuery:
+    case qglslang::EbtRayQuery:
         {
             auto& extensions = glslangIntermediate->getRequestedExtensions();
             if (extensions.find("GL_EXT_ray_query") != extensions.end()) {
@@ -4145,7 +4145,7 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
             spvType = builder.makeRayQueryType();
         }
         break;
-    case glslang::EbtReference:
+    case qglslang::EbtReference:
         {
             // Make the forward pointer, then recurse to convert the structure type, then
             // patch up the forward pointer with a real pointer type.
@@ -4163,9 +4163,9 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
         }
         break;
 #endif
-    case glslang::EbtSampler:
+    case qglslang::EbtSampler:
         {
-            const glslang::TSampler& sampler = type.getSampler();
+            const qglslang::TSampler& sampler = type.getSampler();
             if (sampler.isPureSampler()) {
                 spvType = builder.makeSamplerType();
             } else {
@@ -4180,11 +4180,11 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
             }
         }
         break;
-    case glslang::EbtStruct:
-    case glslang::EbtBlock:
+    case qglslang::EbtStruct:
+    case qglslang::EbtBlock:
         {
             // If we've seen this struct type, return it
-            const glslang::TTypeList* glslangMembers = type.getStruct();
+            const qglslang::TTypeList* glslangMembers = type.getStruct();
 
             // Try to share structs for different layouts, but not yet for other
             // kinds of qualification (primarily not yet including interpolant qualification).
@@ -4194,16 +4194,16 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
                 break;
 
             // else, we haven't seen it...
-            if (type.getBasicType() == glslang::EbtBlock)
+            if (type.getBasicType() == qglslang::EbtBlock)
                 memberRemapper[glslangTypeToIdMap[glslangMembers]].resize(glslangMembers->size());
             spvType = convertGlslangStructToSpvType(type, glslangMembers, explicitLayout, qualifier);
         }
         break;
-    case glslang::EbtString:
+    case qglslang::EbtString:
         // no type used for OpString
         return 0;
 #ifndef GLSLANG_WEB
-    case glslang::EbtSpirvType: {
+    case qglslang::EbtSpirvType: {
         // GL_EXT_spirv_intrinsics
         const auto& spirvType = type.getSpirvType();
         const auto& spirvInst = spirvType.spirvInst;
@@ -4212,20 +4212,20 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
         for (const auto& typeParam : spirvType.typeParams) {
             // Constant expression
             if (typeParam.constant->isLiteral()) {
-                if (typeParam.constant->getBasicType() == glslang::EbtFloat) {
+                if (typeParam.constant->getBasicType() == qglslang::EbtFloat) {
                     float floatValue = static_cast<float>(typeParam.constant->getConstArray()[0].getDConst());
                     unsigned literal = *reinterpret_cast<unsigned*>(&floatValue);
                     operands.push_back({false, literal});
-                } else if (typeParam.constant->getBasicType() == glslang::EbtInt) {
+                } else if (typeParam.constant->getBasicType() == qglslang::EbtInt) {
                     unsigned literal = typeParam.constant->getConstArray()[0].getIConst();
                     operands.push_back({false, literal});
-                } else if (typeParam.constant->getBasicType() == glslang::EbtUint) {
+                } else if (typeParam.constant->getBasicType() == qglslang::EbtUint) {
                     unsigned literal = typeParam.constant->getConstArray()[0].getUConst();
                     operands.push_back({false, literal});
-                } else if (typeParam.constant->getBasicType() == glslang::EbtBool) {
+                } else if (typeParam.constant->getBasicType() == qglslang::EbtBool) {
                     unsigned literal = typeParam.constant->getConstArray()[0].getBConst();
                     operands.push_back({false, literal});
-                } else if (typeParam.constant->getBasicType() == glslang::EbtString) {
+                } else if (typeParam.constant->getBasicType() == qglslang::EbtString) {
                     auto str = typeParam.constant->getConstArray()[0].getSConst()->c_str();
                     unsigned literal = 0;
                     char* literalPtr = reinterpret_cast<char*>(&literal);
@@ -4276,10 +4276,10 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
     if (type.isCoopMat()) {
         builder.addCapability(spv::CapabilityCooperativeMatrixNV);
         builder.addExtension(spv::E_SPV_NV_cooperative_matrix);
-        if (type.getBasicType() == glslang::EbtFloat16)
+        if (type.getBasicType() == qglslang::EbtFloat16)
             builder.addCapability(spv::CapabilityFloat16);
-        if (type.getBasicType() == glslang::EbtUint8 ||
-            type.getBasicType() == glslang::EbtInt8) {
+        if (type.getBasicType() == qglslang::EbtUint8 ||
+            type.getBasicType() == qglslang::EbtInt8) {
             builder.addCapability(spv::CapabilityInt8);
         }
 
@@ -4296,10 +4296,10 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
         // Do all but the outer dimension
         if (type.getArraySizes()->getNumDims() > 1) {
             // We need to decorate array strides for types needing explicit layout, except blocks.
-            if (explicitLayout != glslang::ElpNone && type.getBasicType() != glslang::EbtBlock) {
+            if (explicitLayout != qglslang::ElpNone && type.getBasicType() != qglslang::EbtBlock) {
                 // Use a dummy glslang type for querying internal strides of
                 // arrays of arrays, but using just a one-dimensional array.
-                glslang::TType simpleArrayType(type, 0); // deference type of the array
+                qglslang::TType simpleArrayType(type, 0); // deference type of the array
                 while (simpleArrayType.getArraySizes()->getNumDims() > 1)
                     simpleArrayType.getArraySizes()->dereference();
 
@@ -4319,7 +4319,7 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
             // single-dimensional array, and don't yet have stride
 
             // We need to decorate array strides for types needing explicit layout, except blocks.
-            if (explicitLayout != glslang::ElpNone && type.getBasicType() != glslang::EbtBlock)
+            if (explicitLayout != qglslang::ElpNone && type.getBasicType() != qglslang::EbtBlock)
                 stride = getArrayStride(type, explicitLayout, qualifier.layoutMatrix);
         }
 
@@ -4347,7 +4347,7 @@ spv::Id TGlslangToSpvTraverser::convertGlslangToSpvType(const glslang::TType& ty
 //
 // Identify interface members that don't have their required extension turned on.
 //
-bool TGlslangToSpvTraverser::filterMember(const glslang::TType& member)
+bool TGlslangToSpvTraverser::filterMember(const qglslang::TType& member)
 {
 #ifndef GLSLANG_WEB
     auto& extensions = glslangIntermediate->getRequestedExtensions();
@@ -4378,24 +4378,24 @@ bool TGlslangToSpvTraverser::filterMember(const glslang::TType& member)
 // Do full recursive conversion of a glslang structure (or block) type to a SPIR-V Id.
 // explicitLayout can be kept the same throughout the hierarchical recursive walk.
 // Mutually recursive with convertGlslangToSpvType().
-spv::Id TGlslangToSpvTraverser::convertGlslangStructToSpvType(const glslang::TType& type,
-                                                              const glslang::TTypeList* glslangMembers,
-                                                              glslang::TLayoutPacking explicitLayout,
-                                                              const glslang::TQualifier& qualifier)
+spv::Id TGlslangToSpvTraverser::convertGlslangStructToSpvType(const qglslang::TType& type,
+                                                              const qglslang::TTypeList* glslangMembers,
+                                                              qglslang::TLayoutPacking explicitLayout,
+                                                              const qglslang::TQualifier& qualifier)
 {
     // Create a vector of struct types for SPIR-V to consume
     std::vector<spv::Id> spvMembers;
     int memberDelta = 0;  // how much the member's index changes from glslang to SPIR-V, normally 0,
                           // except sometimes for blocks
-    std::vector<std::pair<glslang::TType*, glslang::TQualifier> > deferredForwardPointers;
+    std::vector<std::pair<qglslang::TType*, qglslang::TQualifier> > deferredForwardPointers;
     for (int i = 0; i < (int)glslangMembers->size(); i++) {
-        glslang::TType& glslangMember = *(*glslangMembers)[i].type;
+        qglslang::TType& glslangMember = *(*glslangMembers)[i].type;
         if (glslangMember.hiddenMember()) {
             ++memberDelta;
-            if (type.getBasicType() == glslang::EbtBlock)
+            if (type.getBasicType() == qglslang::EbtBlock)
                 memberRemapper[glslangTypeToIdMap[glslangMembers]][i] = -1;
         } else {
-            if (type.getBasicType() == glslang::EbtBlock) {
+            if (type.getBasicType() == qglslang::EbtBlock) {
                 if (filterMember(glslangMember)) {
                     memberDelta++;
                     memberRemapper[glslangTypeToIdMap[glslangMembers]][i] = -1;
@@ -4404,7 +4404,7 @@ spv::Id TGlslangToSpvTraverser::convertGlslangStructToSpvType(const glslang::TTy
                 memberRemapper[glslangTypeToIdMap[glslangMembers]][i] = i - memberDelta;
             }
             // modify just this child's view of the qualifier
-            glslang::TQualifier memberQualifier = glslangMember.getQualifier();
+            qglslang::TQualifier memberQualifier = glslangMember.getQualifier();
             InheritQualifiers(memberQualifier, qualifier);
 
             // manually inherit location
@@ -4412,7 +4412,7 @@ spv::Id TGlslangToSpvTraverser::convertGlslangStructToSpvType(const glslang::TTy
                 memberQualifier.layoutLocation = qualifier.layoutLocation;
 
             // recurse
-            bool lastBufferBlockMember = qualifier.storage == glslang::EvqBuffer &&
+            bool lastBufferBlockMember = qualifier.storage == qglslang::EvqBuffer &&
                                          i == (int)glslangMembers->size() - 1;
 
             // Make forward pointers for any pointer members, and create a list of members to
@@ -4448,10 +4448,10 @@ spv::Id TGlslangToSpvTraverser::convertGlslangStructToSpvType(const glslang::TTy
     return spvType;
 }
 
-void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
-                                                const glslang::TTypeList* glslangMembers,
-                                                glslang::TLayoutPacking explicitLayout,
-                                                const glslang::TQualifier& qualifier,
+void TGlslangToSpvTraverser::decorateStructType(const qglslang::TType& type,
+                                                const qglslang::TTypeList* glslangMembers,
+                                                qglslang::TLayoutPacking explicitLayout,
+                                                const qglslang::TQualifier& qualifier,
                                                 spv::Id spvType)
 {
     // Name and decorate the non-hidden members
@@ -4459,16 +4459,16 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
     bool memberLocationInvalid = type.isArrayOfArrays() ||
         (type.isArray() && (type.getQualifier().isArrayedIo(glslangIntermediate->getStage()) == false));
     for (int i = 0; i < (int)glslangMembers->size(); i++) {
-        glslang::TType& glslangMember = *(*glslangMembers)[i].type;
+        qglslang::TType& glslangMember = *(*glslangMembers)[i].type;
         int member = i;
-        if (type.getBasicType() == glslang::EbtBlock) {
+        if (type.getBasicType() == qglslang::EbtBlock) {
             member = memberRemapper[glslangTypeToIdMap[glslangMembers]][i];
             if (filterMember(glslangMember))
                 continue;
         }
 
         // modify just this child's view of the qualifier
-        glslang::TQualifier memberQualifier = glslangMember.getQualifier();
+        qglslang::TQualifier memberQualifier = glslangMember.getQualifier();
         InheritQualifiers(memberQualifier, qualifier);
 
         // using -1 above to indicate a hidden member
@@ -4481,10 +4481,10 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
         builder.addMemberDecoration(spvType, member, TranslatePrecisionDecoration(glslangMember));
         // Add interpolation and auxiliary storage decorations only to
         // top-level members of Input and Output storage classes
-        if (type.getQualifier().storage == glslang::EvqVaryingIn ||
-            type.getQualifier().storage == glslang::EvqVaryingOut) {
-            if (type.getBasicType() == glslang::EbtBlock ||
-                glslangIntermediate->getSource() == glslang::EShSourceHlsl) {
+        if (type.getQualifier().storage == qglslang::EvqVaryingIn ||
+            type.getQualifier().storage == qglslang::EvqVaryingOut) {
+            if (type.getBasicType() == qglslang::EbtBlock ||
+                glslangIntermediate->getSource() == qglslang::EShSourceHlsl) {
                 builder.addMemberDecoration(spvType, member, TranslateInterpolationDecoration(memberQualifier));
                 builder.addMemberDecoration(spvType, member, TranslateAuxiliaryStorageDecoration(memberQualifier));
 #ifndef GLSLANG_WEB
@@ -4495,8 +4495,8 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
         builder.addMemberDecoration(spvType, member, TranslateInvariantDecoration(memberQualifier));
 
 #ifndef GLSLANG_WEB
-        if (type.getBasicType() == glslang::EbtBlock &&
-            qualifier.storage == glslang::EvqBuffer) {
+        if (type.getBasicType() == qglslang::EbtBlock &&
+            qualifier.storage == qglslang::EvqBuffer) {
             // Add memory decorations only to top-level members of shader storage block
             std::vector<spv::Decoration> memory;
             TranslateMemoryDecoration(memberQualifier, memory, glslangIntermediate->usingVulkanMemoryModel());
@@ -4520,7 +4520,7 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
         if (glslangMember.getQualifier().hasXfbOffset())
             builder.addMemberDecoration(spvType, member, spv::DecorationOffset,
                                         glslangMember.getQualifier().layoutXfbOffset);
-        else if (explicitLayout != glslang::ElpNone) {
+        else if (explicitLayout != qglslang::ElpNone) {
             // figure out what to do with offset, which is accumulating
             int nextOffset;
             updateMemberOffset(type, glslangMember, offset, nextOffset, explicitLayout, memberQualifier.layoutMatrix);
@@ -4529,7 +4529,7 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
             offset = nextOffset;
         }
 
-        if (glslangMember.isMatrix() && explicitLayout != glslang::ElpNone)
+        if (glslangMember.isMatrix() && explicitLayout != qglslang::ElpNone)
             builder.addMemberDecoration(spvType, member, spv::DecorationMatrixStride,
                                         getMatrixStride(glslangMember, explicitLayout, memberQualifier.layoutMatrix));
 
@@ -4573,7 +4573,7 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
         // Add SPIR-V decorations for members (GL_EXT_spirv_intrinsics)
         //
         if (glslangMember.getQualifier().hasSprivDecorate()) {
-            const glslang::TSpirvDecorate& spirvDecorate = glslangMember.getQualifier().getSpirvDecorate();
+            const qglslang::TSpirvDecorate& spirvDecorate = glslangMember.getQualifier().getSpirvDecorate();
 
             // Add spirv_decorate
             for (auto& decorate : spirvDecorate.decorates) {
@@ -4612,10 +4612,10 @@ void TGlslangToSpvTraverser::decorateStructType(const glslang::TType& type,
 // This is not quite trivial, because of specialization constants.
 // Sometimes, a raw constant is turned into an Id, and sometimes
 // a specialization constant expression is.
-spv::Id TGlslangToSpvTraverser::makeArraySizeId(const glslang::TArraySizes& arraySizes, int dim)
+spv::Id TGlslangToSpvTraverser::makeArraySizeId(const qglslang::TArraySizes& arraySizes, int dim)
 {
     // First, see if this is sized with a node, meaning a specialization constant:
-    glslang::TIntermTyped* specNode = arraySizes.getDimNode(dim);
+    qglslang::TIntermTyped* specNode = arraySizes.getDimNode(dim);
     if (specNode != nullptr) {
         builder.clearAccessChain();
         SpecConstantOpModeGuard spec_constant_op_mode_setter(&builder);
@@ -4635,7 +4635,7 @@ spv::Id TGlslangToSpvTraverser::makeArraySizeId(const glslang::TArraySizes& arra
 //  - use the SPIR-V inferred type instead of another conversion of the glslang type
 //    (avoids unnecessary work and possible type punning for structures)
 //  - do conversion of concrete to abstract type
-spv::Id TGlslangToSpvTraverser::accessChainLoad(const glslang::TType& type)
+spv::Id TGlslangToSpvTraverser::accessChainLoad(const qglslang::TType& type)
 {
     spv::Id nominalTypeId = builder.accessChainGetInferredType();
 
@@ -4654,7 +4654,7 @@ spv::Id TGlslangToSpvTraverser::accessChainLoad(const glslang::TType& type)
         alignment);
 
     // Need to convert to abstract types when necessary
-    if (type.getBasicType() == glslang::EbtBool) {
+    if (type.getBasicType() == qglslang::EbtBool) {
         loadedId = convertLoadedBoolInUniformToUint(type, nominalTypeId, loadedId);
     }
 
@@ -4665,10 +4665,10 @@ spv::Id TGlslangToSpvTraverser::accessChainLoad(const glslang::TType& type)
 //  - do conversion of concrete to abstract type
 //
 // Implicitly uses the existing builder.accessChain as the storage target.
-void TGlslangToSpvTraverser::accessChainStore(const glslang::TType& type, spv::Id rvalue)
+void TGlslangToSpvTraverser::accessChainStore(const qglslang::TType& type, spv::Id rvalue)
 {
     // Need to convert to abstract types when necessary
-    if (type.getBasicType() == glslang::EbtBool) {
+    if (type.getBasicType() == qglslang::EbtBool) {
         spv::Id nominalTypeId = builder.accessChainGetInferredType();
 
         if (builder.isScalarType(nominalTypeId)) {
@@ -4719,7 +4719,7 @@ void TGlslangToSpvTraverser::accessChainStore(const glslang::TType& type, spv::I
 // simplifies to a simple OpStore.
 //
 // Implicitly uses the existing builder.accessChain as the storage target.
-void TGlslangToSpvTraverser::multiTypeStore(const glslang::TType& type, spv::Id rValue)
+void TGlslangToSpvTraverser::multiTypeStore(const qglslang::TType& type, spv::Id rValue)
 {
     // we only do the complex path here if it's an aggregate
     if (! type.isStruct() && ! type.isArray()) {
@@ -4741,7 +4741,7 @@ void TGlslangToSpvTraverser::multiTypeStore(const glslang::TType& type, spv::Id
     // by member copy, recursively.
 
     // SPIR-V 1.4 added an instruction to do help do this.
-    if (glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_4) {
+    if (glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_4) {
         // However, bool in uniform space is changed to int, so
         // OpCopyLogical does not work for that.
         // TODO: It would be more robust to do a full recursive verification of the types satisfying SPIR-V rules.
@@ -4756,7 +4756,7 @@ void TGlslangToSpvTraverser::multiTypeStore(const glslang::TType& type, spv::Id
 
     // If an array, copy element by element.
     if (type.isArray()) {
-        glslang::TType glslangElementType(type, 0);
+        qglslang::TType glslangElementType(type, 0);
         spv::Id elementRType = builder.getContainedTypeId(rType);
         for (int index = 0; index < type.getOuterArraySize(); ++index) {
             // get the source member
@@ -4775,9 +4775,9 @@ void TGlslangToSpvTraverser::multiTypeStore(const glslang::TType& type, spv::Id
         assert(type.isStruct());
 
         // loop over structure members
-        const glslang::TTypeList& members = *type.getStruct();
+        const qglslang::TTypeList& members = *type.getStruct();
         for (int m = 0; m < (int)members.size(); ++m) {
-            const glslang::TType& glslangMemberType = *members[m].type;
+            const qglslang::TType& glslangMemberType = *members[m].type;
 
             // get the source member
             spv::Id memberRType = builder.getContainedTypeId(rType, m);
@@ -4798,55 +4798,55 @@ void TGlslangToSpvTraverser::multiTypeStore(const glslang::TType& type, spv::Id
 // Decide whether or not this type should be
 // decorated with offsets and strides, and if so
 // whether std140 or std430 rules should be applied.
-glslang::TLayoutPacking TGlslangToSpvTraverser::getExplicitLayout(const glslang::TType& type) const
+qglslang::TLayoutPacking TGlslangToSpvTraverser::getExplicitLayout(const qglslang::TType& type) const
 {
     // has to be a block
-    if (type.getBasicType() != glslang::EbtBlock)
-        return glslang::ElpNone;
+    if (type.getBasicType() != qglslang::EbtBlock)
+        return qglslang::ElpNone;
 
     // has to be a uniform or buffer block or task in/out blocks
-    if (type.getQualifier().storage != glslang::EvqUniform &&
-        type.getQualifier().storage != glslang::EvqBuffer &&
-        type.getQualifier().storage != glslang::EvqShared &&
+    if (type.getQualifier().storage != qglslang::EvqUniform &&
+        type.getQualifier().storage != qglslang::EvqBuffer &&
+        type.getQualifier().storage != qglslang::EvqShared &&
         !type.getQualifier().isTaskMemory())
-        return glslang::ElpNone;
+        return qglslang::ElpNone;
 
     // return the layout to use
     switch (type.getQualifier().layoutPacking) {
-    case glslang::ElpStd140:
-    case glslang::ElpStd430:
-    case glslang::ElpScalar:
+    case qglslang::ElpStd140:
+    case qglslang::ElpStd430:
+    case qglslang::ElpScalar:
         return type.getQualifier().layoutPacking;
     default:
-        return glslang::ElpNone;
+        return qglslang::ElpNone;
     }
 }
 
 // Given an array type, returns the integer stride required for that array
-int TGlslangToSpvTraverser::getArrayStride(const glslang::TType& arrayType, glslang::TLayoutPacking explicitLayout,
-    glslang::TLayoutMatrix matrixLayout)
+int TGlslangToSpvTraverser::getArrayStride(const qglslang::TType& arrayType, qglslang::TLayoutPacking explicitLayout,
+    qglslang::TLayoutMatrix matrixLayout)
 {
     int size;
     int stride;
     glslangIntermediate->getMemberAlignment(arrayType, size, stride, explicitLayout,
-        matrixLayout == glslang::ElmRowMajor);
+        matrixLayout == qglslang::ElmRowMajor);
 
     return stride;
 }
 
 // Given a matrix type, or array (of array) of matrixes type, returns the integer stride required for that matrix
 // when used as a member of an interface block
-int TGlslangToSpvTraverser::getMatrixStride(const glslang::TType& matrixType, glslang::TLayoutPacking explicitLayout,
-    glslang::TLayoutMatrix matrixLayout)
+int TGlslangToSpvTraverser::getMatrixStride(const qglslang::TType& matrixType, qglslang::TLayoutPacking explicitLayout,
+    qglslang::TLayoutMatrix matrixLayout)
 {
-    glslang::TType elementType;
+    qglslang::TType elementType;
     elementType.shallowCopy(matrixType);
     elementType.clearArraySizes();
 
     int size;
     int stride;
     glslangIntermediate->getMemberAlignment(elementType, size, stride, explicitLayout,
-        matrixLayout == glslang::ElmRowMajor);
+        matrixLayout == qglslang::ElmRowMajor);
 
     return stride;
 }
@@ -4857,8 +4857,8 @@ int TGlslangToSpvTraverser::getMatrixStride(const glslang::TType& matrixType, gl
 // 'currentOffset' should be passed in already initialized, ready to modify, and reflecting
 // the migration of data from nextOffset -> currentOffset.  It should be -1 on the first call.
 // -1 means a non-forced member offset (no decoration needed).
-void TGlslangToSpvTraverser::updateMemberOffset(const glslang::TType& structType, const glslang::TType& memberType,
-    int& currentOffset, int& nextOffset, glslang::TLayoutPacking explicitLayout, glslang::TLayoutMatrix matrixLayout)
+void TGlslangToSpvTraverser::updateMemberOffset(const qglslang::TType& structType, const qglslang::TType& memberType,
+    int& currentOffset, int& nextOffset, qglslang::TLayoutPacking explicitLayout, qglslang::TLayoutMatrix matrixLayout)
 {
     // this will get a positive value when deemed necessary
     nextOffset = -1;
@@ -4872,7 +4872,7 @@ void TGlslangToSpvTraverser::updateMemberOffset(const glslang::TType& structType
     // once cross-compilation unit GLSL validation is done, as the original user
     // settings are needed in layoutOffset, and then the following will come into play.
 
-    if (explicitLayout == glslang::ElpNone) {
+    if (explicitLayout == qglslang::ElpNone) {
         if (! memberType.getQualifier().hasOffset())
             currentOffset = -1;
 
@@ -4889,7 +4889,7 @@ void TGlslangToSpvTraverser::updateMemberOffset(const glslang::TType& structType
     int memberSize;
     int dummyStride;
     int memberAlignment = glslangIntermediate->getMemberAlignment(memberType, memberSize, dummyStride, explicitLayout,
-        matrixLayout == glslang::ElmRowMajor);
+        matrixLayout == qglslang::ElmRowMajor);
 
     // Adjust alignment for HLSL rules
     // TODO: make this consistent in early phases of code:
@@ -4905,38 +4905,38 @@ void TGlslangToSpvTraverser::updateMemberOffset(const glslang::TType& structType
     }
 
     // Bump up to member alignment
-    glslang::RoundToPow2(currentOffset, memberAlignment);
+    qglslang::RoundToPow2(currentOffset, memberAlignment);
 
     // Bump up to vec4 if there is a bad straddle
-    if (explicitLayout != glslang::ElpScalar && glslangIntermediate->improperStraddle(memberType, memberSize,
+    if (explicitLayout != qglslang::ElpScalar && glslangIntermediate->improperStraddle(memberType, memberSize,
         currentOffset))
-        glslang::RoundToPow2(currentOffset, 16);
+        qglslang::RoundToPow2(currentOffset, 16);
 
     nextOffset = currentOffset + memberSize;
 }
 
-void TGlslangToSpvTraverser::declareUseOfStructMember(const glslang::TTypeList& members, int glslangMember)
+void TGlslangToSpvTraverser::declareUseOfStructMember(const qglslang::TTypeList& members, int glslangMember)
 {
-    const glslang::TBuiltInVariable glslangBuiltIn = members[glslangMember].type->getQualifier().builtIn;
+    const qglslang::TBuiltInVariable glslangBuiltIn = members[glslangMember].type->getQualifier().builtIn;
     switch (glslangBuiltIn)
     {
-    case glslang::EbvPointSize:
+    case qglslang::EbvPointSize:
 #ifndef GLSLANG_WEB
-    case glslang::EbvClipDistance:
-    case glslang::EbvCullDistance:
-    case glslang::EbvViewportMaskNV:
-    case glslang::EbvSecondaryPositionNV:
-    case glslang::EbvSecondaryViewportMaskNV:
-    case glslang::EbvPositionPerViewNV:
-    case glslang::EbvViewportMaskPerViewNV:
-    case glslang::EbvTaskCountNV:
-    case glslang::EbvPrimitiveCountNV:
-    case glslang::EbvPrimitiveIndicesNV:
-    case glslang::EbvClipDistancePerViewNV:
-    case glslang::EbvCullDistancePerViewNV:
-    case glslang::EbvLayerPerViewNV:
-    case glslang::EbvMeshViewCountNV:
-    case glslang::EbvMeshViewIndicesNV:
+    case qglslang::EbvClipDistance:
+    case qglslang::EbvCullDistance:
+    case qglslang::EbvViewportMaskNV:
+    case qglslang::EbvSecondaryPositionNV:
+    case qglslang::EbvSecondaryViewportMaskNV:
+    case qglslang::EbvPositionPerViewNV:
+    case qglslang::EbvViewportMaskPerViewNV:
+    case qglslang::EbvTaskCountNV:
+    case qglslang::EbvPrimitiveCountNV:
+    case qglslang::EbvPrimitiveIndicesNV:
+    case qglslang::EbvClipDistancePerViewNV:
+    case qglslang::EbvCullDistancePerViewNV:
+    case qglslang::EbvLayerPerViewNV:
+    case qglslang::EbvMeshViewCountNV:
+    case qglslang::EbvMeshViewIndicesNV:
 #endif
         // Generate the associated capability.  Delegate to TranslateBuiltInDecoration.
         // Alternately, we could just call this for any glslang built-in, since the
@@ -4949,7 +4949,7 @@ void TGlslangToSpvTraverser::declareUseOfStructMember(const glslang::TTypeList&
     }
 }
 
-bool TGlslangToSpvTraverser::isShaderEntryPoint(const glslang::TIntermAggregate* node)
+bool TGlslangToSpvTraverser::isShaderEntryPoint(const qglslang::TIntermAggregate* node)
 {
     return node->getName().compare(glslangIntermediate->getEntryPointMangledName().c_str()) == 0;
 }
@@ -4957,36 +4957,36 @@ bool TGlslangToSpvTraverser::isShaderEntryPoint(const glslang::TIntermAggregate*
 // Does parameter need a place to keep writes, separate from the original?
 // Assumes called after originalParam(), which filters out block/buffer/opaque-based
 // qualifiers such that we should have only in/out/inout/constreadonly here.
-bool TGlslangToSpvTraverser::writableParam(glslang::TStorageQualifier qualifier) const
+bool TGlslangToSpvTraverser::writableParam(qglslang::TStorageQualifier qualifier) const
 {
-    assert(qualifier == glslang::EvqIn ||
-           qualifier == glslang::EvqOut ||
-           qualifier == glslang::EvqInOut ||
-           qualifier == glslang::EvqUniform ||
-           qualifier == glslang::EvqConstReadOnly);
-    return qualifier != glslang::EvqConstReadOnly &&
-           qualifier != glslang::EvqUniform;
+    assert(qualifier == qglslang::EvqIn ||
+           qualifier == qglslang::EvqOut ||
+           qualifier == qglslang::EvqInOut ||
+           qualifier == qglslang::EvqUniform ||
+           qualifier == qglslang::EvqConstReadOnly);
+    return qualifier != qglslang::EvqConstReadOnly &&
+           qualifier != qglslang::EvqUniform;
 }
 
 // Is parameter pass-by-original?
-bool TGlslangToSpvTraverser::originalParam(glslang::TStorageQualifier qualifier, const glslang::TType& paramType,
+bool TGlslangToSpvTraverser::originalParam(qglslang::TStorageQualifier qualifier, const qglslang::TType& paramType,
                                            bool implicitThisParam)
 {
     if (implicitThisParam)                                                                     // implicit this
         return true;
-    if (glslangIntermediate->getSource() == glslang::EShSourceHlsl)
-        return paramType.getBasicType() == glslang::EbtBlock;
+    if (glslangIntermediate->getSource() == qglslang::EShSourceHlsl)
+        return paramType.getBasicType() == qglslang::EbtBlock;
     return paramType.containsOpaque() ||                                                       // sampler, etc.
 #ifndef GLSLANG_WEB
            paramType.getQualifier().isSpirvByReference() ||                                    // spirv_by_reference
 #endif
-           (paramType.getBasicType() == glslang::EbtBlock && qualifier == glslang::EvqBuffer); // SSBO
+           (paramType.getBasicType() == qglslang::EbtBlock && qualifier == qglslang::EvqBuffer); // SSBO
 }
 
 // Make all the functions, skeletally, without actually visiting their bodies.
-void TGlslangToSpvTraverser::makeFunctions(const glslang::TIntermSequence& glslFunctions)
+void TGlslangToSpvTraverser::makeFunctions(const qglslang::TIntermSequence& glslFunctions)
 {
-    const auto getParamDecorations = [&](std::vector<spv::Decoration>& decorations, const glslang::TType& type,
+    const auto getParamDecorations = [&](std::vector<spv::Decoration>& decorations, const qglslang::TType& type,
         bool useVulkanMemoryModel) {
         spv::Decoration paramPrecision = TranslatePrecisionDecoration(type);
         if (paramPrecision != spv::NoPrecision)
@@ -5008,8 +5008,8 @@ void TGlslangToSpvTraverser::makeFunctions(const glslang::TIntermSequence& glslF
     };
 
     for (int f = 0; f < (int)glslFunctions.size(); ++f) {
-        glslang::TIntermAggregate* glslFunction = glslFunctions[f]->getAsAggregate();
-        if (! glslFunction || glslFunction->getOp() != glslang::EOpFunction || isShaderEntryPoint(glslFunction))
+        qglslang::TIntermAggregate* glslFunction = glslFunctions[f]->getAsAggregate();
+        if (! glslFunction || glslFunction->getOp() != qglslang::EOpFunction || isShaderEntryPoint(glslFunction))
             continue;
 
         // We're on a user function.  Set up the basic interface for the function now,
@@ -5028,7 +5028,7 @@ void TGlslangToSpvTraverser::makeFunctions(const glslang::TIntermSequence& glslF
 
         std::vector<spv::Id> paramTypes;
         std::vector<std::vector<spv::Decoration>> paramDecorations; // list of decorations per parameter
-        glslang::TIntermSequence& parameters = glslFunction->getSequence()[0]->getAsAggregate()->getSequence();
+        qglslang::TIntermSequence& parameters = glslFunction->getSequence()[0]->getAsAggregate()->getSequence();
 
 #ifdef ENABLE_HLSL
         bool implicitThis = (int)parameters.size() > 0 && parameters[0]->getAsSymbolNode()->getName() ==
@@ -5039,7 +5039,7 @@ void TGlslangToSpvTraverser::makeFunctions(const glslang::TIntermSequence& glslF
 
         paramDecorations.resize(parameters.size());
         for (int p = 0; p < (int)parameters.size(); ++p) {
-            const glslang::TType& paramType = parameters[p]->getAsTyped()->getType();
+            const qglslang::TType& paramType = parameters[p]->getAsTyped()->getType();
             spv::Id typeId = convertGlslangToSpvType(paramType);
             if (originalParam(paramType.getQualifier().storage, paramType, implicitThis && p == 0))
                 typeId = builder.makePointer(TranslateStorageClass(paramType), typeId);
@@ -5068,7 +5068,7 @@ void TGlslangToSpvTraverser::makeFunctions(const glslang::TIntermSequence& glslF
             // give a name too
             builder.addName(function->getParamId(p), parameters[p]->getAsSymbolNode()->getName().c_str());
 
-            const glslang::TType& paramType = parameters[p]->getAsTyped()->getType();
+            const qglslang::TType& paramType = parameters[p]->getAsTyped()->getType();
             if (paramType.contains8BitInt())
                 builder.addCapability(spv::CapabilityInt8);
             if (paramType.contains16BitInt())
@@ -5080,13 +5080,13 @@ void TGlslangToSpvTraverser::makeFunctions(const glslang::TIntermSequence& glslF
 }
 
 // Process all the initializers, while skipping the functions and link objects
-void TGlslangToSpvTraverser::makeGlobalInitializers(const glslang::TIntermSequence& initializers)
+void TGlslangToSpvTraverser::makeGlobalInitializers(const qglslang::TIntermSequence& initializers)
 {
     builder.setBuildPoint(shaderEntry->getLastBlock());
     for (int i = 0; i < (int)initializers.size(); ++i) {
-        glslang::TIntermAggregate* initializer = initializers[i]->getAsAggregate();
-        if (initializer && initializer->getOp() != glslang::EOpFunction && initializer->getOp() !=
-            glslang::EOpLinkerObjects) {
+        qglslang::TIntermAggregate* initializer = initializers[i]->getAsAggregate();
+        if (initializer && initializer->getOp() != qglslang::EOpFunction && initializer->getOp() !=
+            qglslang::EOpLinkerObjects) {
 
             // We're on a top-level node that's not a function.  Treat as an initializer, whose
             // code goes into the beginning of the entry point.
@@ -5099,7 +5099,7 @@ void TGlslangToSpvTraverser::makeGlobalInitializers(const glslang::TIntermSequen
 // This is done here since it is possible that these linker objects are not be referenced in the AST
 void TGlslangToSpvTraverser::collectRayTracingLinkerObjects()
 {
-    glslang::TIntermAggregate* linkerObjects = glslangIntermediate->findLinkerObjects();
+    qglslang::TIntermAggregate* linkerObjects = glslangIntermediate->findLinkerObjects();
     for (auto& objSeq : linkerObjects->getSequence()) {
         auto objNode = objSeq->getAsSymbolNode();
         if (objNode != nullptr) {
@@ -5109,12 +5109,12 @@ void TGlslangToSpvTraverser::collectRayTracingLinkerObjects()
                 int set;
                 switch (st)
                 {
-                case glslang::EvqPayload:
-                case glslang::EvqPayloadIn:
+                case qglslang::EvqPayload:
+                case qglslang::EvqPayloadIn:
                     set = 0;
                     break;
-                case glslang::EvqCallableData:
-                case glslang::EvqCallableDataIn:
+                case qglslang::EvqCallableData:
+                case qglslang::EvqCallableDataIn:
                     set = 1;
                     break;
 
@@ -5128,16 +5128,16 @@ void TGlslangToSpvTraverser::collectRayTracingLinkerObjects()
     }
 }
 // Process all the functions, while skipping initializers.
-void TGlslangToSpvTraverser::visitFunctions(const glslang::TIntermSequence& glslFunctions)
+void TGlslangToSpvTraverser::visitFunctions(const qglslang::TIntermSequence& glslFunctions)
 {
     for (int f = 0; f < (int)glslFunctions.size(); ++f) {
-        glslang::TIntermAggregate* node = glslFunctions[f]->getAsAggregate();
-        if (node && (node->getOp() == glslang::EOpFunction || node->getOp() == glslang::EOpLinkerObjects))
+        qglslang::TIntermAggregate* node = glslFunctions[f]->getAsAggregate();
+        if (node && (node->getOp() == qglslang::EOpFunction || node->getOp() == qglslang::EOpLinkerObjects))
             node->traverse(this);
     }
 }
 
-void TGlslangToSpvTraverser::handleFunctionEntry(const glslang::TIntermAggregate* node)
+void TGlslangToSpvTraverser::handleFunctionEntry(const qglslang::TIntermAggregate* node)
 {
     // SPIR-V functions should already be in the functionMap from the prepass
     // that called makeFunctions().
@@ -5146,22 +5146,22 @@ void TGlslangToSpvTraverser::handleFunctionEntry(const glslang::TIntermAggregate
     builder.setBuildPoint(functionBlock);
 }
 
-void TGlslangToSpvTraverser::translateArguments(const glslang::TIntermAggregate& node, std::vector<spv::Id>& arguments,
+void TGlslangToSpvTraverser::translateArguments(const qglslang::TIntermAggregate& node, std::vector<spv::Id>& arguments,
     spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags)
 {
-    const glslang::TIntermSequence& glslangArguments = node.getSequence();
+    const qglslang::TIntermSequence& glslangArguments = node.getSequence();
 
-    glslang::TSampler sampler = {};
+    qglslang::TSampler sampler = {};
     bool cubeCompare = false;
 #ifndef GLSLANG_WEB
     bool f16ShadowCompare = false;
 #endif
     if (node.isTexture() || node.isImage()) {
         sampler = glslangArguments[0]->getAsTyped()->getType().getSampler();
-        cubeCompare = sampler.dim == glslang::EsdCube && sampler.arrayed && sampler.shadow;
+        cubeCompare = sampler.dim == qglslang::EsdCube && sampler.arrayed && sampler.shadow;
 #ifndef GLSLANG_WEB
         f16ShadowCompare = sampler.shadow &&
-            glslangArguments[1]->getAsTyped()->getType().getBasicType() == glslang::EbtFloat16;
+            glslangArguments[1]->getAsTyped()->getType().getBasicType() == qglslang::EbtFloat16;
 #endif
     }
 
@@ -5173,95 +5173,95 @@ void TGlslangToSpvTraverser::translateArguments(const glslang::TIntermAggregate&
         // Special case l-value operands
         bool lvalue = false;
         switch (node.getOp()) {
-        case glslang::EOpImageAtomicAdd:
-        case glslang::EOpImageAtomicMin:
-        case glslang::EOpImageAtomicMax:
-        case glslang::EOpImageAtomicAnd:
-        case glslang::EOpImageAtomicOr:
-        case glslang::EOpImageAtomicXor:
-        case glslang::EOpImageAtomicExchange:
-        case glslang::EOpImageAtomicCompSwap:
-        case glslang::EOpImageAtomicLoad:
-        case glslang::EOpImageAtomicStore:
+        case qglslang::EOpImageAtomicAdd:
+        case qglslang::EOpImageAtomicMin:
+        case qglslang::EOpImageAtomicMax:
+        case qglslang::EOpImageAtomicAnd:
+        case qglslang::EOpImageAtomicOr:
+        case qglslang::EOpImageAtomicXor:
+        case qglslang::EOpImageAtomicExchange:
+        case qglslang::EOpImageAtomicCompSwap:
+        case qglslang::EOpImageAtomicLoad:
+        case qglslang::EOpImageAtomicStore:
             if (i == 0)
                 lvalue = true;
             break;
-        case glslang::EOpSparseImageLoad:
+        case qglslang::EOpSparseImageLoad:
             if ((sampler.ms && i == 3) || (! sampler.ms && i == 2))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTexture:
+        case qglslang::EOpSparseTexture:
             if (((cubeCompare || f16ShadowCompare) && i == 3) || (! (cubeCompare || f16ShadowCompare) && i == 2))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureClamp:
+        case qglslang::EOpSparseTextureClamp:
             if (((cubeCompare || f16ShadowCompare) && i == 4) || (! (cubeCompare || f16ShadowCompare) && i == 3))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureLod:
-        case glslang::EOpSparseTextureOffset:
+        case qglslang::EOpSparseTextureLod:
+        case qglslang::EOpSparseTextureOffset:
             if  ((f16ShadowCompare && i == 4) || (! f16ShadowCompare && i == 3))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureFetch:
-            if ((sampler.dim != glslang::EsdRect && i == 3) || (sampler.dim == glslang::EsdRect && i == 2))
+        case qglslang::EOpSparseTextureFetch:
+            if ((sampler.dim != qglslang::EsdRect && i == 3) || (sampler.dim == qglslang::EsdRect && i == 2))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureFetchOffset:
-            if ((sampler.dim != glslang::EsdRect && i == 4) || (sampler.dim == glslang::EsdRect && i == 3))
+        case qglslang::EOpSparseTextureFetchOffset:
+            if ((sampler.dim != qglslang::EsdRect && i == 4) || (sampler.dim == qglslang::EsdRect && i == 3))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureLodOffset:
-        case glslang::EOpSparseTextureGrad:
-        case glslang::EOpSparseTextureOffsetClamp:
+        case qglslang::EOpSparseTextureLodOffset:
+        case qglslang::EOpSparseTextureGrad:
+        case qglslang::EOpSparseTextureOffsetClamp:
             if ((f16ShadowCompare && i == 5) || (! f16ShadowCompare && i == 4))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureGradOffset:
-        case glslang::EOpSparseTextureGradClamp:
+        case qglslang::EOpSparseTextureGradOffset:
+        case qglslang::EOpSparseTextureGradClamp:
             if ((f16ShadowCompare && i == 6) || (! f16ShadowCompare && i == 5))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureGradOffsetClamp:
+        case qglslang::EOpSparseTextureGradOffsetClamp:
             if ((f16ShadowCompare && i == 7) || (! f16ShadowCompare && i == 6))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureGather:
+        case qglslang::EOpSparseTextureGather:
             if ((sampler.shadow && i == 3) || (! sampler.shadow && i == 2))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureGatherOffset:
-        case glslang::EOpSparseTextureGatherOffsets:
+        case qglslang::EOpSparseTextureGatherOffset:
+        case qglslang::EOpSparseTextureGatherOffsets:
             if ((sampler.shadow && i == 4) || (! sampler.shadow && i == 3))
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureGatherLod:
+        case qglslang::EOpSparseTextureGatherLod:
             if (i == 3)
                 lvalue = true;
             break;
-        case glslang::EOpSparseTextureGatherLodOffset:
-        case glslang::EOpSparseTextureGatherLodOffsets:
+        case qglslang::EOpSparseTextureGatherLodOffset:
+        case qglslang::EOpSparseTextureGatherLodOffsets:
             if (i == 4)
                 lvalue = true;
             break;
-        case glslang::EOpSparseImageLoadLod:
+        case qglslang::EOpSparseImageLoadLod:
             if (i == 3)
                 lvalue = true;
             break;
-        case glslang::EOpImageSampleFootprintNV:
+        case qglslang::EOpImageSampleFootprintNV:
             if (i == 4)
                 lvalue = true;
             break;
-        case glslang::EOpImageSampleFootprintClampNV:
-        case glslang::EOpImageSampleFootprintLodNV:
+        case qglslang::EOpImageSampleFootprintClampNV:
+        case qglslang::EOpImageSampleFootprintLodNV:
             if (i == 5)
                 lvalue = true;
             break;
-        case glslang::EOpImageSampleFootprintGradNV:
+        case qglslang::EOpImageSampleFootprintGradNV:
             if (i == 6)
                 lvalue = true;
             break;
-        case glslang::EOpImageSampleFootprintGradClampNV:
+        case qglslang::EOpImageSampleFootprintGradClampNV:
             if (i == 7)
                 lvalue = true;
             break;
@@ -5281,14 +5281,14 @@ void TGlslangToSpvTraverser::translateArguments(const glslang::TIntermAggregate&
     }
 }
 
-void TGlslangToSpvTraverser::translateArguments(glslang::TIntermUnary& node, std::vector<spv::Id>& arguments)
+void TGlslangToSpvTraverser::translateArguments(qglslang::TIntermUnary& node, std::vector<spv::Id>& arguments)
 {
     builder.clearAccessChain();
     node.getOperand()->traverse(this);
     arguments.push_back(accessChainLoad(node.getOperand()->getType()));
 }
 
-spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermOperator* node)
+spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(qglslang::TIntermOperator* node)
 {
     if (! node->isImage() && ! node->isTexture())
         return spv::NoResult;
@@ -5297,23 +5297,23 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
 
     // Process a GLSL texturing op (will be SPV image)
 
-    const glslang::TType &imageType = node->getAsAggregate()
+    const qglslang::TType &imageType = node->getAsAggregate()
                                         ? node->getAsAggregate()->getSequence()[0]->getAsTyped()->getType()
                                         : node->getAsUnaryNode()->getOperand()->getAsTyped()->getType();
-    const glslang::TSampler sampler = imageType.getSampler();
+    const qglslang::TSampler sampler = imageType.getSampler();
 #ifdef GLSLANG_WEB
     const bool f16ShadowCompare = false;
 #else
     bool f16ShadowCompare = (sampler.shadow && node->getAsAggregate())
-            ? node->getAsAggregate()->getSequence()[1]->getAsTyped()->getType().getBasicType() == glslang::EbtFloat16
+            ? node->getAsAggregate()->getSequence()[1]->getAsTyped()->getType().getBasicType() == qglslang::EbtFloat16
             : false;
 #endif
 
     const auto signExtensionMask = [&]() {
         if (builder.getSpvVersion() >= spv::Spv_1_4) {
-            if (sampler.type == glslang::EbtUint)
+            if (sampler.type == qglslang::EbtUint)
                 return spv::ImageOperandsZeroExtendMask;
-            else if (sampler.type == glslang::EbtInt)
+            else if (sampler.type == qglslang::EbtInt)
                 return spv::ImageOperandsSignExtendMask;
         }
         return spv::ImageOperandsMaskNone;
@@ -5331,13 +5331,13 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
     spv::Builder::TextureParameters params = { };
     params.sampler = arguments[0];
 
-    glslang::TCrackedTextureOp cracked;
+    qglslang::TCrackedTextureOp cracked;
     node->crackTexture(sampler, cracked);
 
-    const bool isUnsignedResult = node->getType().getBasicType() == glslang::EbtUint;
+    const bool isUnsignedResult = node->getType().getBasicType() == qglslang::EbtUint;
 
     if (builder.isSampledImage(params.sampler) &&
-        ((cracked.query && node->getOp() != glslang::EOpTextureQueryLod) || cracked.fragMask || cracked.fetch)) {
+        ((cracked.query && node->getOp() != qglslang::EOpTextureQueryLod) || cracked.fragMask || cracked.fetch)) {
         params.sampler = builder.createUnaryOp(spv::OpImage, builder.getImageType(params.sampler), params.sampler);
         if (imageType.getQualifier().isNonUniform()) {
             builder.addDecoration(params.sampler, spv::DecorationNonUniformEXT);
@@ -5346,23 +5346,23 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
     // Check for queries
     if (cracked.query) {
         switch (node->getOp()) {
-        case glslang::EOpImageQuerySize:
-        case glslang::EOpTextureQuerySize:
+        case qglslang::EOpImageQuerySize:
+        case qglslang::EOpTextureQuerySize:
             if (arguments.size() > 1) {
                 params.lod = arguments[1];
                 return builder.createTextureQueryCall(spv::OpImageQuerySizeLod, params, isUnsignedResult);
             } else
                 return builder.createTextureQueryCall(spv::OpImageQuerySize, params, isUnsignedResult);
 #ifndef GLSLANG_WEB
-        case glslang::EOpImageQuerySamples:
-        case glslang::EOpTextureQuerySamples:
+        case qglslang::EOpImageQuerySamples:
+        case qglslang::EOpTextureQuerySamples:
             return builder.createTextureQueryCall(spv::OpImageQuerySamples, params, isUnsignedResult);
-        case glslang::EOpTextureQueryLod:
+        case qglslang::EOpTextureQueryLod:
             params.coords = arguments[1];
             return builder.createTextureQueryCall(spv::OpImageQueryLod, params, isUnsignedResult);
-        case glslang::EOpTextureQueryLevels:
+        case qglslang::EOpTextureQueryLevels:
             return builder.createTextureQueryCall(spv::OpImageQueryLevels, params, isUnsignedResult);
-        case glslang::EOpSparseTexelsResident:
+        case qglslang::EOpSparseTexelsResident:
             return builder.createUnaryOp(spv::OpImageSparseTexelsResident, builder.makeBoolType(), arguments[0]);
 #endif
         default:
@@ -5373,10 +5373,10 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
 
     int components = node->getType().getVectorSize();
 
-    if (node->getOp() == glslang::EOpImageLoad ||
-        node->getOp() == glslang::EOpImageLoadLod ||
-        node->getOp() == glslang::EOpTextureFetch ||
-        node->getOp() == glslang::EOpTextureFetchOffset) {
+    if (node->getOp() == qglslang::EOpImageLoad ||
+        node->getOp() == qglslang::EOpImageLoadLod ||
+        node->getOp() == qglslang::EOpTextureFetch ||
+        node->getOp() == qglslang::EOpTextureFetchOffset) {
         // These must produce 4 components, per SPIR-V spec.  We'll add a conversion constructor if needed.
         // This will only happen through the HLSL path for operator[], so we do not have to handle e.g.
         // the EOpTexture/Proj/Lod/etc family.  It would be harmless to do so, but would need more logic
@@ -5384,7 +5384,7 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
         components = 4;
     }
 
-    glslang::TType returnType(node->getType().getBasicType(), glslang::EvqTemporary, components);
+    qglslang::TType returnType(node->getType().getBasicType(), qglslang::EvqTemporary, components);
 
     auto resultType = [&returnType,this]{ return convertGlslangToSpvType(returnType); };
 
@@ -5426,7 +5426,7 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
 
         spv::IdImmediate coord = { true, *(opIt++) };
         operands.push_back(coord);
-        if (node->getOp() == glslang::EOpImageLoad || node->getOp() == glslang::EOpImageLoadLod) {
+        if (node->getOp() == qglslang::EOpImageLoad || node->getOp() == qglslang::EOpImageLoadLod) {
             spv::ImageOperandsMask mask = spv::ImageOperandsMaskNone;
             if (sampler.isMultiSample()) {
                 mask = mask | spv::ImageOperandsSampleMask;
@@ -5468,7 +5468,7 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
                 result[0] = builder.createConstructor(precision, result, convertGlslangToSpvType(node->getType()));
 
             return result[0];
-        } else if (node->getOp() == glslang::EOpImageStore || node->getOp() == glslang::EOpImageStoreLod) {
+        } else if (node->getOp() == qglslang::EOpImageStore || node->getOp() == qglslang::EOpImageStoreLod) {
 
             // Push the texel value before the operands
             if (sampler.isMultiSample() || cracked.lod) {
@@ -5513,8 +5513,8 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
             if (builder.getImageTypeFormat(builder.getImageType(operands.front().word)) == spv::ImageFormatUnknown)
                 builder.addCapability(spv::CapabilityStorageImageWriteWithoutFormat);
             return spv::NoResult;
-        } else if (node->getOp() == glslang::EOpSparseImageLoad ||
-                   node->getOp() == glslang::EOpSparseImageLoadLod) {
+        } else if (node->getOp() == qglslang::EOpSparseImageLoad ||
+                   node->getOp() == qglslang::EOpSparseImageLoadLod) {
             builder.addCapability(spv::CapabilitySparseResidency);
             if (builder.getImageTypeFormat(builder.getImageType(operands.front().word)) == spv::ImageFormatUnknown)
                 builder.addCapability(spv::CapabilityStorageImageReadWithoutFormat);
@@ -5573,7 +5573,7 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
             spv::Id resultTypeId;
             // imageAtomicStore has a void return type so base the pointer type on
             // the type of the value operand.
-            if (node->getOp() == glslang::EOpImageAtomicStore) {
+            if (node->getOp() == qglslang::EOpImageAtomicStore) {
                 resultTypeId = builder.makePointer(spv::StorageClassImage, builder.getTypeId(*opIt));
             } else {
                 resultTypeId = builder.makePointer(spv::StorageClassImage, resultType());
@@ -5618,9 +5618,9 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
             operands.push_back(*opIt);
 
         spv::Op fragMaskOp = spv::OpNop;
-        if (node->getOp() == glslang::EOpFragmentMaskFetch)
+        if (node->getOp() == qglslang::EOpFragmentMaskFetch)
             fragMaskOp = spv::OpFragmentMaskFetchAMD;
-        else if (node->getOp() == glslang::EOpFragmentFetch)
+        else if (node->getOp() == qglslang::EOpFragmentFetch)
             fragMaskOp = spv::OpFragmentFetchAMD;
 
         builder.addExtension(spv::E_SPV_AMD_shader_fragment_mask);
@@ -5632,7 +5632,7 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
     // Check for texture functions other than queries
     bool sparse = node->isSparseTexture();
     bool imageFootprint = node->isImageFootprint();
-    bool cubeCompare = sampler.dim == glslang::EsdCube && sampler.isArrayed() && sampler.isShadow();
+    bool cubeCompare = sampler.dim == qglslang::EsdCube && sampler.isArrayed() && sampler.isShadow();
 
     // check for bias argument
     bool bias = false;
@@ -5665,7 +5665,7 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
     if (cracked.gather) {
         const auto& sourceExtensions = glslangIntermediate->getRequestedExtensions();
         if (bias || cracked.lod ||
-            sourceExtensions.find(glslang::E_GL_AMD_texture_gather_bias_lod) != sourceExtensions.end()) {
+            sourceExtensions.find(qglslang::E_GL_AMD_texture_gather_bias_lod) != sourceExtensions.end()) {
             builder.addExtension(spv::E_SPV_AMD_texture_gather_bias_lod);
             builder.addCapability(spv::CapabilityImageGatherBiasLodAMD);
         }
@@ -5835,9 +5835,9 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
         int projSourceComp = builder.getNumComponents(params.coords) - 1;
         int projTargetComp;
         switch (sampler.dim) {
-        case glslang::Esd1D:   projTargetComp = 1;              break;
-        case glslang::Esd2D:   projTargetComp = 2;              break;
-        case glslang::EsdRect: projTargetComp = 2;              break;
+        case qglslang::Esd1D:   projTargetComp = 1;              break;
+        case qglslang::Esd2D:   projTargetComp = 2;              break;
+        case qglslang::EsdRect: projTargetComp = 2;              break;
         default:               projTargetComp = projSourceComp; break;
         }
         // copy the projective coordinate if we have to
@@ -5872,15 +5872,15 @@ spv::Id TGlslangToSpvTraverser::createImageTextureFunctionCall(glslang::TIntermO
     return result[0];
 }
 
-spv::Id TGlslangToSpvTraverser::handleUserFunctionCall(const glslang::TIntermAggregate* node)
+spv::Id TGlslangToSpvTraverser::handleUserFunctionCall(const qglslang::TIntermAggregate* node)
 {
     // Grab the function's pointer from the previously created function
     spv::Function* function = functionMap[node->getName().c_str()];
     if (! function)
         return 0;
 
-    const glslang::TIntermSequence& glslangArgs = node->getSequence();
-    const glslang::TQualifierList& qualifiers = node->getQualifierList();
+    const qglslang::TIntermSequence& glslangArgs = node->getSequence();
+    const qglslang::TQualifierList& qualifiers = node->getQualifierList();
 
     //  See comments in makeFunctions() for details about the semantics for parameter passing.
     //
@@ -5893,7 +5893,7 @@ spv::Id TGlslangToSpvTraverser::handleUserFunctionCall(const glslang::TIntermAgg
     // 1. Evaluate the arguments and their types
     std::vector<spv::Builder::AccessChain> lValues;
     std::vector<spv::Id> rValues;
-    std::vector<const glslang::TType*> argTypes;
+    std::vector<const qglslang::TType*> argTypes;
     for (int a = 0; a < (int)glslangArgs.size(); ++a) {
         argTypes.push_back(&glslangArgs[a]->getAsTyped()->getType());
         // build l-value
@@ -5927,7 +5927,7 @@ spv::Id TGlslangToSpvTraverser::handleUserFunctionCall(const glslang::TIntermAgg
             // need space to hold the copy
             arg = builder.createVariable(function->getParamPrecision(a), spv::StorageClassFunction,
                 builder.getContainedTypeId(function->getParamType(a)), "param");
-            if (qualifiers[a] == glslang::EvqIn || qualifiers[a] == glslang::EvqInOut) {
+            if (qualifiers[a] == qglslang::EvqIn || qualifiers[a] == qglslang::EvqInOut) {
                 // need to copy the input into output space
                 builder.setAccessChain(lValues[lValueCount]);
                 spv::Id copy = accessChainLoad(*argTypes[a]);
@@ -5964,7 +5964,7 @@ spv::Id TGlslangToSpvTraverser::handleUserFunctionCall(const glslang::TIntermAgg
         if (originalParam(qualifiers[a], *argTypes[a], function->hasImplicitThis() && a == 0))
             ++lValueCount;
         else if (writableParam(qualifiers[a])) {
-            if (qualifiers[a] == glslang::EvqOut || qualifiers[a] == glslang::EvqInOut) {
+            if (qualifiers[a] == qglslang::EvqOut || qualifiers[a] == qglslang::EvqInOut) {
                 spv::Id copy = builder.createLoad(spvArgs[a], spv::NoPrecision);
                 builder.addDecoration(copy, TranslateNonUniformDecoration(argTypes[a]->getQualifier()));
                 builder.setAccessChain(lValues[lValueCount]);
@@ -5978,42 +5978,42 @@ spv::Id TGlslangToSpvTraverser::handleUserFunctionCall(const glslang::TIntermAgg
 }
 
 // Translate AST operation to SPV operation, already having SPV-based operands/types.
-spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpDecorations& decorations,
+spv::Id TGlslangToSpvTraverser::createBinaryOperation(qglslang::TOperator op, OpDecorations& decorations,
                                                       spv::Id typeId, spv::Id left, spv::Id right,
-                                                      glslang::TBasicType typeProxy, bool reduceComparison)
+                                                      qglslang::TBasicType typeProxy, bool reduceComparison)
 {
     bool isUnsigned = isTypeUnsignedInt(typeProxy);
     bool isFloat = isTypeFloat(typeProxy);
-    bool isBool = typeProxy == glslang::EbtBool;
+    bool isBool = typeProxy == qglslang::EbtBool;
 
     spv::Op binOp = spv::OpNop;
     bool needMatchingVectors = true;  // for non-matrix ops, would a scalar need to smear to match a vector?
     bool comparison = false;
 
     switch (op) {
-    case glslang::EOpAdd:
-    case glslang::EOpAddAssign:
+    case qglslang::EOpAdd:
+    case qglslang::EOpAddAssign:
         if (isFloat)
             binOp = spv::OpFAdd;
         else
             binOp = spv::OpIAdd;
         break;
-    case glslang::EOpSub:
-    case glslang::EOpSubAssign:
+    case qglslang::EOpSub:
+    case qglslang::EOpSubAssign:
         if (isFloat)
             binOp = spv::OpFSub;
         else
             binOp = spv::OpISub;
         break;
-    case glslang::EOpMul:
-    case glslang::EOpMulAssign:
+    case qglslang::EOpMul:
+    case qglslang::EOpMulAssign:
         if (isFloat)
             binOp = spv::OpFMul;
         else
             binOp = spv::OpIMul;
         break;
-    case glslang::EOpVectorTimesScalar:
-    case glslang::EOpVectorTimesScalarAssign:
+    case qglslang::EOpVectorTimesScalar:
+    case qglslang::EOpVectorTimesScalarAssign:
         if (isFloat && (builder.isVector(left) || builder.isVector(right))) {
             if (builder.isVector(right))
                 std::swap(left, right);
@@ -6025,28 +6025,28 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
           else
             binOp = spv::OpIMul;
         break;
-    case glslang::EOpVectorTimesMatrix:
-    case glslang::EOpVectorTimesMatrixAssign:
+    case qglslang::EOpVectorTimesMatrix:
+    case qglslang::EOpVectorTimesMatrixAssign:
         binOp = spv::OpVectorTimesMatrix;
         break;
-    case glslang::EOpMatrixTimesVector:
+    case qglslang::EOpMatrixTimesVector:
         binOp = spv::OpMatrixTimesVector;
         break;
-    case glslang::EOpMatrixTimesScalar:
-    case glslang::EOpMatrixTimesScalarAssign:
+    case qglslang::EOpMatrixTimesScalar:
+    case qglslang::EOpMatrixTimesScalarAssign:
         binOp = spv::OpMatrixTimesScalar;
         break;
-    case glslang::EOpMatrixTimesMatrix:
-    case glslang::EOpMatrixTimesMatrixAssign:
+    case qglslang::EOpMatrixTimesMatrix:
+    case qglslang::EOpMatrixTimesMatrixAssign:
         binOp = spv::OpMatrixTimesMatrix;
         break;
-    case glslang::EOpOuterProduct:
+    case qglslang::EOpOuterProduct:
         binOp = spv::OpOuterProduct;
         needMatchingVectors = false;
         break;
 
-    case glslang::EOpDiv:
-    case glslang::EOpDivAssign:
+    case qglslang::EOpDiv:
+    case qglslang::EOpDivAssign:
         if (isFloat)
             binOp = spv::OpFDiv;
         else if (isUnsigned)
@@ -6054,8 +6054,8 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpSDiv;
         break;
-    case glslang::EOpMod:
-    case glslang::EOpModAssign:
+    case qglslang::EOpMod:
+    case qglslang::EOpModAssign:
         if (isFloat)
             binOp = spv::OpFMod;
         else if (isUnsigned)
@@ -6063,74 +6063,74 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpSMod;
         break;
-    case glslang::EOpRightShift:
-    case glslang::EOpRightShiftAssign:
+    case qglslang::EOpRightShift:
+    case qglslang::EOpRightShiftAssign:
         if (isUnsigned)
             binOp = spv::OpShiftRightLogical;
         else
             binOp = spv::OpShiftRightArithmetic;
         break;
-    case glslang::EOpLeftShift:
-    case glslang::EOpLeftShiftAssign:
+    case qglslang::EOpLeftShift:
+    case qglslang::EOpLeftShiftAssign:
         binOp = spv::OpShiftLeftLogical;
         break;
-    case glslang::EOpAnd:
-    case glslang::EOpAndAssign:
+    case qglslang::EOpAnd:
+    case qglslang::EOpAndAssign:
         binOp = spv::OpBitwiseAnd;
         break;
-    case glslang::EOpLogicalAnd:
+    case qglslang::EOpLogicalAnd:
         needMatchingVectors = false;
         binOp = spv::OpLogicalAnd;
         break;
-    case glslang::EOpInclusiveOr:
-    case glslang::EOpInclusiveOrAssign:
+    case qglslang::EOpInclusiveOr:
+    case qglslang::EOpInclusiveOrAssign:
         binOp = spv::OpBitwiseOr;
         break;
-    case glslang::EOpLogicalOr:
+    case qglslang::EOpLogicalOr:
         needMatchingVectors = false;
         binOp = spv::OpLogicalOr;
         break;
-    case glslang::EOpExclusiveOr:
-    case glslang::EOpExclusiveOrAssign:
+    case qglslang::EOpExclusiveOr:
+    case qglslang::EOpExclusiveOrAssign:
         binOp = spv::OpBitwiseXor;
         break;
-    case glslang::EOpLogicalXor:
+    case qglslang::EOpLogicalXor:
         needMatchingVectors = false;
         binOp = spv::OpLogicalNotEqual;
         break;
 
-    case glslang::EOpAbsDifference:
+    case qglslang::EOpAbsDifference:
         binOp = isUnsigned ? spv::OpAbsUSubINTEL : spv::OpAbsISubINTEL;
         break;
 
-    case glslang::EOpAddSaturate:
+    case qglslang::EOpAddSaturate:
         binOp = isUnsigned ? spv::OpUAddSatINTEL : spv::OpIAddSatINTEL;
         break;
 
-    case glslang::EOpSubSaturate:
+    case qglslang::EOpSubSaturate:
         binOp = isUnsigned ? spv::OpUSubSatINTEL : spv::OpISubSatINTEL;
         break;
 
-    case glslang::EOpAverage:
+    case qglslang::EOpAverage:
         binOp = isUnsigned ? spv::OpUAverageINTEL : spv::OpIAverageINTEL;
         break;
 
-    case glslang::EOpAverageRounded:
+    case qglslang::EOpAverageRounded:
         binOp = isUnsigned ? spv::OpUAverageRoundedINTEL : spv::OpIAverageRoundedINTEL;
         break;
 
-    case glslang::EOpMul32x16:
+    case qglslang::EOpMul32x16:
         binOp = isUnsigned ? spv::OpUMul32x16INTEL : spv::OpIMul32x16INTEL;
         break;
 
-    case glslang::EOpLessThan:
-    case glslang::EOpGreaterThan:
-    case glslang::EOpLessThanEqual:
-    case glslang::EOpGreaterThanEqual:
-    case glslang::EOpEqual:
-    case glslang::EOpNotEqual:
-    case glslang::EOpVectorEqual:
-    case glslang::EOpVectorNotEqual:
+    case qglslang::EOpLessThan:
+    case qglslang::EOpGreaterThan:
+    case qglslang::EOpLessThanEqual:
+    case qglslang::EOpGreaterThanEqual:
+    case qglslang::EOpEqual:
+    case qglslang::EOpNotEqual:
+    case qglslang::EOpVectorEqual:
+    case qglslang::EOpVectorNotEqual:
         comparison = true;
         break;
     default:
@@ -6159,15 +6159,15 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
 
     // Handle comparison instructions
 
-    if (reduceComparison && (op == glslang::EOpEqual || op == glslang::EOpNotEqual)
+    if (reduceComparison && (op == qglslang::EOpEqual || op == qglslang::EOpNotEqual)
                          && (builder.isVector(left) || builder.isMatrix(left) || builder.isAggregate(left))) {
-        spv::Id result = builder.createCompositeCompare(decorations.precision, left, right, op == glslang::EOpEqual);
+        spv::Id result = builder.createCompositeCompare(decorations.precision, left, right, op == qglslang::EOpEqual);
         decorations.addNonUniform(builder, result);
         return result;
     }
 
     switch (op) {
-    case glslang::EOpLessThan:
+    case qglslang::EOpLessThan:
         if (isFloat)
             binOp = spv::OpFOrdLessThan;
         else if (isUnsigned)
@@ -6175,7 +6175,7 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpSLessThan;
         break;
-    case glslang::EOpGreaterThan:
+    case qglslang::EOpGreaterThan:
         if (isFloat)
             binOp = spv::OpFOrdGreaterThan;
         else if (isUnsigned)
@@ -6183,7 +6183,7 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpSGreaterThan;
         break;
-    case glslang::EOpLessThanEqual:
+    case qglslang::EOpLessThanEqual:
         if (isFloat)
             binOp = spv::OpFOrdLessThanEqual;
         else if (isUnsigned)
@@ -6191,7 +6191,7 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpSLessThanEqual;
         break;
-    case glslang::EOpGreaterThanEqual:
+    case qglslang::EOpGreaterThanEqual:
         if (isFloat)
             binOp = spv::OpFOrdGreaterThanEqual;
         else if (isUnsigned)
@@ -6199,8 +6199,8 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpSGreaterThanEqual;
         break;
-    case glslang::EOpEqual:
-    case glslang::EOpVectorEqual:
+    case qglslang::EOpEqual:
+    case qglslang::EOpVectorEqual:
         if (isFloat)
             binOp = spv::OpFOrdEqual;
         else if (isBool)
@@ -6208,8 +6208,8 @@ spv::Id TGlslangToSpvTraverser::createBinaryOperation(glslang::TOperator op, OpD
         else
             binOp = spv::OpIEqual;
         break;
-    case glslang::EOpNotEqual:
-    case glslang::EOpVectorNotEqual:
+    case qglslang::EOpNotEqual:
+    case qglslang::EOpVectorNotEqual:
         if (isFloat)
             binOp = spv::OpFUnordNotEqual;
         else if (isBool)
@@ -6344,8 +6344,8 @@ spv::Id TGlslangToSpvTraverser::createBinaryMatrixOperation(spv::Op op, OpDecora
     }
 }
 
-spv::Id TGlslangToSpvTraverser::createUnaryOperation(glslang::TOperator op, OpDecorations& decorations, spv::Id typeId,
-    spv::Id operand, glslang::TBasicType typeProxy, const spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags)
+spv::Id TGlslangToSpvTraverser::createUnaryOperation(qglslang::TOperator op, OpDecorations& decorations, spv::Id typeId,
+    spv::Id operand, qglslang::TBasicType typeProxy, const spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags)
 {
     spv::Op unaryOp = spv::OpNop;
     int extBuiltins = -1;
@@ -6354,7 +6354,7 @@ spv::Id TGlslangToSpvTraverser::createUnaryOperation(glslang::TOperator op, OpDe
     bool isFloat = isTypeFloat(typeProxy);
 
     switch (op) {
-    case glslang::EOpNegative:
+    case qglslang::EOpNegative:
         if (isFloat) {
             unaryOp = spv::OpFNegate;
             if (builder.isMatrixType(typeId))
@@ -6363,224 +6363,224 @@ spv::Id TGlslangToSpvTraverser::createUnaryOperation(glslang::TOperator op, OpDe
             unaryOp = spv::OpSNegate;
         break;
 
-    case glslang::EOpLogicalNot:
-    case glslang::EOpVectorLogicalNot:
+    case qglslang::EOpLogicalNot:
+    case qglslang::EOpVectorLogicalNot:
         unaryOp = spv::OpLogicalNot;
         break;
-    case glslang::EOpBitwiseNot:
+    case qglslang::EOpBitwiseNot:
         unaryOp = spv::OpNot;
         break;
 
-    case glslang::EOpDeterminant:
+    case qglslang::EOpDeterminant:
         libCall = spv::GLSLstd450Determinant;
         break;
-    case glslang::EOpMatrixInverse:
+    case qglslang::EOpMatrixInverse:
         libCall = spv::GLSLstd450MatrixInverse;
         break;
-    case glslang::EOpTranspose:
+    case qglslang::EOpTranspose:
         unaryOp = spv::OpTranspose;
         break;
 
-    case glslang::EOpRadians:
+    case qglslang::EOpRadians:
         libCall = spv::GLSLstd450Radians;
         break;
-    case glslang::EOpDegrees:
+    case qglslang::EOpDegrees:
         libCall = spv::GLSLstd450Degrees;
         break;
-    case glslang::EOpSin:
+    case qglslang::EOpSin:
         libCall = spv::GLSLstd450Sin;
         break;
-    case glslang::EOpCos:
+    case qglslang::EOpCos:
         libCall = spv::GLSLstd450Cos;
         break;
-    case glslang::EOpTan:
+    case qglslang::EOpTan:
         libCall = spv::GLSLstd450Tan;
         break;
-    case glslang::EOpAcos:
+    case qglslang::EOpAcos:
         libCall = spv::GLSLstd450Acos;
         break;
-    case glslang::EOpAsin:
+    case qglslang::EOpAsin:
         libCall = spv::GLSLstd450Asin;
         break;
-    case glslang::EOpAtan:
+    case qglslang::EOpAtan:
         libCall = spv::GLSLstd450Atan;
         break;
 
-    case glslang::EOpAcosh:
+    case qglslang::EOpAcosh:
         libCall = spv::GLSLstd450Acosh;
         break;
-    case glslang::EOpAsinh:
+    case qglslang::EOpAsinh:
         libCall = spv::GLSLstd450Asinh;
         break;
-    case glslang::EOpAtanh:
+    case qglslang::EOpAtanh:
         libCall = spv::GLSLstd450Atanh;
         break;
-    case glslang::EOpTanh:
+    case qglslang::EOpTanh:
         libCall = spv::GLSLstd450Tanh;
         break;
-    case glslang::EOpCosh:
+    case qglslang::EOpCosh:
         libCall = spv::GLSLstd450Cosh;
         break;
-    case glslang::EOpSinh:
+    case qglslang::EOpSinh:
         libCall = spv::GLSLstd450Sinh;
         break;
 
-    case glslang::EOpLength:
+    case qglslang::EOpLength:
         libCall = spv::GLSLstd450Length;
         break;
-    case glslang::EOpNormalize:
+    case qglslang::EOpNormalize:
         libCall = spv::GLSLstd450Normalize;
         break;
 
-    case glslang::EOpExp:
+    case qglslang::EOpExp:
         libCall = spv::GLSLstd450Exp;
         break;
-    case glslang::EOpLog:
+    case qglslang::EOpLog:
         libCall = spv::GLSLstd450Log;
         break;
-    case glslang::EOpExp2:
+    case qglslang::EOpExp2:
         libCall = spv::GLSLstd450Exp2;
         break;
-    case glslang::EOpLog2:
+    case qglslang::EOpLog2:
         libCall = spv::GLSLstd450Log2;
         break;
-    case glslang::EOpSqrt:
+    case qglslang::EOpSqrt:
         libCall = spv::GLSLstd450Sqrt;
         break;
-    case glslang::EOpInverseSqrt:
+    case qglslang::EOpInverseSqrt:
         libCall = spv::GLSLstd450InverseSqrt;
         break;
 
-    case glslang::EOpFloor:
+    case qglslang::EOpFloor:
         libCall = spv::GLSLstd450Floor;
         break;
-    case glslang::EOpTrunc:
+    case qglslang::EOpTrunc:
         libCall = spv::GLSLstd450Trunc;
         break;
-    case glslang::EOpRound:
+    case qglslang::EOpRound:
         libCall = spv::GLSLstd450Round;
         break;
-    case glslang::EOpRoundEven:
+    case qglslang::EOpRoundEven:
         libCall = spv::GLSLstd450RoundEven;
         break;
-    case glslang::EOpCeil:
+    case qglslang::EOpCeil:
         libCall = spv::GLSLstd450Ceil;
         break;
-    case glslang::EOpFract:
+    case qglslang::EOpFract:
         libCall = spv::GLSLstd450Fract;
         break;
 
-    case glslang::EOpIsNan:
+    case qglslang::EOpIsNan:
         unaryOp = spv::OpIsNan;
         break;
-    case glslang::EOpIsInf:
+    case qglslang::EOpIsInf:
         unaryOp = spv::OpIsInf;
         break;
-    case glslang::EOpIsFinite:
+    case qglslang::EOpIsFinite:
         unaryOp = spv::OpIsFinite;
         break;
 
-    case glslang::EOpFloatBitsToInt:
-    case glslang::EOpFloatBitsToUint:
-    case glslang::EOpIntBitsToFloat:
-    case glslang::EOpUintBitsToFloat:
-    case glslang::EOpDoubleBitsToInt64:
-    case glslang::EOpDoubleBitsToUint64:
-    case glslang::EOpInt64BitsToDouble:
-    case glslang::EOpUint64BitsToDouble:
-    case glslang::EOpFloat16BitsToInt16:
-    case glslang::EOpFloat16BitsToUint16:
-    case glslang::EOpInt16BitsToFloat16:
-    case glslang::EOpUint16BitsToFloat16:
+    case qglslang::EOpFloatBitsToInt:
+    case qglslang::EOpFloatBitsToUint:
+    case qglslang::EOpIntBitsToFloat:
+    case qglslang::EOpUintBitsToFloat:
+    case qglslang::EOpDoubleBitsToInt64:
+    case qglslang::EOpDoubleBitsToUint64:
+    case qglslang::EOpInt64BitsToDouble:
+    case qglslang::EOpUint64BitsToDouble:
+    case qglslang::EOpFloat16BitsToInt16:
+    case qglslang::EOpFloat16BitsToUint16:
+    case qglslang::EOpInt16BitsToFloat16:
+    case qglslang::EOpUint16BitsToFloat16:
         unaryOp = spv::OpBitcast;
         break;
 
-    case glslang::EOpPackSnorm2x16:
+    case qglslang::EOpPackSnorm2x16:
         libCall = spv::GLSLstd450PackSnorm2x16;
         break;
-    case glslang::EOpUnpackSnorm2x16:
+    case qglslang::EOpUnpackSnorm2x16:
         libCall = spv::GLSLstd450UnpackSnorm2x16;
         break;
-    case glslang::EOpPackUnorm2x16:
+    case qglslang::EOpPackUnorm2x16:
         libCall = spv::GLSLstd450PackUnorm2x16;
         break;
-    case glslang::EOpUnpackUnorm2x16:
+    case qglslang::EOpUnpackUnorm2x16:
         libCall = spv::GLSLstd450UnpackUnorm2x16;
         break;
-    case glslang::EOpPackHalf2x16:
+    case qglslang::EOpPackHalf2x16:
         libCall = spv::GLSLstd450PackHalf2x16;
         break;
-    case glslang::EOpUnpackHalf2x16:
+    case qglslang::EOpUnpackHalf2x16:
         libCall = spv::GLSLstd450UnpackHalf2x16;
         break;
 #ifndef GLSLANG_WEB
-    case glslang::EOpPackSnorm4x8:
+    case qglslang::EOpPackSnorm4x8:
         libCall = spv::GLSLstd450PackSnorm4x8;
         break;
-    case glslang::EOpUnpackSnorm4x8:
+    case qglslang::EOpUnpackSnorm4x8:
         libCall = spv::GLSLstd450UnpackSnorm4x8;
         break;
-    case glslang::EOpPackUnorm4x8:
+    case qglslang::EOpPackUnorm4x8:
         libCall = spv::GLSLstd450PackUnorm4x8;
         break;
-    case glslang::EOpUnpackUnorm4x8:
+    case qglslang::EOpUnpackUnorm4x8:
         libCall = spv::GLSLstd450UnpackUnorm4x8;
         break;
-    case glslang::EOpPackDouble2x32:
+    case qglslang::EOpPackDouble2x32:
         libCall = spv::GLSLstd450PackDouble2x32;
         break;
-    case glslang::EOpUnpackDouble2x32:
+    case qglslang::EOpUnpackDouble2x32:
         libCall = spv::GLSLstd450UnpackDouble2x32;
         break;
 #endif
 
-    case glslang::EOpPackInt2x32:
-    case glslang::EOpUnpackInt2x32:
-    case glslang::EOpPackUint2x32:
-    case glslang::EOpUnpackUint2x32:
-    case glslang::EOpPack16:
-    case glslang::EOpPack32:
-    case glslang::EOpPack64:
-    case glslang::EOpUnpack32:
-    case glslang::EOpUnpack16:
-    case glslang::EOpUnpack8:
-    case glslang::EOpPackInt2x16:
-    case glslang::EOpUnpackInt2x16:
-    case glslang::EOpPackUint2x16:
-    case glslang::EOpUnpackUint2x16:
-    case glslang::EOpPackInt4x16:
-    case glslang::EOpUnpackInt4x16:
-    case glslang::EOpPackUint4x16:
-    case glslang::EOpUnpackUint4x16:
-    case glslang::EOpPackFloat2x16:
-    case glslang::EOpUnpackFloat2x16:
+    case qglslang::EOpPackInt2x32:
+    case qglslang::EOpUnpackInt2x32:
+    case qglslang::EOpPackUint2x32:
+    case qglslang::EOpUnpackUint2x32:
+    case qglslang::EOpPack16:
+    case qglslang::EOpPack32:
+    case qglslang::EOpPack64:
+    case qglslang::EOpUnpack32:
+    case qglslang::EOpUnpack16:
+    case qglslang::EOpUnpack8:
+    case qglslang::EOpPackInt2x16:
+    case qglslang::EOpUnpackInt2x16:
+    case qglslang::EOpPackUint2x16:
+    case qglslang::EOpUnpackUint2x16:
+    case qglslang::EOpPackInt4x16:
+    case qglslang::EOpUnpackInt4x16:
+    case qglslang::EOpPackUint4x16:
+    case qglslang::EOpUnpackUint4x16:
+    case qglslang::EOpPackFloat2x16:
+    case qglslang::EOpUnpackFloat2x16:
         unaryOp = spv::OpBitcast;
         break;
 
-    case glslang::EOpDPdx:
+    case qglslang::EOpDPdx:
         unaryOp = spv::OpDPdx;
         break;
-    case glslang::EOpDPdy:
+    case qglslang::EOpDPdy:
         unaryOp = spv::OpDPdy;
         break;
-    case glslang::EOpFwidth:
+    case qglslang::EOpFwidth:
         unaryOp = spv::OpFwidth;
         break;
 
-    case glslang::EOpAny:
+    case qglslang::EOpAny:
         unaryOp = spv::OpAny;
         break;
-    case glslang::EOpAll:
+    case qglslang::EOpAll:
         unaryOp = spv::OpAll;
         break;
 
-    case glslang::EOpAbs:
+    case qglslang::EOpAbs:
         if (isFloat)
             libCall = spv::GLSLstd450FAbs;
         else
             libCall = spv::GLSLstd450SAbs;
         break;
-    case glslang::EOpSign:
+    case qglslang::EOpSign:
         if (isFloat)
             libCall = spv::GLSLstd450FSign;
         else
@@ -6588,50 +6588,50 @@ spv::Id TGlslangToSpvTraverser::createUnaryOperation(glslang::TOperator op, OpDe
         break;
 
 #ifndef GLSLANG_WEB
-    case glslang::EOpDPdxFine:
+    case qglslang::EOpDPdxFine:
         unaryOp = spv::OpDPdxFine;
         break;
-    case glslang::EOpDPdyFine:
+    case qglslang::EOpDPdyFine:
         unaryOp = spv::OpDPdyFine;
         break;
-    case glslang::EOpFwidthFine:
+    case qglslang::EOpFwidthFine:
         unaryOp = spv::OpFwidthFine;
         break;
-    case glslang::EOpDPdxCoarse:
+    case qglslang::EOpDPdxCoarse:
         unaryOp = spv::OpDPdxCoarse;
         break;
-    case glslang::EOpDPdyCoarse:
+    case qglslang::EOpDPdyCoarse:
         unaryOp = spv::OpDPdyCoarse;
         break;
-    case glslang::EOpFwidthCoarse:
+    case qglslang::EOpFwidthCoarse:
         unaryOp = spv::OpFwidthCoarse;
         break;
-    case glslang::EOpRayQueryProceed:
+    case qglslang::EOpRayQueryProceed:
         unaryOp = spv::OpRayQueryProceedKHR;
         break;
-    case glslang::EOpRayQueryGetRayTMin:
+    case qglslang::EOpRayQueryGetRayTMin:
         unaryOp = spv::OpRayQueryGetRayTMinKHR;
         break;
-    case glslang::EOpRayQueryGetRayFlags:
+    case qglslang::EOpRayQueryGetRayFlags:
         unaryOp = spv::OpRayQueryGetRayFlagsKHR;
         break;
-    case glslang::EOpRayQueryGetWorldRayOrigin:
+    case qglslang::EOpRayQueryGetWorldRayOrigin:
         unaryOp = spv::OpRayQueryGetWorldRayOriginKHR;
         break;
-    case glslang::EOpRayQueryGetWorldRayDirection:
+    case qglslang::EOpRayQueryGetWorldRayDirection:
         unaryOp = spv::OpRayQueryGetWorldRayDirectionKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionCandidateAABBOpaque:
+    case qglslang::EOpRayQueryGetIntersectionCandidateAABBOpaque:
         unaryOp = spv::OpRayQueryGetIntersectionCandidateAABBOpaqueKHR;
         break;
-    case glslang::EOpInterpolateAtCentroid:
-        if (typeProxy == glslang::EbtFloat16)
+    case qglslang::EOpInterpolateAtCentroid:
+        if (typeProxy == qglslang::EbtFloat16)
             builder.addExtension(spv::E_SPV_AMD_gpu_shader_half_float);
         libCall = spv::GLSLstd450InterpolateAtCentroid;
         break;
-    case glslang::EOpAtomicCounterIncrement:
-    case glslang::EOpAtomicCounterDecrement:
-    case glslang::EOpAtomicCounter:
+    case qglslang::EOpAtomicCounterIncrement:
+    case qglslang::EOpAtomicCounterDecrement:
+    case qglslang::EOpAtomicCounter:
     {
         // Handle all of the atomics in one place, in createAtomicOperation()
         std::vector<spv::Id> operands;
@@ -6639,129 +6639,129 @@ spv::Id TGlslangToSpvTraverser::createUnaryOperation(glslang::TOperator op, OpDe
         return createAtomicOperation(op, decorations.precision, typeId, operands, typeProxy, lvalueCoherentFlags);
     }
 
-    case glslang::EOpBitFieldReverse:
+    case qglslang::EOpBitFieldReverse:
         unaryOp = spv::OpBitReverse;
         break;
-    case glslang::EOpBitCount:
+    case qglslang::EOpBitCount:
         unaryOp = spv::OpBitCount;
         break;
-    case glslang::EOpFindLSB:
+    case qglslang::EOpFindLSB:
         libCall = spv::GLSLstd450FindILsb;
         break;
-    case glslang::EOpFindMSB:
+    case qglslang::EOpFindMSB:
         if (isUnsigned)
             libCall = spv::GLSLstd450FindUMsb;
         else
             libCall = spv::GLSLstd450FindSMsb;
         break;
 
-    case glslang::EOpCountLeadingZeros:
+    case qglslang::EOpCountLeadingZeros:
         builder.addCapability(spv::CapabilityIntegerFunctions2INTEL);
         builder.addExtension("SPV_INTEL_shader_integer_functions2");
         unaryOp = spv::OpUCountLeadingZerosINTEL;
         break;
 
-    case glslang::EOpCountTrailingZeros:
+    case qglslang::EOpCountTrailingZeros:
         builder.addCapability(spv::CapabilityIntegerFunctions2INTEL);
         builder.addExtension("SPV_INTEL_shader_integer_functions2");
         unaryOp = spv::OpUCountTrailingZerosINTEL;
         break;
 
-    case glslang::EOpBallot:
-    case glslang::EOpReadFirstInvocation:
-    case glslang::EOpAnyInvocation:
-    case glslang::EOpAllInvocations:
-    case glslang::EOpAllInvocationsEqual:
-    case glslang::EOpMinInvocations:
-    case glslang::EOpMaxInvocations:
-    case glslang::EOpAddInvocations:
-    case glslang::EOpMinInvocationsNonUniform:
-    case glslang::EOpMaxInvocationsNonUniform:
-    case glslang::EOpAddInvocationsNonUniform:
-    case glslang::EOpMinInvocationsInclusiveScan:
-    case glslang::EOpMaxInvocationsInclusiveScan:
-    case glslang::EOpAddInvocationsInclusiveScan:
-    case glslang::EOpMinInvocationsInclusiveScanNonUniform:
-    case glslang::EOpMaxInvocationsInclusiveScanNonUniform:
-    case glslang::EOpAddInvocationsInclusiveScanNonUniform:
-    case glslang::EOpMinInvocationsExclusiveScan:
-    case glslang::EOpMaxInvocationsExclusiveScan:
-    case glslang::EOpAddInvocationsExclusiveScan:
-    case glslang::EOpMinInvocationsExclusiveScanNonUniform:
-    case glslang::EOpMaxInvocationsExclusiveScanNonUniform:
-    case glslang::EOpAddInvocationsExclusiveScanNonUniform:
+    case qglslang::EOpBallot:
+    case qglslang::EOpReadFirstInvocation:
+    case qglslang::EOpAnyInvocation:
+    case qglslang::EOpAllInvocations:
+    case qglslang::EOpAllInvocationsEqual:
+    case qglslang::EOpMinInvocations:
+    case qglslang::EOpMaxInvocations:
+    case qglslang::EOpAddInvocations:
+    case qglslang::EOpMinInvocationsNonUniform:
+    case qglslang::EOpMaxInvocationsNonUniform:
+    case qglslang::EOpAddInvocationsNonUniform:
+    case qglslang::EOpMinInvocationsInclusiveScan:
+    case qglslang::EOpMaxInvocationsInclusiveScan:
+    case qglslang::EOpAddInvocationsInclusiveScan:
+    case qglslang::EOpMinInvocationsInclusiveScanNonUniform:
+    case qglslang::EOpMaxInvocationsInclusiveScanNonUniform:
+    case qglslang::EOpAddInvocationsInclusiveScanNonUniform:
+    case qglslang::EOpMinInvocationsExclusiveScan:
+    case qglslang::EOpMaxInvocationsExclusiveScan:
+    case qglslang::EOpAddInvocationsExclusiveScan:
+    case qglslang::EOpMinInvocationsExclusiveScanNonUniform:
+    case qglslang::EOpMaxInvocationsExclusiveScanNonUniform:
+    case qglslang::EOpAddInvocationsExclusiveScanNonUniform:
     {
         std::vector<spv::Id> operands;
         operands.push_back(operand);
         return createInvocationsOperation(op, typeId, operands, typeProxy);
     }
-    case glslang::EOpSubgroupAll:
-    case glslang::EOpSubgroupAny:
-    case glslang::EOpSubgroupAllEqual:
-    case glslang::EOpSubgroupBroadcastFirst:
-    case glslang::EOpSubgroupBallot:
-    case glslang::EOpSubgroupInverseBallot:
-    case glslang::EOpSubgroupBallotBitCount:
-    case glslang::EOpSubgroupBallotInclusiveBitCount:
-    case glslang::EOpSubgroupBallotExclusiveBitCount:
-    case glslang::EOpSubgroupBallotFindLSB:
-    case glslang::EOpSubgroupBallotFindMSB:
-    case glslang::EOpSubgroupAdd:
-    case glslang::EOpSubgroupMul:
-    case glslang::EOpSubgroupMin:
-    case glslang::EOpSubgroupMax:
-    case glslang::EOpSubgroupAnd:
-    case glslang::EOpSubgroupOr:
-    case glslang::EOpSubgroupXor:
-    case glslang::EOpSubgroupInclusiveAdd:
-    case glslang::EOpSubgroupInclusiveMul:
-    case glslang::EOpSubgroupInclusiveMin:
-    case glslang::EOpSubgroupInclusiveMax:
-    case glslang::EOpSubgroupInclusiveAnd:
-    case glslang::EOpSubgroupInclusiveOr:
-    case glslang::EOpSubgroupInclusiveXor:
-    case glslang::EOpSubgroupExclusiveAdd:
-    case glslang::EOpSubgroupExclusiveMul:
-    case glslang::EOpSubgroupExclusiveMin:
-    case glslang::EOpSubgroupExclusiveMax:
-    case glslang::EOpSubgroupExclusiveAnd:
-    case glslang::EOpSubgroupExclusiveOr:
-    case glslang::EOpSubgroupExclusiveXor:
-    case glslang::EOpSubgroupQuadSwapHorizontal:
-    case glslang::EOpSubgroupQuadSwapVertical:
-    case glslang::EOpSubgroupQuadSwapDiagonal: {
+    case qglslang::EOpSubgroupAll:
+    case qglslang::EOpSubgroupAny:
+    case qglslang::EOpSubgroupAllEqual:
+    case qglslang::EOpSubgroupBroadcastFirst:
+    case qglslang::EOpSubgroupBallot:
+    case qglslang::EOpSubgroupInverseBallot:
+    case qglslang::EOpSubgroupBallotBitCount:
+    case qglslang::EOpSubgroupBallotInclusiveBitCount:
+    case qglslang::EOpSubgroupBallotExclusiveBitCount:
+    case qglslang::EOpSubgroupBallotFindLSB:
+    case qglslang::EOpSubgroupBallotFindMSB:
+    case qglslang::EOpSubgroupAdd:
+    case qglslang::EOpSubgroupMul:
+    case qglslang::EOpSubgroupMin:
+    case qglslang::EOpSubgroupMax:
+    case qglslang::EOpSubgroupAnd:
+    case qglslang::EOpSubgroupOr:
+    case qglslang::EOpSubgroupXor:
+    case qglslang::EOpSubgroupInclusiveAdd:
+    case qglslang::EOpSubgroupInclusiveMul:
+    case qglslang::EOpSubgroupInclusiveMin:
+    case qglslang::EOpSubgroupInclusiveMax:
+    case qglslang::EOpSubgroupInclusiveAnd:
+    case qglslang::EOpSubgroupInclusiveOr:
+    case qglslang::EOpSubgroupInclusiveXor:
+    case qglslang::EOpSubgroupExclusiveAdd:
+    case qglslang::EOpSubgroupExclusiveMul:
+    case qglslang::EOpSubgroupExclusiveMin:
+    case qglslang::EOpSubgroupExclusiveMax:
+    case qglslang::EOpSubgroupExclusiveAnd:
+    case qglslang::EOpSubgroupExclusiveOr:
+    case qglslang::EOpSubgroupExclusiveXor:
+    case qglslang::EOpSubgroupQuadSwapHorizontal:
+    case qglslang::EOpSubgroupQuadSwapVertical:
+    case qglslang::EOpSubgroupQuadSwapDiagonal: {
         std::vector<spv::Id> operands;
         operands.push_back(operand);
         return createSubgroupOperation(op, typeId, operands, typeProxy);
     }
-    case glslang::EOpMbcnt:
+    case qglslang::EOpMbcnt:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_ballot);
         libCall = spv::MbcntAMD;
         break;
 
-    case glslang::EOpCubeFaceIndex:
+    case qglslang::EOpCubeFaceIndex:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_gcn_shader);
         libCall = spv::CubeFaceIndexAMD;
         break;
 
-    case glslang::EOpCubeFaceCoord:
+    case qglslang::EOpCubeFaceCoord:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_gcn_shader);
         libCall = spv::CubeFaceCoordAMD;
         break;
-    case glslang::EOpSubgroupPartition:
+    case qglslang::EOpSubgroupPartition:
         unaryOp = spv::OpGroupNonUniformPartitionNV;
         break;
-    case glslang::EOpConstructReference:
+    case qglslang::EOpConstructReference:
         unaryOp = spv::OpBitcast;
         break;
 
-    case glslang::EOpConvUint64ToAccStruct:
-    case glslang::EOpConvUvec2ToAccStruct:
+    case qglslang::EOpConvUint64ToAccStruct:
+    case qglslang::EOpConvUvec2ToAccStruct:
         unaryOp = spv::OpConvertUToAccelerationStructureKHR;
         break;
 #endif
 
-    case glslang::EOpCopyObject:
+    case qglslang::EOpCopyObject:
         unaryOp = spv::OpCopyObject;
         break;
 
@@ -6785,7 +6785,7 @@ spv::Id TGlslangToSpvTraverser::createUnaryOperation(glslang::TOperator op, OpDe
 
 // Create a unary operation on a matrix
 spv::Id TGlslangToSpvTraverser::createUnaryMatrixOperation(spv::Op op, OpDecorations& decorations, spv::Id typeId,
-                                                           spv::Id operand, glslang::TBasicType /* typeProxy */)
+                                                           spv::Id operand, qglslang::TBasicType /* typeProxy */)
 {
     // Handle unary operations vector by vector.
     // The result type is the same type as the original type.
@@ -6821,41 +6821,41 @@ spv::Id TGlslangToSpvTraverser::createUnaryMatrixOperation(spv::Op op, OpDecorat
 // For converting integers where both the bitwidth and the signedness could
 // change, but only do the width change here. The caller is still responsible
 // for the signedness conversion.
-spv::Id TGlslangToSpvTraverser::createIntWidthConversion(glslang::TOperator op, spv::Id operand, int vectorSize)
+spv::Id TGlslangToSpvTraverser::createIntWidthConversion(qglslang::TOperator op, spv::Id operand, int vectorSize)
 {
     // Get the result type width, based on the type to convert to.
     int width = 32;
     switch(op) {
-    case glslang::EOpConvInt16ToUint8:
-    case glslang::EOpConvIntToUint8:
-    case glslang::EOpConvInt64ToUint8:
-    case glslang::EOpConvUint16ToInt8:
-    case glslang::EOpConvUintToInt8:
-    case glslang::EOpConvUint64ToInt8:
+    case qglslang::EOpConvInt16ToUint8:
+    case qglslang::EOpConvIntToUint8:
+    case qglslang::EOpConvInt64ToUint8:
+    case qglslang::EOpConvUint16ToInt8:
+    case qglslang::EOpConvUintToInt8:
+    case qglslang::EOpConvUint64ToInt8:
         width = 8;
         break;
-    case glslang::EOpConvInt8ToUint16:
-    case glslang::EOpConvIntToUint16:
-    case glslang::EOpConvInt64ToUint16:
-    case glslang::EOpConvUint8ToInt16:
-    case glslang::EOpConvUintToInt16:
-    case glslang::EOpConvUint64ToInt16:
+    case qglslang::EOpConvInt8ToUint16:
+    case qglslang::EOpConvIntToUint16:
+    case qglslang::EOpConvInt64ToUint16:
+    case qglslang::EOpConvUint8ToInt16:
+    case qglslang::EOpConvUintToInt16:
+    case qglslang::EOpConvUint64ToInt16:
         width = 16;
         break;
-    case glslang::EOpConvInt8ToUint:
-    case glslang::EOpConvInt16ToUint:
-    case glslang::EOpConvInt64ToUint:
-    case glslang::EOpConvUint8ToInt:
-    case glslang::EOpConvUint16ToInt:
-    case glslang::EOpConvUint64ToInt:
+    case qglslang::EOpConvInt8ToUint:
+    case qglslang::EOpConvInt16ToUint:
+    case qglslang::EOpConvInt64ToUint:
+    case qglslang::EOpConvUint8ToInt:
+    case qglslang::EOpConvUint16ToInt:
+    case qglslang::EOpConvUint64ToInt:
         width = 32;
         break;
-    case glslang::EOpConvInt8ToUint64:
-    case glslang::EOpConvInt16ToUint64:
-    case glslang::EOpConvIntToUint64:
-    case glslang::EOpConvUint8ToInt64:
-    case glslang::EOpConvUint16ToInt64:
-    case glslang::EOpConvUintToInt64:
+    case qglslang::EOpConvInt8ToUint64:
+    case qglslang::EOpConvInt16ToUint64:
+    case qglslang::EOpConvIntToUint64:
+    case qglslang::EOpConvUint8ToInt64:
+    case qglslang::EOpConvUint16ToInt64:
+    case qglslang::EOpConvUintToInt64:
         width = 64;
         break;
 
@@ -6869,18 +6869,18 @@ spv::Id TGlslangToSpvTraverser::createIntWidthConversion(glslang::TOperator op,
     spv::Id type = spv::NoType;
     spv::Op convOp = spv::OpNop;
     switch(op) {
-    case glslang::EOpConvInt8ToUint16:
-    case glslang::EOpConvInt8ToUint:
-    case glslang::EOpConvInt8ToUint64:
-    case glslang::EOpConvInt16ToUint8:
-    case glslang::EOpConvInt16ToUint:
-    case glslang::EOpConvInt16ToUint64:
-    case glslang::EOpConvIntToUint8:
-    case glslang::EOpConvIntToUint16:
-    case glslang::EOpConvIntToUint64:
-    case glslang::EOpConvInt64ToUint8:
-    case glslang::EOpConvInt64ToUint16:
-    case glslang::EOpConvInt64ToUint:
+    case qglslang::EOpConvInt8ToUint16:
+    case qglslang::EOpConvInt8ToUint:
+    case qglslang::EOpConvInt8ToUint64:
+    case qglslang::EOpConvInt16ToUint8:
+    case qglslang::EOpConvInt16ToUint:
+    case qglslang::EOpConvInt16ToUint64:
+    case qglslang::EOpConvIntToUint8:
+    case qglslang::EOpConvIntToUint16:
+    case qglslang::EOpConvIntToUint64:
+    case qglslang::EOpConvInt64ToUint8:
+    case qglslang::EOpConvInt64ToUint16:
+    case qglslang::EOpConvInt64ToUint:
         convOp = spv::OpSConvert;
         type = builder.makeIntType(width);
         break;
@@ -6896,8 +6896,8 @@ spv::Id TGlslangToSpvTraverser::createIntWidthConversion(glslang::TOperator op,
     return builder.createUnaryOp(convOp, type, operand);
 }
 
-spv::Id TGlslangToSpvTraverser::createConversion(glslang::TOperator op, OpDecorations& decorations, spv::Id destType,
-                                                 spv::Id operand, glslang::TBasicType typeProxy)
+spv::Id TGlslangToSpvTraverser::createConversion(qglslang::TOperator op, OpDecorations& decorations, spv::Id destType,
+                                                 spv::Id operand, qglslang::TBasicType typeProxy)
 {
     spv::Op convOp = spv::OpNop;
     spv::Id zero = 0;
@@ -6906,25 +6906,25 @@ spv::Id TGlslangToSpvTraverser::createConversion(glslang::TOperator op, OpDecora
     int vectorSize = builder.isVectorType(destType) ? builder.getNumTypeComponents(destType) : 0;
 
     switch (op) {
-    case glslang::EOpConvIntToBool:
-    case glslang::EOpConvUintToBool:
+    case qglslang::EOpConvIntToBool:
+    case qglslang::EOpConvUintToBool:
         zero = builder.makeUintConstant(0);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpINotEqual, destType, operand, zero);
-    case glslang::EOpConvFloatToBool:
+    case qglslang::EOpConvFloatToBool:
         zero = builder.makeFloatConstant(0.0F);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpFUnordNotEqual, destType, operand, zero);
-    case glslang::EOpConvBoolToFloat:
+    case qglslang::EOpConvBoolToFloat:
         convOp = spv::OpSelect;
         zero = builder.makeFloatConstant(0.0F);
         one  = builder.makeFloatConstant(1.0F);
         break;
 
-    case glslang::EOpConvBoolToInt:
-    case glslang::EOpConvBoolToInt64:
+    case qglslang::EOpConvBoolToInt:
+    case qglslang::EOpConvBoolToInt64:
 #ifndef GLSLANG_WEB
-        if (op == glslang::EOpConvBoolToInt64) {
+        if (op == qglslang::EOpConvBoolToInt64) {
             zero = builder.makeInt64Constant(0);
             one = builder.makeInt64Constant(1);
         } else
@@ -6937,10 +6937,10 @@ spv::Id TGlslangToSpvTraverser::createConversion(glslang::TOperator op, OpDecora
         convOp = spv::OpSelect;
         break;
 
-    case glslang::EOpConvBoolToUint:
-    case glslang::EOpConvBoolToUint64:
+    case qglslang::EOpConvBoolToUint:
+    case qglslang::EOpConvBoolToUint64:
 #ifndef GLSLANG_WEB
-        if (op == glslang::EOpConvBoolToUint64) {
+        if (op == qglslang::EOpConvBoolToUint64) {
             zero = builder.makeUint64Constant(0);
             one = builder.makeUint64Constant(1);
         } else
@@ -6953,67 +6953,67 @@ spv::Id TGlslangToSpvTraverser::createConversion(glslang::TOperator op, OpDecora
         convOp = spv::OpSelect;
         break;
 
-    case glslang::EOpConvInt8ToFloat16:
-    case glslang::EOpConvInt8ToFloat:
-    case glslang::EOpConvInt8ToDouble:
-    case glslang::EOpConvInt16ToFloat16:
-    case glslang::EOpConvInt16ToFloat:
-    case glslang::EOpConvInt16ToDouble:
-    case glslang::EOpConvIntToFloat16:
-    case glslang::EOpConvIntToFloat:
-    case glslang::EOpConvIntToDouble:
-    case glslang::EOpConvInt64ToFloat:
-    case glslang::EOpConvInt64ToDouble:
-    case glslang::EOpConvInt64ToFloat16:
+    case qglslang::EOpConvInt8ToFloat16:
+    case qglslang::EOpConvInt8ToFloat:
+    case qglslang::EOpConvInt8ToDouble:
+    case qglslang::EOpConvInt16ToFloat16:
+    case qglslang::EOpConvInt16ToFloat:
+    case qglslang::EOpConvInt16ToDouble:
+    case qglslang::EOpConvIntToFloat16:
+    case qglslang::EOpConvIntToFloat:
+    case qglslang::EOpConvIntToDouble:
+    case qglslang::EOpConvInt64ToFloat:
+    case qglslang::EOpConvInt64ToDouble:
+    case qglslang::EOpConvInt64ToFloat16:
         convOp = spv::OpConvertSToF;
         break;
 
-    case glslang::EOpConvUint8ToFloat16:
-    case glslang::EOpConvUint8ToFloat:
-    case glslang::EOpConvUint8ToDouble:
-    case glslang::EOpConvUint16ToFloat16:
-    case glslang::EOpConvUint16ToFloat:
-    case glslang::EOpConvUint16ToDouble:
-    case glslang::EOpConvUintToFloat16:
-    case glslang::EOpConvUintToFloat:
-    case glslang::EOpConvUintToDouble:
-    case glslang::EOpConvUint64ToFloat:
-    case glslang::EOpConvUint64ToDouble:
-    case glslang::EOpConvUint64ToFloat16:
+    case qglslang::EOpConvUint8ToFloat16:
+    case qglslang::EOpConvUint8ToFloat:
+    case qglslang::EOpConvUint8ToDouble:
+    case qglslang::EOpConvUint16ToFloat16:
+    case qglslang::EOpConvUint16ToFloat:
+    case qglslang::EOpConvUint16ToDouble:
+    case qglslang::EOpConvUintToFloat16:
+    case qglslang::EOpConvUintToFloat:
+    case qglslang::EOpConvUintToDouble:
+    case qglslang::EOpConvUint64ToFloat:
+    case qglslang::EOpConvUint64ToDouble:
+    case qglslang::EOpConvUint64ToFloat16:
         convOp = spv::OpConvertUToF;
         break;
 
-    case glslang::EOpConvFloat16ToInt8:
-    case glslang::EOpConvFloatToInt8:
-    case glslang::EOpConvDoubleToInt8:
-    case glslang::EOpConvFloat16ToInt16:
-    case glslang::EOpConvFloatToInt16:
-    case glslang::EOpConvDoubleToInt16:
-    case glslang::EOpConvFloat16ToInt:
-    case glslang::EOpConvFloatToInt:
-    case glslang::EOpConvDoubleToInt:
-    case glslang::EOpConvFloat16ToInt64:
-    case glslang::EOpConvFloatToInt64:
-    case glslang::EOpConvDoubleToInt64:
+    case qglslang::EOpConvFloat16ToInt8:
+    case qglslang::EOpConvFloatToInt8:
+    case qglslang::EOpConvDoubleToInt8:
+    case qglslang::EOpConvFloat16ToInt16:
+    case qglslang::EOpConvFloatToInt16:
+    case qglslang::EOpConvDoubleToInt16:
+    case qglslang::EOpConvFloat16ToInt:
+    case qglslang::EOpConvFloatToInt:
+    case qglslang::EOpConvDoubleToInt:
+    case qglslang::EOpConvFloat16ToInt64:
+    case qglslang::EOpConvFloatToInt64:
+    case qglslang::EOpConvDoubleToInt64:
         convOp = spv::OpConvertFToS;
         break;
 
-    case glslang::EOpConvUint8ToInt8:
-    case glslang::EOpConvInt8ToUint8:
-    case glslang::EOpConvUint16ToInt16:
-    case glslang::EOpConvInt16ToUint16:
-    case glslang::EOpConvUintToInt:
-    case glslang::EOpConvIntToUint:
-    case glslang::EOpConvUint64ToInt64:
-    case glslang::EOpConvInt64ToUint64:
+    case qglslang::EOpConvUint8ToInt8:
+    case qglslang::EOpConvInt8ToUint8:
+    case qglslang::EOpConvUint16ToInt16:
+    case qglslang::EOpConvInt16ToUint16:
+    case qglslang::EOpConvUintToInt:
+    case qglslang::EOpConvIntToUint:
+    case qglslang::EOpConvUint64ToInt64:
+    case qglslang::EOpConvInt64ToUint64:
         if (builder.isInSpecConstCodeGenMode()) {
             // Build zero scalar or vector for OpIAdd.
 #ifndef GLSLANG_WEB
-            if(op == glslang::EOpConvUint8ToInt8 || op == glslang::EOpConvInt8ToUint8) {
+            if(op == qglslang::EOpConvUint8ToInt8 || op == qglslang::EOpConvInt8ToUint8) {
                 zero = builder.makeUint8Constant(0);
-            } else if (op == glslang::EOpConvUint16ToInt16 || op == glslang::EOpConvInt16ToUint16) {
+            } else if (op == qglslang::EOpConvUint16ToInt16 || op == qglslang::EOpConvInt16ToUint16) {
                 zero = builder.makeUint16Constant(0);
-            } else if (op == glslang::EOpConvUint64ToInt64 || op == glslang::EOpConvInt64ToUint64) {
+            } else if (op == qglslang::EOpConvUint64ToInt64 || op == qglslang::EOpConvInt64ToUint64) {
                 zero = builder.makeUint64Constant(0);
             } else
 #endif
@@ -7029,176 +7029,176 @@ spv::Id TGlslangToSpvTraverser::createConversion(glslang::TOperator op, OpDecora
         convOp = spv::OpBitcast;
         break;
 
-    case glslang::EOpConvFloat16ToUint8:
-    case glslang::EOpConvFloatToUint8:
-    case glslang::EOpConvDoubleToUint8:
-    case glslang::EOpConvFloat16ToUint16:
-    case glslang::EOpConvFloatToUint16:
-    case glslang::EOpConvDoubleToUint16:
-    case glslang::EOpConvFloat16ToUint:
-    case glslang::EOpConvFloatToUint:
-    case glslang::EOpConvDoubleToUint:
-    case glslang::EOpConvFloatToUint64:
-    case glslang::EOpConvDoubleToUint64:
-    case glslang::EOpConvFloat16ToUint64:
+    case qglslang::EOpConvFloat16ToUint8:
+    case qglslang::EOpConvFloatToUint8:
+    case qglslang::EOpConvDoubleToUint8:
+    case qglslang::EOpConvFloat16ToUint16:
+    case qglslang::EOpConvFloatToUint16:
+    case qglslang::EOpConvDoubleToUint16:
+    case qglslang::EOpConvFloat16ToUint:
+    case qglslang::EOpConvFloatToUint:
+    case qglslang::EOpConvDoubleToUint:
+    case qglslang::EOpConvFloatToUint64:
+    case qglslang::EOpConvDoubleToUint64:
+    case qglslang::EOpConvFloat16ToUint64:
         convOp = spv::OpConvertFToU;
         break;
 
 #ifndef GLSLANG_WEB
-    case glslang::EOpConvInt8ToBool:
-    case glslang::EOpConvUint8ToBool:
+    case qglslang::EOpConvInt8ToBool:
+    case qglslang::EOpConvUint8ToBool:
         zero = builder.makeUint8Constant(0);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpINotEqual, destType, operand, zero);
-    case glslang::EOpConvInt16ToBool:
-    case glslang::EOpConvUint16ToBool:
+    case qglslang::EOpConvInt16ToBool:
+    case qglslang::EOpConvUint16ToBool:
         zero = builder.makeUint16Constant(0);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpINotEqual, destType, operand, zero);
-    case glslang::EOpConvInt64ToBool:
-    case glslang::EOpConvUint64ToBool:
+    case qglslang::EOpConvInt64ToBool:
+    case qglslang::EOpConvUint64ToBool:
         zero = builder.makeUint64Constant(0);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpINotEqual, destType, operand, zero);
-    case glslang::EOpConvDoubleToBool:
+    case qglslang::EOpConvDoubleToBool:
         zero = builder.makeDoubleConstant(0.0);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpFUnordNotEqual, destType, operand, zero);
-    case glslang::EOpConvFloat16ToBool:
+    case qglslang::EOpConvFloat16ToBool:
         zero = builder.makeFloat16Constant(0.0F);
         zero = makeSmearedConstant(zero, vectorSize);
         return builder.createBinOp(spv::OpFUnordNotEqual, destType, operand, zero);
-    case glslang::EOpConvBoolToDouble:
+    case qglslang::EOpConvBoolToDouble:
         convOp = spv::OpSelect;
         zero = builder.makeDoubleConstant(0.0);
         one  = builder.makeDoubleConstant(1.0);
         break;
-    case glslang::EOpConvBoolToFloat16:
+    case qglslang::EOpConvBoolToFloat16:
         convOp = spv::OpSelect;
         zero = builder.makeFloat16Constant(0.0F);
         one = builder.makeFloat16Constant(1.0F);
         break;
-    case glslang::EOpConvBoolToInt8:
+    case qglslang::EOpConvBoolToInt8:
         zero = builder.makeInt8Constant(0);
         one  = builder.makeInt8Constant(1);
         convOp = spv::OpSelect;
         break;
-    case glslang::EOpConvBoolToUint8:
+    case qglslang::EOpConvBoolToUint8:
         zero = builder.makeUint8Constant(0);
         one  = builder.makeUint8Constant(1);
         convOp = spv::OpSelect;
         break;
-    case glslang::EOpConvBoolToInt16:
+    case qglslang::EOpConvBoolToInt16:
         zero = builder.makeInt16Constant(0);
         one  = builder.makeInt16Constant(1);
         convOp = spv::OpSelect;
         break;
-    case glslang::EOpConvBoolToUint16:
+    case qglslang::EOpConvBoolToUint16:
         zero = builder.makeUint16Constant(0);
         one  = builder.makeUint16Constant(1);
         convOp = spv::OpSelect;
         break;
-    case glslang::EOpConvDoubleToFloat:
-    case glslang::EOpConvFloatToDouble:
-    case glslang::EOpConvDoubleToFloat16:
-    case glslang::EOpConvFloat16ToDouble:
-    case glslang::EOpConvFloatToFloat16:
-    case glslang::EOpConvFloat16ToFloat:
+    case qglslang::EOpConvDoubleToFloat:
+    case qglslang::EOpConvFloatToDouble:
+    case qglslang::EOpConvDoubleToFloat16:
+    case qglslang::EOpConvFloat16ToDouble:
+    case qglslang::EOpConvFloatToFloat16:
+    case qglslang::EOpConvFloat16ToFloat:
         convOp = spv::OpFConvert;
         if (builder.isMatrixType(destType))
             return createUnaryMatrixOperation(convOp, decorations, destType, operand, typeProxy);
         break;
 
-    case glslang::EOpConvInt8ToInt16:
-    case glslang::EOpConvInt8ToInt:
-    case glslang::EOpConvInt8ToInt64:
-    case glslang::EOpConvInt16ToInt8:
-    case glslang::EOpConvInt16ToInt:
-    case glslang::EOpConvInt16ToInt64:
-    case glslang::EOpConvIntToInt8:
-    case glslang::EOpConvIntToInt16:
-    case glslang::EOpConvIntToInt64:
-    case glslang::EOpConvInt64ToInt8:
-    case glslang::EOpConvInt64ToInt16:
-    case glslang::EOpConvInt64ToInt:
+    case qglslang::EOpConvInt8ToInt16:
+    case qglslang::EOpConvInt8ToInt:
+    case qglslang::EOpConvInt8ToInt64:
+    case qglslang::EOpConvInt16ToInt8:
+    case qglslang::EOpConvInt16ToInt:
+    case qglslang::EOpConvInt16ToInt64:
+    case qglslang::EOpConvIntToInt8:
+    case qglslang::EOpConvIntToInt16:
+    case qglslang::EOpConvIntToInt64:
+    case qglslang::EOpConvInt64ToInt8:
+    case qglslang::EOpConvInt64ToInt16:
+    case qglslang::EOpConvInt64ToInt:
         convOp = spv::OpSConvert;
         break;
 
-    case glslang::EOpConvUint8ToUint16:
-    case glslang::EOpConvUint8ToUint:
-    case glslang::EOpConvUint8ToUint64:
-    case glslang::EOpConvUint16ToUint8:
-    case glslang::EOpConvUint16ToUint:
-    case glslang::EOpConvUint16ToUint64:
-    case glslang::EOpConvUintToUint8:
-    case glslang::EOpConvUintToUint16:
-    case glslang::EOpConvUintToUint64:
-    case glslang::EOpConvUint64ToUint8:
-    case glslang::EOpConvUint64ToUint16:
-    case glslang::EOpConvUint64ToUint:
+    case qglslang::EOpConvUint8ToUint16:
+    case qglslang::EOpConvUint8ToUint:
+    case qglslang::EOpConvUint8ToUint64:
+    case qglslang::EOpConvUint16ToUint8:
+    case qglslang::EOpConvUint16ToUint:
+    case qglslang::EOpConvUint16ToUint64:
+    case qglslang::EOpConvUintToUint8:
+    case qglslang::EOpConvUintToUint16:
+    case qglslang::EOpConvUintToUint64:
+    case qglslang::EOpConvUint64ToUint8:
+    case qglslang::EOpConvUint64ToUint16:
+    case qglslang::EOpConvUint64ToUint:
         convOp = spv::OpUConvert;
         break;
 
-    case glslang::EOpConvInt8ToUint16:
-    case glslang::EOpConvInt8ToUint:
-    case glslang::EOpConvInt8ToUint64:
-    case glslang::EOpConvInt16ToUint8:
-    case glslang::EOpConvInt16ToUint:
-    case glslang::EOpConvInt16ToUint64:
-    case glslang::EOpConvIntToUint8:
-    case glslang::EOpConvIntToUint16:
-    case glslang::EOpConvIntToUint64:
-    case glslang::EOpConvInt64ToUint8:
-    case glslang::EOpConvInt64ToUint16:
-    case glslang::EOpConvInt64ToUint:
-    case glslang::EOpConvUint8ToInt16:
-    case glslang::EOpConvUint8ToInt:
-    case glslang::EOpConvUint8ToInt64:
-    case glslang::EOpConvUint16ToInt8:
-    case glslang::EOpConvUint16ToInt:
-    case glslang::EOpConvUint16ToInt64:
-    case glslang::EOpConvUintToInt8:
-    case glslang::EOpConvUintToInt16:
-    case glslang::EOpConvUintToInt64:
-    case glslang::EOpConvUint64ToInt8:
-    case glslang::EOpConvUint64ToInt16:
-    case glslang::EOpConvUint64ToInt:
+    case qglslang::EOpConvInt8ToUint16:
+    case qglslang::EOpConvInt8ToUint:
+    case qglslang::EOpConvInt8ToUint64:
+    case qglslang::EOpConvInt16ToUint8:
+    case qglslang::EOpConvInt16ToUint:
+    case qglslang::EOpConvInt16ToUint64:
+    case qglslang::EOpConvIntToUint8:
+    case qglslang::EOpConvIntToUint16:
+    case qglslang::EOpConvIntToUint64:
+    case qglslang::EOpConvInt64ToUint8:
+    case qglslang::EOpConvInt64ToUint16:
+    case qglslang::EOpConvInt64ToUint:
+    case qglslang::EOpConvUint8ToInt16:
+    case qglslang::EOpConvUint8ToInt:
+    case qglslang::EOpConvUint8ToInt64:
+    case qglslang::EOpConvUint16ToInt8:
+    case qglslang::EOpConvUint16ToInt:
+    case qglslang::EOpConvUint16ToInt64:
+    case qglslang::EOpConvUintToInt8:
+    case qglslang::EOpConvUintToInt16:
+    case qglslang::EOpConvUintToInt64:
+    case qglslang::EOpConvUint64ToInt8:
+    case qglslang::EOpConvUint64ToInt16:
+    case qglslang::EOpConvUint64ToInt:
         // OpSConvert/OpUConvert + OpBitCast
         operand = createIntWidthConversion(op, operand, vectorSize);
 
         if (builder.isInSpecConstCodeGenMode()) {
             // Build zero scalar or vector for OpIAdd.
             switch(op) {
-            case glslang::EOpConvInt16ToUint8:
-            case glslang::EOpConvIntToUint8:
-            case glslang::EOpConvInt64ToUint8:
-            case glslang::EOpConvUint16ToInt8:
-            case glslang::EOpConvUintToInt8:
-            case glslang::EOpConvUint64ToInt8:
+            case qglslang::EOpConvInt16ToUint8:
+            case qglslang::EOpConvIntToUint8:
+            case qglslang::EOpConvInt64ToUint8:
+            case qglslang::EOpConvUint16ToInt8:
+            case qglslang::EOpConvUintToInt8:
+            case qglslang::EOpConvUint64ToInt8:
                 zero = builder.makeUint8Constant(0);
                 break;
-            case glslang::EOpConvInt8ToUint16:
-            case glslang::EOpConvIntToUint16:
-            case glslang::EOpConvInt64ToUint16:
-            case glslang::EOpConvUint8ToInt16:
-            case glslang::EOpConvUintToInt16:
-            case glslang::EOpConvUint64ToInt16:
+            case qglslang::EOpConvInt8ToUint16:
+            case qglslang::EOpConvIntToUint16:
+            case qglslang::EOpConvInt64ToUint16:
+            case qglslang::EOpConvUint8ToInt16:
+            case qglslang::EOpConvUintToInt16:
+            case qglslang::EOpConvUint64ToInt16:
                 zero = builder.makeUint16Constant(0);
                 break;
-            case glslang::EOpConvInt8ToUint:
-            case glslang::EOpConvInt16ToUint:
-            case glslang::EOpConvInt64ToUint:
-            case glslang::EOpConvUint8ToInt:
-            case glslang::EOpConvUint16ToInt:
-            case glslang::EOpConvUint64ToInt:
+            case qglslang::EOpConvInt8ToUint:
+            case qglslang::EOpConvInt16ToUint:
+            case qglslang::EOpConvInt64ToUint:
+            case qglslang::EOpConvUint8ToInt:
+            case qglslang::EOpConvUint16ToInt:
+            case qglslang::EOpConvUint64ToInt:
                 zero = builder.makeUintConstant(0);
                 break;
-            case glslang::EOpConvInt8ToUint64:
-            case glslang::EOpConvInt16ToUint64:
-            case glslang::EOpConvIntToUint64:
-            case glslang::EOpConvUint8ToInt64:
-            case glslang::EOpConvUint16ToInt64:
-            case glslang::EOpConvUintToInt64:
+            case qglslang::EOpConvInt8ToUint64:
+            case qglslang::EOpConvInt16ToUint64:
+            case qglslang::EOpConvIntToUint64:
+            case qglslang::EOpConvUint8ToInt64:
+            case qglslang::EOpConvUint16ToInt64:
+            case qglslang::EOpConvUintToInt64:
                 zero = builder.makeUint64Constant(0);
                 break;
             default:
@@ -7213,14 +7213,14 @@ spv::Id TGlslangToSpvTraverser::createConversion(glslang::TOperator op, OpDecora
         // For normal run-time conversion instruction, use OpBitcast.
         convOp = spv::OpBitcast;
         break;
-    case glslang::EOpConvUint64ToPtr:
+    case qglslang::EOpConvUint64ToPtr:
         convOp = spv::OpConvertUToPtr;
         break;
-    case glslang::EOpConvPtrToUint64:
+    case qglslang::EOpConvPtrToUint64:
         convOp = spv::OpConvertPtrToU;
         break;
-    case glslang::EOpConvPtrToUvec2:
-    case glslang::EOpConvUvec2ToPtr:
+    case qglslang::EOpConvPtrToUvec2:
+    case qglslang::EOpConvUvec2ToPtr:
         convOp = spv::OpBitcast;
         break;
 #endif
@@ -7258,108 +7258,108 @@ spv::Id TGlslangToSpvTraverser::makeSmearedConstant(spv::Id constant, int vector
 }
 
 // For glslang ops that map to SPV atomic opCodes
-spv::Id TGlslangToSpvTraverser::createAtomicOperation(glslang::TOperator op, spv::Decoration /*precision*/,
-    spv::Id typeId, std::vector<spv::Id>& operands, glslang::TBasicType typeProxy,
+spv::Id TGlslangToSpvTraverser::createAtomicOperation(qglslang::TOperator op, spv::Decoration /*precision*/,
+    spv::Id typeId, std::vector<spv::Id>& operands, qglslang::TBasicType typeProxy,
     const spv::Builder::AccessChain::CoherentFlags &lvalueCoherentFlags)
 {
     spv::Op opCode = spv::OpNop;
 
     switch (op) {
-    case glslang::EOpAtomicAdd:
-    case glslang::EOpImageAtomicAdd:
-    case glslang::EOpAtomicCounterAdd:
+    case qglslang::EOpAtomicAdd:
+    case qglslang::EOpImageAtomicAdd:
+    case qglslang::EOpAtomicCounterAdd:
         opCode = spv::OpAtomicIAdd;
-        if (typeProxy == glslang::EbtFloat16 || typeProxy == glslang::EbtFloat || typeProxy == glslang::EbtDouble) {
+        if (typeProxy == qglslang::EbtFloat16 || typeProxy == qglslang::EbtFloat || typeProxy == qglslang::EbtDouble) {
             opCode = spv::OpAtomicFAddEXT;
             builder.addExtension(spv::E_SPV_EXT_shader_atomic_float_add);
-            if (typeProxy == glslang::EbtFloat16) {
+            if (typeProxy == qglslang::EbtFloat16) {
                 builder.addExtension(spv::E_SPV_EXT_shader_atomic_float16_add);
                 builder.addCapability(spv::CapabilityAtomicFloat16AddEXT);
-            } else if (typeProxy == glslang::EbtFloat) {
+            } else if (typeProxy == qglslang::EbtFloat) {
                 builder.addCapability(spv::CapabilityAtomicFloat32AddEXT);
             } else {
                 builder.addCapability(spv::CapabilityAtomicFloat64AddEXT);
             }
         }
         break;
-    case glslang::EOpAtomicSubtract:
-    case glslang::EOpAtomicCounterSubtract:
+    case qglslang::EOpAtomicSubtract:
+    case qglslang::EOpAtomicCounterSubtract:
         opCode = spv::OpAtomicISub;
         break;
-    case glslang::EOpAtomicMin:
-    case glslang::EOpImageAtomicMin:
-    case glslang::EOpAtomicCounterMin:
-        if (typeProxy == glslang::EbtFloat16 || typeProxy == glslang::EbtFloat || typeProxy == glslang::EbtDouble) {
+    case qglslang::EOpAtomicMin:
+    case qglslang::EOpImageAtomicMin:
+    case qglslang::EOpAtomicCounterMin:
+        if (typeProxy == qglslang::EbtFloat16 || typeProxy == qglslang::EbtFloat || typeProxy == qglslang::EbtDouble) {
             opCode = spv::OpAtomicFMinEXT;
             builder.addExtension(spv::E_SPV_EXT_shader_atomic_float_min_max);
-            if (typeProxy == glslang::EbtFloat16)
+            if (typeProxy == qglslang::EbtFloat16)
                 builder.addCapability(spv::CapabilityAtomicFloat16MinMaxEXT);
-            else if (typeProxy == glslang::EbtFloat)
+            else if (typeProxy == qglslang::EbtFloat)
                 builder.addCapability(spv::CapabilityAtomicFloat32MinMaxEXT);
             else
                 builder.addCapability(spv::CapabilityAtomicFloat64MinMaxEXT);
-        } else if (typeProxy == glslang::EbtUint || typeProxy == glslang::EbtUint64) {
+        } else if (typeProxy == qglslang::EbtUint || typeProxy == qglslang::EbtUint64) {
             opCode = spv::OpAtomicUMin;
         } else {
             opCode = spv::OpAtomicSMin;
         }
         break;
-    case glslang::EOpAtomicMax:
-    case glslang::EOpImageAtomicMax:
-    case glslang::EOpAtomicCounterMax:
-        if (typeProxy == glslang::EbtFloat16 || typeProxy == glslang::EbtFloat || typeProxy == glslang::EbtDouble) {
+    case qglslang::EOpAtomicMax:
+    case qglslang::EOpImageAtomicMax:
+    case qglslang::EOpAtomicCounterMax:
+        if (typeProxy == qglslang::EbtFloat16 || typeProxy == qglslang::EbtFloat || typeProxy == qglslang::EbtDouble) {
             opCode = spv::OpAtomicFMaxEXT;
             builder.addExtension(spv::E_SPV_EXT_shader_atomic_float_min_max);
-            if (typeProxy == glslang::EbtFloat16)
+            if (typeProxy == qglslang::EbtFloat16)
                 builder.addCapability(spv::CapabilityAtomicFloat16MinMaxEXT);
-            else if (typeProxy == glslang::EbtFloat)
+            else if (typeProxy == qglslang::EbtFloat)
                 builder.addCapability(spv::CapabilityAtomicFloat32MinMaxEXT);
             else
                 builder.addCapability(spv::CapabilityAtomicFloat64MinMaxEXT);
-        } else if (typeProxy == glslang::EbtUint || typeProxy == glslang::EbtUint64) {
+        } else if (typeProxy == qglslang::EbtUint || typeProxy == qglslang::EbtUint64) {
             opCode = spv::OpAtomicUMax;
         } else {
             opCode = spv::OpAtomicSMax;
         }
         break;
-    case glslang::EOpAtomicAnd:
-    case glslang::EOpImageAtomicAnd:
-    case glslang::EOpAtomicCounterAnd:
+    case qglslang::EOpAtomicAnd:
+    case qglslang::EOpImageAtomicAnd:
+    case qglslang::EOpAtomicCounterAnd:
         opCode = spv::OpAtomicAnd;
         break;
-    case glslang::EOpAtomicOr:
-    case glslang::EOpImageAtomicOr:
-    case glslang::EOpAtomicCounterOr:
+    case qglslang::EOpAtomicOr:
+    case qglslang::EOpImageAtomicOr:
+    case qglslang::EOpAtomicCounterOr:
         opCode = spv::OpAtomicOr;
         break;
-    case glslang::EOpAtomicXor:
-    case glslang::EOpImageAtomicXor:
-    case glslang::EOpAtomicCounterXor:
+    case qglslang::EOpAtomicXor:
+    case qglslang::EOpImageAtomicXor:
+    case qglslang::EOpAtomicCounterXor:
         opCode = spv::OpAtomicXor;
         break;
-    case glslang::EOpAtomicExchange:
-    case glslang::EOpImageAtomicExchange:
-    case glslang::EOpAtomicCounterExchange:
+    case qglslang::EOpAtomicExchange:
+    case qglslang::EOpImageAtomicExchange:
+    case qglslang::EOpAtomicCounterExchange:
         opCode = spv::OpAtomicExchange;
         break;
-    case glslang::EOpAtomicCompSwap:
-    case glslang::EOpImageAtomicCompSwap:
-    case glslang::EOpAtomicCounterCompSwap:
+    case qglslang::EOpAtomicCompSwap:
+    case qglslang::EOpImageAtomicCompSwap:
+    case qglslang::EOpAtomicCounterCompSwap:
         opCode = spv::OpAtomicCompareExchange;
         break;
-    case glslang::EOpAtomicCounterIncrement:
+    case qglslang::EOpAtomicCounterIncrement:
         opCode = spv::OpAtomicIIncrement;
         break;
-    case glslang::EOpAtomicCounterDecrement:
+    case qglslang::EOpAtomicCounterDecrement:
         opCode = spv::OpAtomicIDecrement;
         break;
-    case glslang::EOpAtomicCounter:
-    case glslang::EOpImageAtomicLoad:
-    case glslang::EOpAtomicLoad:
+    case qglslang::EOpAtomicCounter:
+    case qglslang::EOpImageAtomicLoad:
+    case qglslang::EOpAtomicLoad:
         opCode = spv::OpAtomicLoad;
         break;
-    case glslang::EOpAtomicStore:
-    case glslang::EOpImageAtomicStore:
+    case qglslang::EOpAtomicStore:
+    case qglslang::EOpImageAtomicStore:
         opCode = spv::OpAtomicStore;
         break;
     default:
@@ -7367,7 +7367,7 @@ spv::Id TGlslangToSpvTraverser::createAtomicOperation(glslang::TOperator op, spv
         break;
     }
 
-    if (typeProxy == glslang::EbtInt64 || typeProxy == glslang::EbtUint64)
+    if (typeProxy == qglslang::EbtInt64 || typeProxy == qglslang::EbtUint64)
         builder.addCapability(spv::CapabilityInt64Atomics);
 
     // Sort out the operands
@@ -7457,7 +7457,7 @@ spv::Id TGlslangToSpvTraverser::createAtomicOperation(glslang::TOperator op, spv
 
         // GLSL and HLSL atomic-counter decrement return post-decrement value,
         // while SPIR-V returns pre-decrement value. Translate between these semantics.
-        if (op == glslang::EOpAtomicCounterDecrement)
+        if (op == qglslang::EOpAtomicCounterDecrement)
             resultId = builder.createBinOp(spv::OpISub, typeId, resultId, builder.makeIntConstant(1));
 
         return resultId;
@@ -7465,8 +7465,8 @@ spv::Id TGlslangToSpvTraverser::createAtomicOperation(glslang::TOperator op, spv
 }
 
 // Create group invocation operations.
-spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op, spv::Id typeId,
-    std::vector<spv::Id>& operands, glslang::TBasicType typeProxy)
+spv::Id TGlslangToSpvTraverser::createInvocationsOperation(qglslang::TOperator op, spv::Id typeId,
+    std::vector<spv::Id>& operands, qglslang::TBasicType typeProxy)
 {
     bool isUnsigned = isTypeUnsignedInt(typeProxy);
     bool isFloat = isTypeFloat(typeProxy);
@@ -7475,51 +7475,51 @@ spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op
     std::vector<spv::IdImmediate> spvGroupOperands;
     spv::GroupOperation groupOperation = spv::GroupOperationMax;
 
-    if (op == glslang::EOpBallot || op == glslang::EOpReadFirstInvocation ||
-        op == glslang::EOpReadInvocation) {
+    if (op == qglslang::EOpBallot || op == qglslang::EOpReadFirstInvocation ||
+        op == qglslang::EOpReadInvocation) {
         builder.addExtension(spv::E_SPV_KHR_shader_ballot);
         builder.addCapability(spv::CapabilitySubgroupBallotKHR);
-    } else if (op == glslang::EOpAnyInvocation ||
-        op == glslang::EOpAllInvocations ||
-        op == glslang::EOpAllInvocationsEqual) {
+    } else if (op == qglslang::EOpAnyInvocation ||
+        op == qglslang::EOpAllInvocations ||
+        op == qglslang::EOpAllInvocationsEqual) {
         builder.addExtension(spv::E_SPV_KHR_subgroup_vote);
         builder.addCapability(spv::CapabilitySubgroupVoteKHR);
     } else {
         builder.addCapability(spv::CapabilityGroups);
-        if (op == glslang::EOpMinInvocationsNonUniform ||
-            op == glslang::EOpMaxInvocationsNonUniform ||
-            op == glslang::EOpAddInvocationsNonUniform ||
-            op == glslang::EOpMinInvocationsInclusiveScanNonUniform ||
-            op == glslang::EOpMaxInvocationsInclusiveScanNonUniform ||
-            op == glslang::EOpAddInvocationsInclusiveScanNonUniform ||
-            op == glslang::EOpMinInvocationsExclusiveScanNonUniform ||
-            op == glslang::EOpMaxInvocationsExclusiveScanNonUniform ||
-            op == glslang::EOpAddInvocationsExclusiveScanNonUniform)
+        if (op == qglslang::EOpMinInvocationsNonUniform ||
+            op == qglslang::EOpMaxInvocationsNonUniform ||
+            op == qglslang::EOpAddInvocationsNonUniform ||
+            op == qglslang::EOpMinInvocationsInclusiveScanNonUniform ||
+            op == qglslang::EOpMaxInvocationsInclusiveScanNonUniform ||
+            op == qglslang::EOpAddInvocationsInclusiveScanNonUniform ||
+            op == qglslang::EOpMinInvocationsExclusiveScanNonUniform ||
+            op == qglslang::EOpMaxInvocationsExclusiveScanNonUniform ||
+            op == qglslang::EOpAddInvocationsExclusiveScanNonUniform)
             builder.addExtension(spv::E_SPV_AMD_shader_ballot);
 
         switch (op) {
-        case glslang::EOpMinInvocations:
-        case glslang::EOpMaxInvocations:
-        case glslang::EOpAddInvocations:
-        case glslang::EOpMinInvocationsNonUniform:
-        case glslang::EOpMaxInvocationsNonUniform:
-        case glslang::EOpAddInvocationsNonUniform:
+        case qglslang::EOpMinInvocations:
+        case qglslang::EOpMaxInvocations:
+        case qglslang::EOpAddInvocations:
+        case qglslang::EOpMinInvocationsNonUniform:
+        case qglslang::EOpMaxInvocationsNonUniform:
+        case qglslang::EOpAddInvocationsNonUniform:
             groupOperation = spv::GroupOperationReduce;
             break;
-        case glslang::EOpMinInvocationsInclusiveScan:
-        case glslang::EOpMaxInvocationsInclusiveScan:
-        case glslang::EOpAddInvocationsInclusiveScan:
-        case glslang::EOpMinInvocationsInclusiveScanNonUniform:
-        case glslang::EOpMaxInvocationsInclusiveScanNonUniform:
-        case glslang::EOpAddInvocationsInclusiveScanNonUniform:
+        case qglslang::EOpMinInvocationsInclusiveScan:
+        case qglslang::EOpMaxInvocationsInclusiveScan:
+        case qglslang::EOpAddInvocationsInclusiveScan:
+        case qglslang::EOpMinInvocationsInclusiveScanNonUniform:
+        case qglslang::EOpMaxInvocationsInclusiveScanNonUniform:
+        case qglslang::EOpAddInvocationsInclusiveScanNonUniform:
             groupOperation = spv::GroupOperationInclusiveScan;
             break;
-        case glslang::EOpMinInvocationsExclusiveScan:
-        case glslang::EOpMaxInvocationsExclusiveScan:
-        case glslang::EOpAddInvocationsExclusiveScan:
-        case glslang::EOpMinInvocationsExclusiveScanNonUniform:
-        case glslang::EOpMaxInvocationsExclusiveScanNonUniform:
-        case glslang::EOpAddInvocationsExclusiveScanNonUniform:
+        case qglslang::EOpMinInvocationsExclusiveScan:
+        case qglslang::EOpMaxInvocationsExclusiveScan:
+        case qglslang::EOpAddInvocationsExclusiveScan:
+        case qglslang::EOpMinInvocationsExclusiveScanNonUniform:
+        case qglslang::EOpMaxInvocationsExclusiveScanNonUniform:
+        case qglslang::EOpAddInvocationsExclusiveScanNonUniform:
             groupOperation = spv::GroupOperationExclusiveScan;
             break;
         default:
@@ -7539,26 +7539,26 @@ spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op
     }
 
     switch (op) {
-    case glslang::EOpAnyInvocation:
+    case qglslang::EOpAnyInvocation:
         opCode = spv::OpSubgroupAnyKHR;
         break;
-    case glslang::EOpAllInvocations:
+    case qglslang::EOpAllInvocations:
         opCode = spv::OpSubgroupAllKHR;
         break;
-    case glslang::EOpAllInvocationsEqual:
+    case qglslang::EOpAllInvocationsEqual:
         opCode = spv::OpSubgroupAllEqualKHR;
         break;
-    case glslang::EOpReadInvocation:
+    case qglslang::EOpReadInvocation:
         opCode = spv::OpSubgroupReadInvocationKHR;
         if (builder.isVectorType(typeId))
             return CreateInvocationsVectorOperation(opCode, groupOperation, typeId, operands);
         break;
-    case glslang::EOpReadFirstInvocation:
+    case qglslang::EOpReadFirstInvocation:
         opCode = spv::OpSubgroupFirstInvocationKHR;
         if (builder.isVectorType(typeId))
             return CreateInvocationsVectorOperation(opCode, groupOperation, typeId, operands);
         break;
-    case glslang::EOpBallot:
+    case qglslang::EOpBallot:
     {
         // NOTE: According to the spec, the result type of "OpSubgroupBallotKHR" must be a 4 component vector of 32
         // bit integer types. The GLSL built-in function "ballotARB()" assumes the maximum number of invocations in
@@ -7579,18 +7579,18 @@ spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op
                                      builder.createCompositeConstruct(uvec2Type, components));
     }
 
-    case glslang::EOpMinInvocations:
-    case glslang::EOpMaxInvocations:
-    case glslang::EOpAddInvocations:
-    case glslang::EOpMinInvocationsInclusiveScan:
-    case glslang::EOpMaxInvocationsInclusiveScan:
-    case glslang::EOpAddInvocationsInclusiveScan:
-    case glslang::EOpMinInvocationsExclusiveScan:
-    case glslang::EOpMaxInvocationsExclusiveScan:
-    case glslang::EOpAddInvocationsExclusiveScan:
-        if (op == glslang::EOpMinInvocations ||
-            op == glslang::EOpMinInvocationsInclusiveScan ||
-            op == glslang::EOpMinInvocationsExclusiveScan) {
+    case qglslang::EOpMinInvocations:
+    case qglslang::EOpMaxInvocations:
+    case qglslang::EOpAddInvocations:
+    case qglslang::EOpMinInvocationsInclusiveScan:
+    case qglslang::EOpMaxInvocationsInclusiveScan:
+    case qglslang::EOpAddInvocationsInclusiveScan:
+    case qglslang::EOpMinInvocationsExclusiveScan:
+    case qglslang::EOpMaxInvocationsExclusiveScan:
+    case qglslang::EOpAddInvocationsExclusiveScan:
+        if (op == qglslang::EOpMinInvocations ||
+            op == qglslang::EOpMinInvocationsInclusiveScan ||
+            op == qglslang::EOpMinInvocationsExclusiveScan) {
             if (isFloat)
                 opCode = spv::OpGroupFMin;
             else {
@@ -7599,9 +7599,9 @@ spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op
                 else
                     opCode = spv::OpGroupSMin;
             }
-        } else if (op == glslang::EOpMaxInvocations ||
-                   op == glslang::EOpMaxInvocationsInclusiveScan ||
-                   op == glslang::EOpMaxInvocationsExclusiveScan) {
+        } else if (op == qglslang::EOpMaxInvocations ||
+                   op == qglslang::EOpMaxInvocationsInclusiveScan ||
+                   op == qglslang::EOpMaxInvocationsExclusiveScan) {
             if (isFloat)
                 opCode = spv::OpGroupFMax;
             else {
@@ -7621,18 +7621,18 @@ spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op
             return CreateInvocationsVectorOperation(opCode, groupOperation, typeId, operands);
 
         break;
-    case glslang::EOpMinInvocationsNonUniform:
-    case glslang::EOpMaxInvocationsNonUniform:
-    case glslang::EOpAddInvocationsNonUniform:
-    case glslang::EOpMinInvocationsInclusiveScanNonUniform:
-    case glslang::EOpMaxInvocationsInclusiveScanNonUniform:
-    case glslang::EOpAddInvocationsInclusiveScanNonUniform:
-    case glslang::EOpMinInvocationsExclusiveScanNonUniform:
-    case glslang::EOpMaxInvocationsExclusiveScanNonUniform:
-    case glslang::EOpAddInvocationsExclusiveScanNonUniform:
-        if (op == glslang::EOpMinInvocationsNonUniform ||
-            op == glslang::EOpMinInvocationsInclusiveScanNonUniform ||
-            op == glslang::EOpMinInvocationsExclusiveScanNonUniform) {
+    case qglslang::EOpMinInvocationsNonUniform:
+    case qglslang::EOpMaxInvocationsNonUniform:
+    case qglslang::EOpAddInvocationsNonUniform:
+    case qglslang::EOpMinInvocationsInclusiveScanNonUniform:
+    case qglslang::EOpMaxInvocationsInclusiveScanNonUniform:
+    case qglslang::EOpAddInvocationsInclusiveScanNonUniform:
+    case qglslang::EOpMinInvocationsExclusiveScanNonUniform:
+    case qglslang::EOpMaxInvocationsExclusiveScanNonUniform:
+    case qglslang::EOpAddInvocationsExclusiveScanNonUniform:
+        if (op == qglslang::EOpMinInvocationsNonUniform ||
+            op == qglslang::EOpMinInvocationsInclusiveScanNonUniform ||
+            op == qglslang::EOpMinInvocationsExclusiveScanNonUniform) {
             if (isFloat)
                 opCode = spv::OpGroupFMinNonUniformAMD;
             else {
@@ -7642,9 +7642,9 @@ spv::Id TGlslangToSpvTraverser::createInvocationsOperation(glslang::TOperator op
                     opCode = spv::OpGroupSMinNonUniformAMD;
             }
         }
-        else if (op == glslang::EOpMaxInvocationsNonUniform ||
-                 op == glslang::EOpMaxInvocationsInclusiveScanNonUniform ||
-                 op == glslang::EOpMaxInvocationsExclusiveScanNonUniform) {
+        else if (op == qglslang::EOpMaxInvocationsNonUniform ||
+                 op == qglslang::EOpMaxInvocationsInclusiveScanNonUniform ||
+                 op == qglslang::EOpMaxInvocationsExclusiveScanNonUniform) {
             if (isFloat)
                 opCode = spv::OpGroupFMaxNonUniformAMD;
             else {
@@ -7734,105 +7734,105 @@ spv::Id TGlslangToSpvTraverser::CreateInvocationsVectorOperation(spv::Op op, spv
 }
 
 // Create subgroup invocation operations.
-spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, spv::Id typeId,
-    std::vector<spv::Id>& operands, glslang::TBasicType typeProxy)
+spv::Id TGlslangToSpvTraverser::createSubgroupOperation(qglslang::TOperator op, spv::Id typeId,
+    std::vector<spv::Id>& operands, qglslang::TBasicType typeProxy)
 {
     // Add the required capabilities.
     switch (op) {
-    case glslang::EOpSubgroupElect:
+    case qglslang::EOpSubgroupElect:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         break;
-    case glslang::EOpSubgroupAll:
-    case glslang::EOpSubgroupAny:
-    case glslang::EOpSubgroupAllEqual:
+    case qglslang::EOpSubgroupAll:
+    case qglslang::EOpSubgroupAny:
+    case qglslang::EOpSubgroupAllEqual:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformVote);
         break;
-    case glslang::EOpSubgroupBroadcast:
-    case glslang::EOpSubgroupBroadcastFirst:
-    case glslang::EOpSubgroupBallot:
-    case glslang::EOpSubgroupInverseBallot:
-    case glslang::EOpSubgroupBallotBitExtract:
-    case glslang::EOpSubgroupBallotBitCount:
-    case glslang::EOpSubgroupBallotInclusiveBitCount:
-    case glslang::EOpSubgroupBallotExclusiveBitCount:
-    case glslang::EOpSubgroupBallotFindLSB:
-    case glslang::EOpSubgroupBallotFindMSB:
+    case qglslang::EOpSubgroupBroadcast:
+    case qglslang::EOpSubgroupBroadcastFirst:
+    case qglslang::EOpSubgroupBallot:
+    case qglslang::EOpSubgroupInverseBallot:
+    case qglslang::EOpSubgroupBallotBitExtract:
+    case qglslang::EOpSubgroupBallotBitCount:
+    case qglslang::EOpSubgroupBallotInclusiveBitCount:
+    case qglslang::EOpSubgroupBallotExclusiveBitCount:
+    case qglslang::EOpSubgroupBallotFindLSB:
+    case qglslang::EOpSubgroupBallotFindMSB:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformBallot);
         break;
-    case glslang::EOpSubgroupShuffle:
-    case glslang::EOpSubgroupShuffleXor:
+    case qglslang::EOpSubgroupShuffle:
+    case qglslang::EOpSubgroupShuffleXor:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformShuffle);
         break;
-    case glslang::EOpSubgroupShuffleUp:
-    case glslang::EOpSubgroupShuffleDown:
+    case qglslang::EOpSubgroupShuffleUp:
+    case qglslang::EOpSubgroupShuffleDown:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformShuffleRelative);
         break;
-    case glslang::EOpSubgroupAdd:
-    case glslang::EOpSubgroupMul:
-    case glslang::EOpSubgroupMin:
-    case glslang::EOpSubgroupMax:
-    case glslang::EOpSubgroupAnd:
-    case glslang::EOpSubgroupOr:
-    case glslang::EOpSubgroupXor:
-    case glslang::EOpSubgroupInclusiveAdd:
-    case glslang::EOpSubgroupInclusiveMul:
-    case glslang::EOpSubgroupInclusiveMin:
-    case glslang::EOpSubgroupInclusiveMax:
-    case glslang::EOpSubgroupInclusiveAnd:
-    case glslang::EOpSubgroupInclusiveOr:
-    case glslang::EOpSubgroupInclusiveXor:
-    case glslang::EOpSubgroupExclusiveAdd:
-    case glslang::EOpSubgroupExclusiveMul:
-    case glslang::EOpSubgroupExclusiveMin:
-    case glslang::EOpSubgroupExclusiveMax:
-    case glslang::EOpSubgroupExclusiveAnd:
-    case glslang::EOpSubgroupExclusiveOr:
-    case glslang::EOpSubgroupExclusiveXor:
+    case qglslang::EOpSubgroupAdd:
+    case qglslang::EOpSubgroupMul:
+    case qglslang::EOpSubgroupMin:
+    case qglslang::EOpSubgroupMax:
+    case qglslang::EOpSubgroupAnd:
+    case qglslang::EOpSubgroupOr:
+    case qglslang::EOpSubgroupXor:
+    case qglslang::EOpSubgroupInclusiveAdd:
+    case qglslang::EOpSubgroupInclusiveMul:
+    case qglslang::EOpSubgroupInclusiveMin:
+    case qglslang::EOpSubgroupInclusiveMax:
+    case qglslang::EOpSubgroupInclusiveAnd:
+    case qglslang::EOpSubgroupInclusiveOr:
+    case qglslang::EOpSubgroupInclusiveXor:
+    case qglslang::EOpSubgroupExclusiveAdd:
+    case qglslang::EOpSubgroupExclusiveMul:
+    case qglslang::EOpSubgroupExclusiveMin:
+    case qglslang::EOpSubgroupExclusiveMax:
+    case qglslang::EOpSubgroupExclusiveAnd:
+    case qglslang::EOpSubgroupExclusiveOr:
+    case qglslang::EOpSubgroupExclusiveXor:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformArithmetic);
         break;
-    case glslang::EOpSubgroupClusteredAdd:
-    case glslang::EOpSubgroupClusteredMul:
-    case glslang::EOpSubgroupClusteredMin:
-    case glslang::EOpSubgroupClusteredMax:
-    case glslang::EOpSubgroupClusteredAnd:
-    case glslang::EOpSubgroupClusteredOr:
-    case glslang::EOpSubgroupClusteredXor:
+    case qglslang::EOpSubgroupClusteredAdd:
+    case qglslang::EOpSubgroupClusteredMul:
+    case qglslang::EOpSubgroupClusteredMin:
+    case qglslang::EOpSubgroupClusteredMax:
+    case qglslang::EOpSubgroupClusteredAnd:
+    case qglslang::EOpSubgroupClusteredOr:
+    case qglslang::EOpSubgroupClusteredXor:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformClustered);
         break;
-    case glslang::EOpSubgroupQuadBroadcast:
-    case glslang::EOpSubgroupQuadSwapHorizontal:
-    case glslang::EOpSubgroupQuadSwapVertical:
-    case glslang::EOpSubgroupQuadSwapDiagonal:
+    case qglslang::EOpSubgroupQuadBroadcast:
+    case qglslang::EOpSubgroupQuadSwapHorizontal:
+    case qglslang::EOpSubgroupQuadSwapVertical:
+    case qglslang::EOpSubgroupQuadSwapDiagonal:
         builder.addCapability(spv::CapabilityGroupNonUniform);
         builder.addCapability(spv::CapabilityGroupNonUniformQuad);
         break;
-    case glslang::EOpSubgroupPartitionedAdd:
-    case glslang::EOpSubgroupPartitionedMul:
-    case glslang::EOpSubgroupPartitionedMin:
-    case glslang::EOpSubgroupPartitionedMax:
-    case glslang::EOpSubgroupPartitionedAnd:
-    case glslang::EOpSubgroupPartitionedOr:
-    case glslang::EOpSubgroupPartitionedXor:
-    case glslang::EOpSubgroupPartitionedInclusiveAdd:
-    case glslang::EOpSubgroupPartitionedInclusiveMul:
-    case glslang::EOpSubgroupPartitionedInclusiveMin:
-    case glslang::EOpSubgroupPartitionedInclusiveMax:
-    case glslang::EOpSubgroupPartitionedInclusiveAnd:
-    case glslang::EOpSubgroupPartitionedInclusiveOr:
-    case glslang::EOpSubgroupPartitionedInclusiveXor:
-    case glslang::EOpSubgroupPartitionedExclusiveAdd:
-    case glslang::EOpSubgroupPartitionedExclusiveMul:
-    case glslang::EOpSubgroupPartitionedExclusiveMin:
-    case glslang::EOpSubgroupPartitionedExclusiveMax:
-    case glslang::EOpSubgroupPartitionedExclusiveAnd:
-    case glslang::EOpSubgroupPartitionedExclusiveOr:
-    case glslang::EOpSubgroupPartitionedExclusiveXor:
+    case qglslang::EOpSubgroupPartitionedAdd:
+    case qglslang::EOpSubgroupPartitionedMul:
+    case qglslang::EOpSubgroupPartitionedMin:
+    case qglslang::EOpSubgroupPartitionedMax:
+    case qglslang::EOpSubgroupPartitionedAnd:
+    case qglslang::EOpSubgroupPartitionedOr:
+    case qglslang::EOpSubgroupPartitionedXor:
+    case qglslang::EOpSubgroupPartitionedInclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedInclusiveMul:
+    case qglslang::EOpSubgroupPartitionedInclusiveMin:
+    case qglslang::EOpSubgroupPartitionedInclusiveMax:
+    case qglslang::EOpSubgroupPartitionedInclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedInclusiveOr:
+    case qglslang::EOpSubgroupPartitionedInclusiveXor:
+    case qglslang::EOpSubgroupPartitionedExclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedExclusiveMul:
+    case qglslang::EOpSubgroupPartitionedExclusiveMin:
+    case qglslang::EOpSubgroupPartitionedExclusiveMax:
+    case qglslang::EOpSubgroupPartitionedExclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedExclusiveOr:
+    case qglslang::EOpSubgroupPartitionedExclusiveXor:
         builder.addExtension(spv::E_SPV_NV_shader_subgroup_partitioned);
         builder.addCapability(spv::CapabilityGroupNonUniformPartitionedNV);
         break;
@@ -7842,63 +7842,63 @@ spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, s
 
     const bool isUnsigned = isTypeUnsignedInt(typeProxy);
     const bool isFloat = isTypeFloat(typeProxy);
-    const bool isBool = typeProxy == glslang::EbtBool;
+    const bool isBool = typeProxy == qglslang::EbtBool;
 
     spv::Op opCode = spv::OpNop;
 
     // Figure out which opcode to use.
     switch (op) {
-    case glslang::EOpSubgroupElect:                   opCode = spv::OpGroupNonUniformElect; break;
-    case glslang::EOpSubgroupAll:                     opCode = spv::OpGroupNonUniformAll; break;
-    case glslang::EOpSubgroupAny:                     opCode = spv::OpGroupNonUniformAny; break;
-    case glslang::EOpSubgroupAllEqual:                opCode = spv::OpGroupNonUniformAllEqual; break;
-    case glslang::EOpSubgroupBroadcast:               opCode = spv::OpGroupNonUniformBroadcast; break;
-    case glslang::EOpSubgroupBroadcastFirst:          opCode = spv::OpGroupNonUniformBroadcastFirst; break;
-    case glslang::EOpSubgroupBallot:                  opCode = spv::OpGroupNonUniformBallot; break;
-    case glslang::EOpSubgroupInverseBallot:           opCode = spv::OpGroupNonUniformInverseBallot; break;
-    case glslang::EOpSubgroupBallotBitExtract:        opCode = spv::OpGroupNonUniformBallotBitExtract; break;
-    case glslang::EOpSubgroupBallotBitCount:
-    case glslang::EOpSubgroupBallotInclusiveBitCount:
-    case glslang::EOpSubgroupBallotExclusiveBitCount: opCode = spv::OpGroupNonUniformBallotBitCount; break;
-    case glslang::EOpSubgroupBallotFindLSB:           opCode = spv::OpGroupNonUniformBallotFindLSB; break;
-    case glslang::EOpSubgroupBallotFindMSB:           opCode = spv::OpGroupNonUniformBallotFindMSB; break;
-    case glslang::EOpSubgroupShuffle:                 opCode = spv::OpGroupNonUniformShuffle; break;
-    case glslang::EOpSubgroupShuffleXor:              opCode = spv::OpGroupNonUniformShuffleXor; break;
-    case glslang::EOpSubgroupShuffleUp:               opCode = spv::OpGroupNonUniformShuffleUp; break;
-    case glslang::EOpSubgroupShuffleDown:             opCode = spv::OpGroupNonUniformShuffleDown; break;
-    case glslang::EOpSubgroupAdd:
-    case glslang::EOpSubgroupInclusiveAdd:
-    case glslang::EOpSubgroupExclusiveAdd:
-    case glslang::EOpSubgroupClusteredAdd:
-    case glslang::EOpSubgroupPartitionedAdd:
-    case glslang::EOpSubgroupPartitionedInclusiveAdd:
-    case glslang::EOpSubgroupPartitionedExclusiveAdd:
+    case qglslang::EOpSubgroupElect:                   opCode = spv::OpGroupNonUniformElect; break;
+    case qglslang::EOpSubgroupAll:                     opCode = spv::OpGroupNonUniformAll; break;
+    case qglslang::EOpSubgroupAny:                     opCode = spv::OpGroupNonUniformAny; break;
+    case qglslang::EOpSubgroupAllEqual:                opCode = spv::OpGroupNonUniformAllEqual; break;
+    case qglslang::EOpSubgroupBroadcast:               opCode = spv::OpGroupNonUniformBroadcast; break;
+    case qglslang::EOpSubgroupBroadcastFirst:          opCode = spv::OpGroupNonUniformBroadcastFirst; break;
+    case qglslang::EOpSubgroupBallot:                  opCode = spv::OpGroupNonUniformBallot; break;
+    case qglslang::EOpSubgroupInverseBallot:           opCode = spv::OpGroupNonUniformInverseBallot; break;
+    case qglslang::EOpSubgroupBallotBitExtract:        opCode = spv::OpGroupNonUniformBallotBitExtract; break;
+    case qglslang::EOpSubgroupBallotBitCount:
+    case qglslang::EOpSubgroupBallotInclusiveBitCount:
+    case qglslang::EOpSubgroupBallotExclusiveBitCount: opCode = spv::OpGroupNonUniformBallotBitCount; break;
+    case qglslang::EOpSubgroupBallotFindLSB:           opCode = spv::OpGroupNonUniformBallotFindLSB; break;
+    case qglslang::EOpSubgroupBallotFindMSB:           opCode = spv::OpGroupNonUniformBallotFindMSB; break;
+    case qglslang::EOpSubgroupShuffle:                 opCode = spv::OpGroupNonUniformShuffle; break;
+    case qglslang::EOpSubgroupShuffleXor:              opCode = spv::OpGroupNonUniformShuffleXor; break;
+    case qglslang::EOpSubgroupShuffleUp:               opCode = spv::OpGroupNonUniformShuffleUp; break;
+    case qglslang::EOpSubgroupShuffleDown:             opCode = spv::OpGroupNonUniformShuffleDown; break;
+    case qglslang::EOpSubgroupAdd:
+    case qglslang::EOpSubgroupInclusiveAdd:
+    case qglslang::EOpSubgroupExclusiveAdd:
+    case qglslang::EOpSubgroupClusteredAdd:
+    case qglslang::EOpSubgroupPartitionedAdd:
+    case qglslang::EOpSubgroupPartitionedInclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedExclusiveAdd:
         if (isFloat) {
             opCode = spv::OpGroupNonUniformFAdd;
         } else {
             opCode = spv::OpGroupNonUniformIAdd;
         }
         break;
-    case glslang::EOpSubgroupMul:
-    case glslang::EOpSubgroupInclusiveMul:
-    case glslang::EOpSubgroupExclusiveMul:
-    case glslang::EOpSubgroupClusteredMul:
-    case glslang::EOpSubgroupPartitionedMul:
-    case glslang::EOpSubgroupPartitionedInclusiveMul:
-    case glslang::EOpSubgroupPartitionedExclusiveMul:
+    case qglslang::EOpSubgroupMul:
+    case qglslang::EOpSubgroupInclusiveMul:
+    case qglslang::EOpSubgroupExclusiveMul:
+    case qglslang::EOpSubgroupClusteredMul:
+    case qglslang::EOpSubgroupPartitionedMul:
+    case qglslang::EOpSubgroupPartitionedInclusiveMul:
+    case qglslang::EOpSubgroupPartitionedExclusiveMul:
         if (isFloat) {
             opCode = spv::OpGroupNonUniformFMul;
         } else {
             opCode = spv::OpGroupNonUniformIMul;
         }
         break;
-    case glslang::EOpSubgroupMin:
-    case glslang::EOpSubgroupInclusiveMin:
-    case glslang::EOpSubgroupExclusiveMin:
-    case glslang::EOpSubgroupClusteredMin:
-    case glslang::EOpSubgroupPartitionedMin:
-    case glslang::EOpSubgroupPartitionedInclusiveMin:
-    case glslang::EOpSubgroupPartitionedExclusiveMin:
+    case qglslang::EOpSubgroupMin:
+    case qglslang::EOpSubgroupInclusiveMin:
+    case qglslang::EOpSubgroupExclusiveMin:
+    case qglslang::EOpSubgroupClusteredMin:
+    case qglslang::EOpSubgroupPartitionedMin:
+    case qglslang::EOpSubgroupPartitionedInclusiveMin:
+    case qglslang::EOpSubgroupPartitionedExclusiveMin:
         if (isFloat) {
             opCode = spv::OpGroupNonUniformFMin;
         } else if (isUnsigned) {
@@ -7907,13 +7907,13 @@ spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, s
             opCode = spv::OpGroupNonUniformSMin;
         }
         break;
-    case glslang::EOpSubgroupMax:
-    case glslang::EOpSubgroupInclusiveMax:
-    case glslang::EOpSubgroupExclusiveMax:
-    case glslang::EOpSubgroupClusteredMax:
-    case glslang::EOpSubgroupPartitionedMax:
-    case glslang::EOpSubgroupPartitionedInclusiveMax:
-    case glslang::EOpSubgroupPartitionedExclusiveMax:
+    case qglslang::EOpSubgroupMax:
+    case qglslang::EOpSubgroupInclusiveMax:
+    case qglslang::EOpSubgroupExclusiveMax:
+    case qglslang::EOpSubgroupClusteredMax:
+    case qglslang::EOpSubgroupPartitionedMax:
+    case qglslang::EOpSubgroupPartitionedInclusiveMax:
+    case qglslang::EOpSubgroupPartitionedExclusiveMax:
         if (isFloat) {
             opCode = spv::OpGroupNonUniformFMax;
         } else if (isUnsigned) {
@@ -7922,49 +7922,49 @@ spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, s
             opCode = spv::OpGroupNonUniformSMax;
         }
         break;
-    case glslang::EOpSubgroupAnd:
-    case glslang::EOpSubgroupInclusiveAnd:
-    case glslang::EOpSubgroupExclusiveAnd:
-    case glslang::EOpSubgroupClusteredAnd:
-    case glslang::EOpSubgroupPartitionedAnd:
-    case glslang::EOpSubgroupPartitionedInclusiveAnd:
-    case glslang::EOpSubgroupPartitionedExclusiveAnd:
+    case qglslang::EOpSubgroupAnd:
+    case qglslang::EOpSubgroupInclusiveAnd:
+    case qglslang::EOpSubgroupExclusiveAnd:
+    case qglslang::EOpSubgroupClusteredAnd:
+    case qglslang::EOpSubgroupPartitionedAnd:
+    case qglslang::EOpSubgroupPartitionedInclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedExclusiveAnd:
         if (isBool) {
             opCode = spv::OpGroupNonUniformLogicalAnd;
         } else {
             opCode = spv::OpGroupNonUniformBitwiseAnd;
         }
         break;
-    case glslang::EOpSubgroupOr:
-    case glslang::EOpSubgroupInclusiveOr:
-    case glslang::EOpSubgroupExclusiveOr:
-    case glslang::EOpSubgroupClusteredOr:
-    case glslang::EOpSubgroupPartitionedOr:
-    case glslang::EOpSubgroupPartitionedInclusiveOr:
-    case glslang::EOpSubgroupPartitionedExclusiveOr:
+    case qglslang::EOpSubgroupOr:
+    case qglslang::EOpSubgroupInclusiveOr:
+    case qglslang::EOpSubgroupExclusiveOr:
+    case qglslang::EOpSubgroupClusteredOr:
+    case qglslang::EOpSubgroupPartitionedOr:
+    case qglslang::EOpSubgroupPartitionedInclusiveOr:
+    case qglslang::EOpSubgroupPartitionedExclusiveOr:
         if (isBool) {
             opCode = spv::OpGroupNonUniformLogicalOr;
         } else {
             opCode = spv::OpGroupNonUniformBitwiseOr;
         }
         break;
-    case glslang::EOpSubgroupXor:
-    case glslang::EOpSubgroupInclusiveXor:
-    case glslang::EOpSubgroupExclusiveXor:
-    case glslang::EOpSubgroupClusteredXor:
-    case glslang::EOpSubgroupPartitionedXor:
-    case glslang::EOpSubgroupPartitionedInclusiveXor:
-    case glslang::EOpSubgroupPartitionedExclusiveXor:
+    case qglslang::EOpSubgroupXor:
+    case qglslang::EOpSubgroupInclusiveXor:
+    case qglslang::EOpSubgroupExclusiveXor:
+    case qglslang::EOpSubgroupClusteredXor:
+    case qglslang::EOpSubgroupPartitionedXor:
+    case qglslang::EOpSubgroupPartitionedInclusiveXor:
+    case qglslang::EOpSubgroupPartitionedExclusiveXor:
         if (isBool) {
             opCode = spv::OpGroupNonUniformLogicalXor;
         } else {
             opCode = spv::OpGroupNonUniformBitwiseXor;
         }
         break;
-    case glslang::EOpSubgroupQuadBroadcast:      opCode = spv::OpGroupNonUniformQuadBroadcast; break;
-    case glslang::EOpSubgroupQuadSwapHorizontal:
-    case glslang::EOpSubgroupQuadSwapVertical:
-    case glslang::EOpSubgroupQuadSwapDiagonal:   opCode = spv::OpGroupNonUniformQuadSwap; break;
+    case qglslang::EOpSubgroupQuadBroadcast:      opCode = spv::OpGroupNonUniformQuadBroadcast; break;
+    case qglslang::EOpSubgroupQuadSwapHorizontal:
+    case qglslang::EOpSubgroupQuadSwapVertical:
+    case qglslang::EOpSubgroupQuadSwapDiagonal:   opCode = spv::OpGroupNonUniformQuadSwap; break;
     default: assert(0 && "Unhandled subgroup operation!");
     }
 
@@ -7973,70 +7973,70 @@ spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, s
     switch (op) {
     default:
         break;
-    case glslang::EOpSubgroupBallotBitCount:
-    case glslang::EOpSubgroupAdd:
-    case glslang::EOpSubgroupMul:
-    case glslang::EOpSubgroupMin:
-    case glslang::EOpSubgroupMax:
-    case glslang::EOpSubgroupAnd:
-    case glslang::EOpSubgroupOr:
-    case glslang::EOpSubgroupXor:
+    case qglslang::EOpSubgroupBallotBitCount:
+    case qglslang::EOpSubgroupAdd:
+    case qglslang::EOpSubgroupMul:
+    case qglslang::EOpSubgroupMin:
+    case qglslang::EOpSubgroupMax:
+    case qglslang::EOpSubgroupAnd:
+    case qglslang::EOpSubgroupOr:
+    case qglslang::EOpSubgroupXor:
         groupOperation = spv::GroupOperationReduce;
         break;
-    case glslang::EOpSubgroupBallotInclusiveBitCount:
-    case glslang::EOpSubgroupInclusiveAdd:
-    case glslang::EOpSubgroupInclusiveMul:
-    case glslang::EOpSubgroupInclusiveMin:
-    case glslang::EOpSubgroupInclusiveMax:
-    case glslang::EOpSubgroupInclusiveAnd:
-    case glslang::EOpSubgroupInclusiveOr:
-    case glslang::EOpSubgroupInclusiveXor:
+    case qglslang::EOpSubgroupBallotInclusiveBitCount:
+    case qglslang::EOpSubgroupInclusiveAdd:
+    case qglslang::EOpSubgroupInclusiveMul:
+    case qglslang::EOpSubgroupInclusiveMin:
+    case qglslang::EOpSubgroupInclusiveMax:
+    case qglslang::EOpSubgroupInclusiveAnd:
+    case qglslang::EOpSubgroupInclusiveOr:
+    case qglslang::EOpSubgroupInclusiveXor:
         groupOperation = spv::GroupOperationInclusiveScan;
         break;
-    case glslang::EOpSubgroupBallotExclusiveBitCount:
-    case glslang::EOpSubgroupExclusiveAdd:
-    case glslang::EOpSubgroupExclusiveMul:
-    case glslang::EOpSubgroupExclusiveMin:
-    case glslang::EOpSubgroupExclusiveMax:
-    case glslang::EOpSubgroupExclusiveAnd:
-    case glslang::EOpSubgroupExclusiveOr:
-    case glslang::EOpSubgroupExclusiveXor:
+    case qglslang::EOpSubgroupBallotExclusiveBitCount:
+    case qglslang::EOpSubgroupExclusiveAdd:
+    case qglslang::EOpSubgroupExclusiveMul:
+    case qglslang::EOpSubgroupExclusiveMin:
+    case qglslang::EOpSubgroupExclusiveMax:
+    case qglslang::EOpSubgroupExclusiveAnd:
+    case qglslang::EOpSubgroupExclusiveOr:
+    case qglslang::EOpSubgroupExclusiveXor:
         groupOperation = spv::GroupOperationExclusiveScan;
         break;
-    case glslang::EOpSubgroupClusteredAdd:
-    case glslang::EOpSubgroupClusteredMul:
-    case glslang::EOpSubgroupClusteredMin:
-    case glslang::EOpSubgroupClusteredMax:
-    case glslang::EOpSubgroupClusteredAnd:
-    case glslang::EOpSubgroupClusteredOr:
-    case glslang::EOpSubgroupClusteredXor:
+    case qglslang::EOpSubgroupClusteredAdd:
+    case qglslang::EOpSubgroupClusteredMul:
+    case qglslang::EOpSubgroupClusteredMin:
+    case qglslang::EOpSubgroupClusteredMax:
+    case qglslang::EOpSubgroupClusteredAnd:
+    case qglslang::EOpSubgroupClusteredOr:
+    case qglslang::EOpSubgroupClusteredXor:
         groupOperation = spv::GroupOperationClusteredReduce;
         break;
-    case glslang::EOpSubgroupPartitionedAdd:
-    case glslang::EOpSubgroupPartitionedMul:
-    case glslang::EOpSubgroupPartitionedMin:
-    case glslang::EOpSubgroupPartitionedMax:
-    case glslang::EOpSubgroupPartitionedAnd:
-    case glslang::EOpSubgroupPartitionedOr:
-    case glslang::EOpSubgroupPartitionedXor:
+    case qglslang::EOpSubgroupPartitionedAdd:
+    case qglslang::EOpSubgroupPartitionedMul:
+    case qglslang::EOpSubgroupPartitionedMin:
+    case qglslang::EOpSubgroupPartitionedMax:
+    case qglslang::EOpSubgroupPartitionedAnd:
+    case qglslang::EOpSubgroupPartitionedOr:
+    case qglslang::EOpSubgroupPartitionedXor:
         groupOperation = spv::GroupOperationPartitionedReduceNV;
         break;
-    case glslang::EOpSubgroupPartitionedInclusiveAdd:
-    case glslang::EOpSubgroupPartitionedInclusiveMul:
-    case glslang::EOpSubgroupPartitionedInclusiveMin:
-    case glslang::EOpSubgroupPartitionedInclusiveMax:
-    case glslang::EOpSubgroupPartitionedInclusiveAnd:
-    case glslang::EOpSubgroupPartitionedInclusiveOr:
-    case glslang::EOpSubgroupPartitionedInclusiveXor:
+    case qglslang::EOpSubgroupPartitionedInclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedInclusiveMul:
+    case qglslang::EOpSubgroupPartitionedInclusiveMin:
+    case qglslang::EOpSubgroupPartitionedInclusiveMax:
+    case qglslang::EOpSubgroupPartitionedInclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedInclusiveOr:
+    case qglslang::EOpSubgroupPartitionedInclusiveXor:
         groupOperation = spv::GroupOperationPartitionedInclusiveScanNV;
         break;
-    case glslang::EOpSubgroupPartitionedExclusiveAdd:
-    case glslang::EOpSubgroupPartitionedExclusiveMul:
-    case glslang::EOpSubgroupPartitionedExclusiveMin:
-    case glslang::EOpSubgroupPartitionedExclusiveMax:
-    case glslang::EOpSubgroupPartitionedExclusiveAnd:
-    case glslang::EOpSubgroupPartitionedExclusiveOr:
-    case glslang::EOpSubgroupPartitionedExclusiveXor:
+    case qglslang::EOpSubgroupPartitionedExclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedExclusiveMul:
+    case qglslang::EOpSubgroupPartitionedExclusiveMin:
+    case qglslang::EOpSubgroupPartitionedExclusiveMax:
+    case qglslang::EOpSubgroupPartitionedExclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedExclusiveOr:
+    case qglslang::EOpSubgroupPartitionedExclusiveXor:
         groupOperation = spv::GroupOperationPartitionedExclusiveScanNV;
         break;
     }
@@ -8064,9 +8064,9 @@ spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, s
     spv::Id directionId = spv::NoResult;
     switch (op) {
     default: break;
-    case glslang::EOpSubgroupQuadSwapHorizontal: directionId = builder.makeUintConstant(0); break;
-    case glslang::EOpSubgroupQuadSwapVertical:   directionId = builder.makeUintConstant(1); break;
-    case glslang::EOpSubgroupQuadSwapDiagonal:   directionId = builder.makeUintConstant(2); break;
+    case qglslang::EOpSubgroupQuadSwapHorizontal: directionId = builder.makeUintConstant(0); break;
+    case qglslang::EOpSubgroupQuadSwapVertical:   directionId = builder.makeUintConstant(1); break;
+    case qglslang::EOpSubgroupQuadSwapDiagonal:   directionId = builder.makeUintConstant(2); break;
     }
     if (directionId != spv::NoResult) {
         spv::IdImmediate direction = { true, directionId };
@@ -8076,8 +8076,8 @@ spv::Id TGlslangToSpvTraverser::createSubgroupOperation(glslang::TOperator op, s
     return builder.createOp(opCode, typeId, spvGroupOperands);
 }
 
-spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::Decoration precision,
-    spv::Id typeId, std::vector<spv::Id>& operands, glslang::TBasicType typeProxy)
+spv::Id TGlslangToSpvTraverser::createMiscOperation(qglslang::TOperator op, spv::Decoration precision,
+    spv::Id typeId, std::vector<spv::Id>& operands, qglslang::TBasicType typeProxy)
 {
     bool isUnsigned = isTypeUnsignedInt(typeProxy);
     bool isFloat = isTypeFloat(typeProxy);
@@ -8095,7 +8095,7 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
     spv::Id frexpIntType = 0;
 
     switch (op) {
-    case glslang::EOpMin:
+    case qglslang::EOpMin:
         if (isFloat)
             libCall = nanMinMaxClamp ? spv::GLSLstd450NMin : spv::GLSLstd450FMin;
         else if (isUnsigned)
@@ -8104,10 +8104,10 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
             libCall = spv::GLSLstd450SMin;
         builder.promoteScalar(precision, operands.front(), operands.back());
         break;
-    case glslang::EOpModf:
+    case qglslang::EOpModf:
         libCall = spv::GLSLstd450Modf;
         break;
-    case glslang::EOpMax:
+    case qglslang::EOpMax:
         if (isFloat)
             libCall = nanMinMaxClamp ? spv::GLSLstd450NMax : spv::GLSLstd450FMax;
         else if (isUnsigned)
@@ -8116,17 +8116,17 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
             libCall = spv::GLSLstd450SMax;
         builder.promoteScalar(precision, operands.front(), operands.back());
         break;
-    case glslang::EOpPow:
+    case qglslang::EOpPow:
         libCall = spv::GLSLstd450Pow;
         break;
-    case glslang::EOpDot:
+    case qglslang::EOpDot:
         opCode = spv::OpDot;
         break;
-    case glslang::EOpAtan:
+    case qglslang::EOpAtan:
         libCall = spv::GLSLstd450Atan2;
         break;
 
-    case glslang::EOpClamp:
+    case qglslang::EOpClamp:
         if (isFloat)
             libCall = nanMinMaxClamp ? spv::GLSLstd450NClamp : spv::GLSLstd450FClamp;
         else if (isUnsigned)
@@ -8136,7 +8136,7 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
         builder.promoteScalar(precision, operands.front(), operands[1]);
         builder.promoteScalar(precision, operands.front(), operands[2]);
         break;
-    case glslang::EOpMix:
+    case qglslang::EOpMix:
         if (! builder.isBoolType(builder.getScalarTypeId(builder.getTypeId(operands.back())))) {
             assert(isFloat);
             libCall = spv::GLSLstd450FMix;
@@ -8146,32 +8146,32 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
         }
         builder.promoteScalar(precision, operands.front(), operands.back());
         break;
-    case glslang::EOpStep:
+    case qglslang::EOpStep:
         libCall = spv::GLSLstd450Step;
         builder.promoteScalar(precision, operands.front(), operands.back());
         break;
-    case glslang::EOpSmoothStep:
+    case qglslang::EOpSmoothStep:
         libCall = spv::GLSLstd450SmoothStep;
         builder.promoteScalar(precision, operands[0], operands[2]);
         builder.promoteScalar(precision, operands[1], operands[2]);
         break;
 
-    case glslang::EOpDistance:
+    case qglslang::EOpDistance:
         libCall = spv::GLSLstd450Distance;
         break;
-    case glslang::EOpCross:
+    case qglslang::EOpCross:
         libCall = spv::GLSLstd450Cross;
         break;
-    case glslang::EOpFaceForward:
+    case qglslang::EOpFaceForward:
         libCall = spv::GLSLstd450FaceForward;
         break;
-    case glslang::EOpReflect:
+    case qglslang::EOpReflect:
         libCall = spv::GLSLstd450Reflect;
         break;
-    case glslang::EOpRefract:
+    case qglslang::EOpRefract:
         libCall = spv::GLSLstd450Refract;
         break;
-    case glslang::EOpBarrier:
+    case qglslang::EOpBarrier:
         {
             // This is for the extended controlBarrier function, with four operands.
             // The unextended barrier() goes through createNoArgOperation.
@@ -8194,7 +8194,7 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
             return 0;
         }
         break;
-    case glslang::EOpMemoryBarrier:
+    case qglslang::EOpMemoryBarrier:
         {
             // This is for the extended memoryBarrier function, with three operands.
             // The unextended memoryBarrier() goes through createNoArgOperation.
@@ -8216,50 +8216,50 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
         break;
 
 #ifndef GLSLANG_WEB
-    case glslang::EOpInterpolateAtSample:
-        if (typeProxy == glslang::EbtFloat16)
+    case qglslang::EOpInterpolateAtSample:
+        if (typeProxy == qglslang::EbtFloat16)
             builder.addExtension(spv::E_SPV_AMD_gpu_shader_half_float);
         libCall = spv::GLSLstd450InterpolateAtSample;
         break;
-    case glslang::EOpInterpolateAtOffset:
-        if (typeProxy == glslang::EbtFloat16)
+    case qglslang::EOpInterpolateAtOffset:
+        if (typeProxy == qglslang::EbtFloat16)
             builder.addExtension(spv::E_SPV_AMD_gpu_shader_half_float);
         libCall = spv::GLSLstd450InterpolateAtOffset;
         break;
-    case glslang::EOpAddCarry:
+    case qglslang::EOpAddCarry:
         opCode = spv::OpIAddCarry;
         typeId = builder.makeStructResultType(typeId0, typeId0);
         consumedOperands = 2;
         break;
-    case glslang::EOpSubBorrow:
+    case qglslang::EOpSubBorrow:
         opCode = spv::OpISubBorrow;
         typeId = builder.makeStructResultType(typeId0, typeId0);
         consumedOperands = 2;
         break;
-    case glslang::EOpUMulExtended:
+    case qglslang::EOpUMulExtended:
         opCode = spv::OpUMulExtended;
         typeId = builder.makeStructResultType(typeId0, typeId0);
         consumedOperands = 2;
         break;
-    case glslang::EOpIMulExtended:
+    case qglslang::EOpIMulExtended:
         opCode = spv::OpSMulExtended;
         typeId = builder.makeStructResultType(typeId0, typeId0);
         consumedOperands = 2;
         break;
-    case glslang::EOpBitfieldExtract:
+    case qglslang::EOpBitfieldExtract:
         if (isUnsigned)
             opCode = spv::OpBitFieldUExtract;
         else
             opCode = spv::OpBitFieldSExtract;
         break;
-    case glslang::EOpBitfieldInsert:
+    case qglslang::EOpBitfieldInsert:
         opCode = spv::OpBitFieldInsert;
         break;
 
-    case glslang::EOpFma:
+    case qglslang::EOpFma:
         libCall = spv::GLSLstd450Fma;
         break;
-    case glslang::EOpFrexp:
+    case qglslang::EOpFrexp:
         {
             libCall = spv::GLSLstd450FrexpStruct;
             assert(builder.isPointerType(typeId1));
@@ -8277,64 +8277,64 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
             consumedOperands = 1;
         }
         break;
-    case glslang::EOpLdexp:
+    case qglslang::EOpLdexp:
         libCall = spv::GLSLstd450Ldexp;
         break;
 
-    case glslang::EOpReadInvocation:
+    case qglslang::EOpReadInvocation:
         return createInvocationsOperation(op, typeId, operands, typeProxy);
 
-    case glslang::EOpSubgroupBroadcast:
-    case glslang::EOpSubgroupBallotBitExtract:
-    case glslang::EOpSubgroupShuffle:
-    case glslang::EOpSubgroupShuffleXor:
-    case glslang::EOpSubgroupShuffleUp:
-    case glslang::EOpSubgroupShuffleDown:
-    case glslang::EOpSubgroupClusteredAdd:
-    case glslang::EOpSubgroupClusteredMul:
-    case glslang::EOpSubgroupClusteredMin:
-    case glslang::EOpSubgroupClusteredMax:
-    case glslang::EOpSubgroupClusteredAnd:
-    case glslang::EOpSubgroupClusteredOr:
-    case glslang::EOpSubgroupClusteredXor:
-    case glslang::EOpSubgroupQuadBroadcast:
-    case glslang::EOpSubgroupPartitionedAdd:
-    case glslang::EOpSubgroupPartitionedMul:
-    case glslang::EOpSubgroupPartitionedMin:
-    case glslang::EOpSubgroupPartitionedMax:
-    case glslang::EOpSubgroupPartitionedAnd:
-    case glslang::EOpSubgroupPartitionedOr:
-    case glslang::EOpSubgroupPartitionedXor:
-    case glslang::EOpSubgroupPartitionedInclusiveAdd:
-    case glslang::EOpSubgroupPartitionedInclusiveMul:
-    case glslang::EOpSubgroupPartitionedInclusiveMin:
-    case glslang::EOpSubgroupPartitionedInclusiveMax:
-    case glslang::EOpSubgroupPartitionedInclusiveAnd:
-    case glslang::EOpSubgroupPartitionedInclusiveOr:
-    case glslang::EOpSubgroupPartitionedInclusiveXor:
-    case glslang::EOpSubgroupPartitionedExclusiveAdd:
-    case glslang::EOpSubgroupPartitionedExclusiveMul:
-    case glslang::EOpSubgroupPartitionedExclusiveMin:
-    case glslang::EOpSubgroupPartitionedExclusiveMax:
-    case glslang::EOpSubgroupPartitionedExclusiveAnd:
-    case glslang::EOpSubgroupPartitionedExclusiveOr:
-    case glslang::EOpSubgroupPartitionedExclusiveXor:
+    case qglslang::EOpSubgroupBroadcast:
+    case qglslang::EOpSubgroupBallotBitExtract:
+    case qglslang::EOpSubgroupShuffle:
+    case qglslang::EOpSubgroupShuffleXor:
+    case qglslang::EOpSubgroupShuffleUp:
+    case qglslang::EOpSubgroupShuffleDown:
+    case qglslang::EOpSubgroupClusteredAdd:
+    case qglslang::EOpSubgroupClusteredMul:
+    case qglslang::EOpSubgroupClusteredMin:
+    case qglslang::EOpSubgroupClusteredMax:
+    case qglslang::EOpSubgroupClusteredAnd:
+    case qglslang::EOpSubgroupClusteredOr:
+    case qglslang::EOpSubgroupClusteredXor:
+    case qglslang::EOpSubgroupQuadBroadcast:
+    case qglslang::EOpSubgroupPartitionedAdd:
+    case qglslang::EOpSubgroupPartitionedMul:
+    case qglslang::EOpSubgroupPartitionedMin:
+    case qglslang::EOpSubgroupPartitionedMax:
+    case qglslang::EOpSubgroupPartitionedAnd:
+    case qglslang::EOpSubgroupPartitionedOr:
+    case qglslang::EOpSubgroupPartitionedXor:
+    case qglslang::EOpSubgroupPartitionedInclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedInclusiveMul:
+    case qglslang::EOpSubgroupPartitionedInclusiveMin:
+    case qglslang::EOpSubgroupPartitionedInclusiveMax:
+    case qglslang::EOpSubgroupPartitionedInclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedInclusiveOr:
+    case qglslang::EOpSubgroupPartitionedInclusiveXor:
+    case qglslang::EOpSubgroupPartitionedExclusiveAdd:
+    case qglslang::EOpSubgroupPartitionedExclusiveMul:
+    case qglslang::EOpSubgroupPartitionedExclusiveMin:
+    case qglslang::EOpSubgroupPartitionedExclusiveMax:
+    case qglslang::EOpSubgroupPartitionedExclusiveAnd:
+    case qglslang::EOpSubgroupPartitionedExclusiveOr:
+    case qglslang::EOpSubgroupPartitionedExclusiveXor:
         return createSubgroupOperation(op, typeId, operands, typeProxy);
 
-    case glslang::EOpSwizzleInvocations:
+    case qglslang::EOpSwizzleInvocations:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_ballot);
         libCall = spv::SwizzleInvocationsAMD;
         break;
-    case glslang::EOpSwizzleInvocationsMasked:
+    case qglslang::EOpSwizzleInvocationsMasked:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_ballot);
         libCall = spv::SwizzleInvocationsMaskedAMD;
         break;
-    case glslang::EOpWriteInvocation:
+    case qglslang::EOpWriteInvocation:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_ballot);
         libCall = spv::WriteInvocationAMD;
         break;
 
-    case glslang::EOpMin3:
+    case qglslang::EOpMin3:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_trinary_minmax);
         if (isFloat)
             libCall = spv::FMin3AMD;
@@ -8345,7 +8345,7 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
                 libCall = spv::SMin3AMD;
         }
         break;
-    case glslang::EOpMax3:
+    case qglslang::EOpMax3:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_trinary_minmax);
         if (isFloat)
             libCall = spv::FMax3AMD;
@@ -8356,7 +8356,7 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
                 libCall = spv::SMax3AMD;
         }
         break;
-    case glslang::EOpMid3:
+    case qglslang::EOpMid3:
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_trinary_minmax);
         if (isFloat)
             libCall = spv::FMid3AMD;
@@ -8368,127 +8368,127 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
         }
         break;
 
-    case glslang::EOpInterpolateAtVertex:
-        if (typeProxy == glslang::EbtFloat16)
+    case qglslang::EOpInterpolateAtVertex:
+        if (typeProxy == qglslang::EbtFloat16)
             builder.addExtension(spv::E_SPV_AMD_gpu_shader_half_float);
         extBuiltins = getExtBuiltins(spv::E_SPV_AMD_shader_explicit_vertex_parameter);
         libCall = spv::InterpolateAtVertexAMD;
         break;
 
-    case glslang::EOpReportIntersection:
+    case qglslang::EOpReportIntersection:
         typeId = builder.makeBoolType();
         opCode = spv::OpReportIntersectionKHR;
         break;
-    case glslang::EOpTraceNV:
+    case qglslang::EOpTraceNV:
         builder.createNoResultOp(spv::OpTraceNV, operands);
         return 0;
-    case glslang::EOpTraceRayMotionNV:
+    case qglslang::EOpTraceRayMotionNV:
         builder.addExtension(spv::E_SPV_NV_ray_tracing_motion_blur);
         builder.addCapability(spv::CapabilityRayTracingMotionBlurNV);
         builder.createNoResultOp(spv::OpTraceRayMotionNV, operands);
         return 0;
-    case glslang::EOpTraceKHR:
+    case qglslang::EOpTraceKHR:
         builder.createNoResultOp(spv::OpTraceRayKHR, operands);
         return 0;
-    case glslang::EOpExecuteCallableNV:
+    case qglslang::EOpExecuteCallableNV:
         builder.createNoResultOp(spv::OpExecuteCallableNV, operands);
         return 0;
-    case glslang::EOpExecuteCallableKHR:
+    case qglslang::EOpExecuteCallableKHR:
         builder.createNoResultOp(spv::OpExecuteCallableKHR, operands);
         return 0;
 
-    case glslang::EOpRayQueryInitialize:
+    case qglslang::EOpRayQueryInitialize:
         builder.createNoResultOp(spv::OpRayQueryInitializeKHR, operands);
         return 0;
-    case glslang::EOpRayQueryTerminate:
+    case qglslang::EOpRayQueryTerminate:
         builder.createNoResultOp(spv::OpRayQueryTerminateKHR, operands);
         return 0;
-    case glslang::EOpRayQueryGenerateIntersection:
+    case qglslang::EOpRayQueryGenerateIntersection:
         builder.createNoResultOp(spv::OpRayQueryGenerateIntersectionKHR, operands);
         return 0;
-    case glslang::EOpRayQueryConfirmIntersection:
+    case qglslang::EOpRayQueryConfirmIntersection:
         builder.createNoResultOp(spv::OpRayQueryConfirmIntersectionKHR, operands);
         return 0;
-    case glslang::EOpRayQueryProceed:
+    case qglslang::EOpRayQueryProceed:
         typeId = builder.makeBoolType();
         opCode = spv::OpRayQueryProceedKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionType:
+    case qglslang::EOpRayQueryGetIntersectionType:
         typeId = builder.makeUintType(32);
         opCode = spv::OpRayQueryGetIntersectionTypeKHR;
         break;
-    case glslang::EOpRayQueryGetRayTMin:
+    case qglslang::EOpRayQueryGetRayTMin:
         typeId = builder.makeFloatType(32);
         opCode = spv::OpRayQueryGetRayTMinKHR;
         break;
-    case glslang::EOpRayQueryGetRayFlags:
+    case qglslang::EOpRayQueryGetRayFlags:
         typeId = builder.makeIntType(32);
         opCode = spv::OpRayQueryGetRayFlagsKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionT:
+    case qglslang::EOpRayQueryGetIntersectionT:
         typeId = builder.makeFloatType(32);
         opCode = spv::OpRayQueryGetIntersectionTKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionInstanceCustomIndex:
+    case qglslang::EOpRayQueryGetIntersectionInstanceCustomIndex:
         typeId = builder.makeIntType(32);
         opCode = spv::OpRayQueryGetIntersectionInstanceCustomIndexKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionInstanceId:
+    case qglslang::EOpRayQueryGetIntersectionInstanceId:
         typeId = builder.makeIntType(32);
         opCode = spv::OpRayQueryGetIntersectionInstanceIdKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset:
+    case qglslang::EOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffset:
         typeId = builder.makeUintType(32);
         opCode = spv::OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionGeometryIndex:
+    case qglslang::EOpRayQueryGetIntersectionGeometryIndex:
         typeId = builder.makeIntType(32);
         opCode = spv::OpRayQueryGetIntersectionGeometryIndexKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionPrimitiveIndex:
+    case qglslang::EOpRayQueryGetIntersectionPrimitiveIndex:
         typeId = builder.makeIntType(32);
         opCode = spv::OpRayQueryGetIntersectionPrimitiveIndexKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionBarycentrics:
+    case qglslang::EOpRayQueryGetIntersectionBarycentrics:
         typeId = builder.makeVectorType(builder.makeFloatType(32), 2);
         opCode = spv::OpRayQueryGetIntersectionBarycentricsKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionFrontFace:
+    case qglslang::EOpRayQueryGetIntersectionFrontFace:
         typeId = builder.makeBoolType();
         opCode = spv::OpRayQueryGetIntersectionFrontFaceKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionCandidateAABBOpaque:
+    case qglslang::EOpRayQueryGetIntersectionCandidateAABBOpaque:
         typeId = builder.makeBoolType();
         opCode = spv::OpRayQueryGetIntersectionCandidateAABBOpaqueKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionObjectRayDirection:
+    case qglslang::EOpRayQueryGetIntersectionObjectRayDirection:
         typeId = builder.makeVectorType(builder.makeFloatType(32), 3);
         opCode = spv::OpRayQueryGetIntersectionObjectRayDirectionKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionObjectRayOrigin:
+    case qglslang::EOpRayQueryGetIntersectionObjectRayOrigin:
         typeId = builder.makeVectorType(builder.makeFloatType(32), 3);
         opCode = spv::OpRayQueryGetIntersectionObjectRayOriginKHR;
         break;
-    case glslang::EOpRayQueryGetWorldRayDirection:
+    case qglslang::EOpRayQueryGetWorldRayDirection:
         typeId = builder.makeVectorType(builder.makeFloatType(32), 3);
         opCode = spv::OpRayQueryGetWorldRayDirectionKHR;
         break;
-    case glslang::EOpRayQueryGetWorldRayOrigin:
+    case qglslang::EOpRayQueryGetWorldRayOrigin:
         typeId = builder.makeVectorType(builder.makeFloatType(32), 3);
         opCode = spv::OpRayQueryGetWorldRayOriginKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionObjectToWorld:
+    case qglslang::EOpRayQueryGetIntersectionObjectToWorld:
         typeId = builder.makeMatrixType(builder.makeFloatType(32), 4, 3);
         opCode = spv::OpRayQueryGetIntersectionObjectToWorldKHR;
         break;
-    case glslang::EOpRayQueryGetIntersectionWorldToObject:
+    case qglslang::EOpRayQueryGetIntersectionWorldToObject:
         typeId = builder.makeMatrixType(builder.makeFloatType(32), 4, 3);
         opCode = spv::OpRayQueryGetIntersectionWorldToObjectKHR;
         break;
-    case glslang::EOpWritePackedPrimitiveIndices4x8NV:
+    case qglslang::EOpWritePackedPrimitiveIndices4x8NV:
         builder.createNoResultOp(spv::OpWritePackedPrimitiveIndices4x8NV, operands);
         return 0;
-    case glslang::EOpCooperativeMatrixMulAdd:
+    case qglslang::EOpCooperativeMatrixMulAdd:
         opCode = spv::OpCooperativeMatrixMulAddNV;
         break;
 #endif // GLSLANG_WEB
@@ -8538,17 +8538,17 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
 #ifndef GLSLANG_WEB
     // Decode the return types that were structures
     switch (op) {
-    case glslang::EOpAddCarry:
-    case glslang::EOpSubBorrow:
+    case qglslang::EOpAddCarry:
+    case qglslang::EOpSubBorrow:
         builder.createStore(builder.createCompositeExtract(id, typeId0, 1), operands[2]);
         id = builder.createCompositeExtract(id, typeId0, 0);
         break;
-    case glslang::EOpUMulExtended:
-    case glslang::EOpIMulExtended:
+    case qglslang::EOpUMulExtended:
+    case qglslang::EOpIMulExtended:
         builder.createStore(builder.createCompositeExtract(id, typeId0, 0), operands[3]);
         builder.createStore(builder.createCompositeExtract(id, typeId0, 1), operands[2]);
         break;
-    case glslang::EOpFrexp:
+    case qglslang::EOpFrexp:
         {
             assert(operands.size() == 2);
             if (builder.isFloatType(builder.getScalarTypeId(typeId1))) {
@@ -8571,14 +8571,14 @@ spv::Id TGlslangToSpvTraverser::createMiscOperation(glslang::TOperator op, spv::
 }
 
 // Intrinsics with no arguments (or no return value, and no precision).
-spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv::Decoration precision, spv::Id typeId)
+spv::Id TGlslangToSpvTraverser::createNoArgOperation(qglslang::TOperator op, spv::Decoration precision, spv::Id typeId)
 {
     // GLSL memory barriers use queuefamily scope in new model, device scope in old model
     spv::Scope memoryBarrierScope = glslangIntermediate->usingVulkanMemoryModel() ?
         spv::ScopeQueueFamilyKHR : spv::ScopeDevice;
 
     switch (op) {
-    case glslang::EOpBarrier:
+    case qglslang::EOpBarrier:
         if (glslangIntermediate->getStage() == EShLangTessControl) {
             if (glslangIntermediate->usingVulkanMemoryModel()) {
                 builder.createControlBarrier(spv::ScopeWorkgroup, spv::ScopeWorkgroup,
@@ -8594,119 +8594,119 @@ spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv:
                                             spv::MemorySemanticsAcquireReleaseMask);
         }
         return 0;
-    case glslang::EOpMemoryBarrier:
+    case qglslang::EOpMemoryBarrier:
         builder.createMemoryBarrier(memoryBarrierScope, spv::MemorySemanticsAllMemory |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpMemoryBarrierBuffer:
+    case qglslang::EOpMemoryBarrierBuffer:
         builder.createMemoryBarrier(memoryBarrierScope, spv::MemorySemanticsUniformMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpMemoryBarrierShared:
+    case qglslang::EOpMemoryBarrierShared:
         builder.createMemoryBarrier(memoryBarrierScope, spv::MemorySemanticsWorkgroupMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpGroupMemoryBarrier:
+    case qglslang::EOpGroupMemoryBarrier:
         builder.createMemoryBarrier(spv::ScopeWorkgroup, spv::MemorySemanticsAllMemory |
                                                          spv::MemorySemanticsAcquireReleaseMask);
         return 0;
 #ifndef GLSLANG_WEB
-    case glslang::EOpMemoryBarrierAtomicCounter:
+    case qglslang::EOpMemoryBarrierAtomicCounter:
         builder.createMemoryBarrier(memoryBarrierScope, spv::MemorySemanticsAtomicCounterMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpMemoryBarrierImage:
+    case qglslang::EOpMemoryBarrierImage:
         builder.createMemoryBarrier(memoryBarrierScope, spv::MemorySemanticsImageMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpAllMemoryBarrierWithGroupSync:
+    case qglslang::EOpAllMemoryBarrierWithGroupSync:
         builder.createControlBarrier(spv::ScopeWorkgroup, spv::ScopeDevice,
                                         spv::MemorySemanticsAllMemory |
                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpDeviceMemoryBarrier:
+    case qglslang::EOpDeviceMemoryBarrier:
         builder.createMemoryBarrier(spv::ScopeDevice, spv::MemorySemanticsUniformMemoryMask |
                                                       spv::MemorySemanticsImageMemoryMask |
                                                       spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpDeviceMemoryBarrierWithGroupSync:
+    case qglslang::EOpDeviceMemoryBarrierWithGroupSync:
         builder.createControlBarrier(spv::ScopeWorkgroup, spv::ScopeDevice, spv::MemorySemanticsUniformMemoryMask |
                                                                             spv::MemorySemanticsImageMemoryMask |
                                                                             spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpWorkgroupMemoryBarrier:
+    case qglslang::EOpWorkgroupMemoryBarrier:
         builder.createMemoryBarrier(spv::ScopeWorkgroup, spv::MemorySemanticsWorkgroupMemoryMask |
                                                          spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpWorkgroupMemoryBarrierWithGroupSync:
+    case qglslang::EOpWorkgroupMemoryBarrierWithGroupSync:
         builder.createControlBarrier(spv::ScopeWorkgroup, spv::ScopeWorkgroup,
                                         spv::MemorySemanticsWorkgroupMemoryMask |
                                         spv::MemorySemanticsAcquireReleaseMask);
         return 0;
-    case glslang::EOpSubgroupBarrier:
+    case qglslang::EOpSubgroupBarrier:
         builder.createControlBarrier(spv::ScopeSubgroup, spv::ScopeSubgroup, spv::MemorySemanticsAllMemory |
                                                                              spv::MemorySemanticsAcquireReleaseMask);
         return spv::NoResult;
-    case glslang::EOpSubgroupMemoryBarrier:
+    case qglslang::EOpSubgroupMemoryBarrier:
         builder.createMemoryBarrier(spv::ScopeSubgroup, spv::MemorySemanticsAllMemory |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return spv::NoResult;
-    case glslang::EOpSubgroupMemoryBarrierBuffer:
+    case qglslang::EOpSubgroupMemoryBarrierBuffer:
         builder.createMemoryBarrier(spv::ScopeSubgroup, spv::MemorySemanticsUniformMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return spv::NoResult;
-    case glslang::EOpSubgroupMemoryBarrierImage:
+    case qglslang::EOpSubgroupMemoryBarrierImage:
         builder.createMemoryBarrier(spv::ScopeSubgroup, spv::MemorySemanticsImageMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return spv::NoResult;
-    case glslang::EOpSubgroupMemoryBarrierShared:
+    case qglslang::EOpSubgroupMemoryBarrierShared:
         builder.createMemoryBarrier(spv::ScopeSubgroup, spv::MemorySemanticsWorkgroupMemoryMask |
                                                         spv::MemorySemanticsAcquireReleaseMask);
         return spv::NoResult;
 
-    case glslang::EOpEmitVertex:
+    case qglslang::EOpEmitVertex:
         builder.createNoResultOp(spv::OpEmitVertex);
         return 0;
-    case glslang::EOpEndPrimitive:
+    case qglslang::EOpEndPrimitive:
         builder.createNoResultOp(spv::OpEndPrimitive);
         return 0;
 
-    case glslang::EOpSubgroupElect: {
+    case qglslang::EOpSubgroupElect: {
         std::vector<spv::Id> operands;
-        return createSubgroupOperation(op, typeId, operands, glslang::EbtVoid);
+        return createSubgroupOperation(op, typeId, operands, qglslang::EbtVoid);
     }
-    case glslang::EOpTime:
+    case qglslang::EOpTime:
     {
         std::vector<spv::Id> args; // Dummy arguments
         spv::Id id = builder.createBuiltinCall(typeId, getExtBuiltins(spv::E_SPV_AMD_gcn_shader), spv::TimeAMD, args);
         return builder.setPrecision(id, precision);
     }
-    case glslang::EOpIgnoreIntersectionNV:
+    case qglslang::EOpIgnoreIntersectionNV:
         builder.createNoResultOp(spv::OpIgnoreIntersectionNV);
         return 0;
-    case glslang::EOpTerminateRayNV:
+    case qglslang::EOpTerminateRayNV:
         builder.createNoResultOp(spv::OpTerminateRayNV);
         return 0;
-    case glslang::EOpRayQueryInitialize:
+    case qglslang::EOpRayQueryInitialize:
         builder.createNoResultOp(spv::OpRayQueryInitializeKHR);
         return 0;
-    case glslang::EOpRayQueryTerminate:
+    case qglslang::EOpRayQueryTerminate:
         builder.createNoResultOp(spv::OpRayQueryTerminateKHR);
         return 0;
-    case glslang::EOpRayQueryGenerateIntersection:
+    case qglslang::EOpRayQueryGenerateIntersection:
         builder.createNoResultOp(spv::OpRayQueryGenerateIntersectionKHR);
         return 0;
-    case glslang::EOpRayQueryConfirmIntersection:
+    case qglslang::EOpRayQueryConfirmIntersection:
         builder.createNoResultOp(spv::OpRayQueryConfirmIntersectionKHR);
         return 0;
-    case glslang::EOpBeginInvocationInterlock:
+    case qglslang::EOpBeginInvocationInterlock:
         builder.createNoResultOp(spv::OpBeginInvocationInterlockEXT);
         return 0;
-    case glslang::EOpEndInvocationInterlock:
+    case qglslang::EOpEndInvocationInterlock:
         builder.createNoResultOp(spv::OpEndInvocationInterlockEXT);
         return 0;
 
-    case glslang::EOpIsHelperInvocation:
+    case qglslang::EOpIsHelperInvocation:
     {
         std::vector<spv::Id> args; // Dummy arguments
         builder.addExtension(spv::E_SPV_EXT_demote_to_helper_invocation);
@@ -8714,7 +8714,7 @@ spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv:
         return builder.createOp(spv::OpIsHelperInvocationEXT, typeId, args);
     }
 
-    case glslang::EOpReadClockSubgroupKHR: {
+    case qglslang::EOpReadClockSubgroupKHR: {
         std::vector<spv::Id> args;
         args.push_back(builder.makeUintConstant(spv::ScopeSubgroup));
         builder.addExtension(spv::E_SPV_KHR_shader_clock);
@@ -8722,7 +8722,7 @@ spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv:
         return builder.createOp(spv::OpReadClockKHR, typeId, args);
     }
 
-    case glslang::EOpReadClockDeviceKHR: {
+    case qglslang::EOpReadClockDeviceKHR: {
         std::vector<spv::Id> args;
         args.push_back(builder.makeUintConstant(spv::ScopeDevice));
         builder.addExtension(spv::E_SPV_KHR_shader_clock);
@@ -8739,7 +8739,7 @@ spv::Id TGlslangToSpvTraverser::createNoArgOperation(glslang::TOperator op, spv:
     return 0;
 }
 
-spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol)
+spv::Id TGlslangToSpvTraverser::getSymbolId(const qglslang::TIntermSymbol* symbol)
 {
     auto iter = symbolValues.find(symbol->getId());
     spv::Id id;
@@ -8781,7 +8781,7 @@ spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol
     if (forcedType.second != spv::NoType)
         forceType[id] = forcedType.second;
 
-    if (symbol->getBasicType() != glslang::EbtBlock) {
+    if (symbol->getBasicType() != qglslang::EbtBlock) {
         builder.addDecoration(id, TranslatePrecisionDecoration(symbol->getType()));
         builder.addDecoration(id, TranslateInterpolationDecoration(symbol->getType().getQualifier()));
         builder.addDecoration(id, TranslateAuxiliaryStorageDecoration(symbol->getType().getQualifier()));
@@ -8800,7 +8800,7 @@ spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol
     }
 
     if (symbol->getQualifier().hasLocation()) {
-        if (!(glslangIntermediate->isRayTracingStage() && glslangIntermediate->IsRequestedExtension(glslang::E_GL_EXT_ray_tracing)
+        if (!(glslangIntermediate->isRayTracingStage() && glslangIntermediate->IsRequestedExtension(qglslang::E_GL_EXT_ray_tracing)
               && (builder.getStorageClass(id) == spv::StorageClassRayPayloadKHR ||
                   builder.getStorageClass(id) == spv::StorageClassIncomingRayPayloadKHR ||
                   builder.getStorageClass(id) == spv::StorageClassCallableDataKHR ||
@@ -8835,7 +8835,7 @@ spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol
         if (symbol->getQualifier().hasXfbBuffer()) {
             builder.addDecoration(id, spv::DecorationXfbBuffer, symbol->getQualifier().layoutXfbBuffer);
             unsigned stride = glslangIntermediate->getXfbStride(symbol->getQualifier().layoutXfbBuffer);
-            if (stride != glslang::TQualifier::layoutXfbStrideEnd)
+            if (stride != qglslang::TQualifier::layoutXfbStrideEnd)
                 builder.addDecoration(id, spv::DecorationXfbStride, stride);
         }
         if (symbol->getQualifier().hasXfbOffset())
@@ -8845,14 +8845,14 @@ spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol
     // add built-in variable decoration
     if (builtIn != spv::BuiltInMax) {
         // WorkgroupSize deprecated in spirv1.6
-        if (glslangIntermediate->getSpv().spv < glslang::EShTargetSpv_1_6 ||
+        if (glslangIntermediate->getSpv().spv < qglslang::EShTargetSpv_1_6 ||
             builtIn != spv::BuiltInWorkgroupSize)
             builder.addDecoration(id, spv::DecorationBuiltIn, (int)builtIn);
     }
 
     // Add volatile decoration to HelperInvocation for spirv1.6 and beyond
     if (builtIn == spv::BuiltInHelperInvocation &&
-        glslangIntermediate->getSpv().spv >= glslang::EShTargetSpv_1_6) {
+        glslangIntermediate->getSpv().spv >= qglslang::EShTargetSpv_1_6) {
         builder.addDecoration(id, spv::DecorationVolatile);
     }
 
@@ -8926,7 +8926,7 @@ spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol
     // Add SPIR-V decorations for structure (GL_EXT_spirv_intrinsics)
     //
     if (symbol->getType().getQualifier().hasSprivDecorate()) {
-        const glslang::TSpirvDecorate& spirvDecorate = symbol->getType().getQualifier().getSpirvDecorate();
+        const qglslang::TSpirvDecorate& spirvDecorate = symbol->getType().getQualifier().getSpirvDecorate();
 
         // Add spirv_decorate
         for (auto& decorate : spirvDecorate.decorates) {
@@ -8970,7 +8970,7 @@ spv::Id TGlslangToSpvTraverser::getSymbolId(const glslang::TIntermSymbol* symbol
 
 #ifndef GLSLANG_WEB
 // add per-primitive, per-view. per-task decorations to a struct member (member >= 0) or an object
-void TGlslangToSpvTraverser::addMeshNVDecoration(spv::Id id, int member, const glslang::TQualifier& qualifier)
+void TGlslangToSpvTraverser::addMeshNVDecoration(spv::Id id, int member, const qglslang::TQualifier& qualifier)
 {
     if (member >= 0) {
         if (qualifier.perPrimitiveNV) {
@@ -9014,7 +9014,7 @@ void TGlslangToSpvTraverser::addMeshNVDecoration(spv::Id id, int member, const g
 // recursively walks.  So, this function walks the "top" of the tree:
 //  - emit specialization constant-building instructions for specConstant
 //  - when running into a non-spec-constant, switch to createSpvConstant()
-spv::Id TGlslangToSpvTraverser::createSpvConstant(const glslang::TIntermTyped& node)
+spv::Id TGlslangToSpvTraverser::createSpvConstant(const qglslang::TIntermTyped& node)
 {
     assert(node.getQualifier().isConstant());
 
@@ -9044,10 +9044,10 @@ spv::Id TGlslangToSpvTraverser::createSpvConstant(const glslang::TIntermTyped& n
 
     // gl_WorkGroupSize is a special case until the front-end handles hierarchical specialization constants,
     // even then, it's specialization ids are handled by special case syntax in GLSL: layout(local_size_x = ...
-    if (node.getType().getQualifier().builtIn == glslang::EbvWorkGroupSize) {
+    if (node.getType().getQualifier().builtIn == qglslang::EbvWorkGroupSize) {
         std::vector<spv::Id> dimConstId;
         for (int dim = 0; dim < 3; ++dim) {
-            bool specConst = (glslangIntermediate->getLocalSizeSpecId(dim) != glslang::TQualifier::layoutNotSet);
+            bool specConst = (glslangIntermediate->getLocalSizeSpecId(dim) != qglslang::TQualifier::layoutNotSet);
             dimConstId.push_back(builder.makeUintConstant(glslangIntermediate->getLocalSize(dim), specConst));
             if (specConst) {
                 builder.addDecoration(dimConstId.back(), spv::DecorationSpecId,
@@ -9090,8 +9090,8 @@ spv::Id TGlslangToSpvTraverser::createSpvConstant(const glslang::TIntermTyped& n
 // If there are not enough elements present in 'consts', 0 will be substituted;
 // an empty 'consts' can be used to create a fully zeroed SPIR-V constant.
 //
-spv::Id TGlslangToSpvTraverser::createSpvConstantFromConstUnionArray(const glslang::TType& glslangType,
-    const glslang::TConstUnionArray& consts, int& nextConst, bool specConstant)
+spv::Id TGlslangToSpvTraverser::createSpvConstantFromConstUnionArray(const qglslang::TType& glslangType,
+    const qglslang::TConstUnionArray& consts, int& nextConst, bool specConstant)
 {
     // vector of constants for SPIR-V
     std::vector<spv::Id> spvConsts;
@@ -9100,63 +9100,63 @@ spv::Id TGlslangToSpvTraverser::createSpvConstantFromConstUnionArray(const glsla
     spv::Id typeId = convertGlslangToSpvType(glslangType);
 
     if (glslangType.isArray()) {
-        glslang::TType elementType(glslangType, 0);
+        qglslang::TType elementType(glslangType, 0);
         for (int i = 0; i < glslangType.getOuterArraySize(); ++i)
             spvConsts.push_back(createSpvConstantFromConstUnionArray(elementType, consts, nextConst, false));
     } else if (glslangType.isMatrix()) {
-        glslang::TType vectorType(glslangType, 0);
+        qglslang::TType vectorType(glslangType, 0);
         for (int col = 0; col < glslangType.getMatrixCols(); ++col)
             spvConsts.push_back(createSpvConstantFromConstUnionArray(vectorType, consts, nextConst, false));
     } else if (glslangType.isCoopMat()) {
-        glslang::TType componentType(glslangType.getBasicType());
+        qglslang::TType componentType(glslangType.getBasicType());
         spvConsts.push_back(createSpvConstantFromConstUnionArray(componentType, consts, nextConst, false));
     } else if (glslangType.isStruct()) {
-        glslang::TVector<glslang::TTypeLoc>::const_iterator iter;
+        qglslang::TVector<qglslang::TTypeLoc>::const_iterator iter;
         for (iter = glslangType.getStruct()->begin(); iter != glslangType.getStruct()->end(); ++iter)
             spvConsts.push_back(createSpvConstantFromConstUnionArray(*iter->type, consts, nextConst, false));
     } else if (glslangType.getVectorSize() > 1) {
         for (unsigned int i = 0; i < (unsigned int)glslangType.getVectorSize(); ++i) {
             bool zero = nextConst >= consts.size();
             switch (glslangType.getBasicType()) {
-            case glslang::EbtInt:
+            case qglslang::EbtInt:
                 spvConsts.push_back(builder.makeIntConstant(zero ? 0 : consts[nextConst].getIConst()));
                 break;
-            case glslang::EbtUint:
+            case qglslang::EbtUint:
                 spvConsts.push_back(builder.makeUintConstant(zero ? 0 : consts[nextConst].getUConst()));
                 break;
-            case glslang::EbtFloat:
+            case qglslang::EbtFloat:
                 spvConsts.push_back(builder.makeFloatConstant(zero ? 0.0F : (float)consts[nextConst].getDConst()));
                 break;
-            case glslang::EbtBool:
+            case qglslang::EbtBool:
                 spvConsts.push_back(builder.makeBoolConstant(zero ? false : consts[nextConst].getBConst()));
                 break;
 #ifndef GLSLANG_WEB
-            case glslang::EbtInt8:
+            case qglslang::EbtInt8:
                 builder.addCapability(spv::CapabilityInt8);
                 spvConsts.push_back(builder.makeInt8Constant(zero ? 0 : consts[nextConst].getI8Const()));
                 break;
-            case glslang::EbtUint8:
+            case qglslang::EbtUint8:
                 builder.addCapability(spv::CapabilityInt8);
                 spvConsts.push_back(builder.makeUint8Constant(zero ? 0 : consts[nextConst].getU8Const()));
                 break;
-            case glslang::EbtInt16:
+            case qglslang::EbtInt16:
                 builder.addCapability(spv::CapabilityInt16);
                 spvConsts.push_back(builder.makeInt16Constant(zero ? 0 : consts[nextConst].getI16Const()));
                 break;
-            case glslang::EbtUint16:
+            case qglslang::EbtUint16:
                 builder.addCapability(spv::CapabilityInt16);
                 spvConsts.push_back(builder.makeUint16Constant(zero ? 0 : consts[nextConst].getU16Const()));
                 break;
-            case glslang::EbtInt64:
+            case qglslang::EbtInt64:
                 spvConsts.push_back(builder.makeInt64Constant(zero ? 0 : consts[nextConst].getI64Const()));
                 break;
-            case glslang::EbtUint64:
+            case qglslang::EbtUint64:
                 spvConsts.push_back(builder.makeUint64Constant(zero ? 0 : consts[nextConst].getU64Const()));
                 break;
-            case glslang::EbtDouble:
+            case qglslang::EbtDouble:
                 spvConsts.push_back(builder.makeDoubleConstant(zero ? 0.0 : consts[nextConst].getDConst()));
                 break;
-            case glslang::EbtFloat16:
+            case qglslang::EbtFloat16:
                 builder.addCapability(spv::CapabilityFloat16);
                 spvConsts.push_back(builder.makeFloat16Constant(zero ? 0.0F : (float)consts[nextConst].getDConst()));
                 break;
@@ -9172,54 +9172,54 @@ spv::Id TGlslangToSpvTraverser::createSpvConstantFromConstUnionArray(const glsla
         bool zero = nextConst >= consts.size();
         spv::Id scalar = 0;
         switch (glslangType.getBasicType()) {
-        case glslang::EbtInt:
+        case qglslang::EbtInt:
             scalar = builder.makeIntConstant(zero ? 0 : consts[nextConst].getIConst(), specConstant);
             break;
-        case glslang::EbtUint:
+        case qglslang::EbtUint:
             scalar = builder.makeUintConstant(zero ? 0 : consts[nextConst].getUConst(), specConstant);
             break;
-        case glslang::EbtFloat:
+        case qglslang::EbtFloat:
             scalar = builder.makeFloatConstant(zero ? 0.0F : (float)consts[nextConst].getDConst(), specConstant);
             break;
-        case glslang::EbtBool:
+        case qglslang::EbtBool:
             scalar = builder.makeBoolConstant(zero ? false : consts[nextConst].getBConst(), specConstant);
             break;
 #ifndef GLSLANG_WEB
-        case glslang::EbtInt8:
+        case qglslang::EbtInt8:
             builder.addCapability(spv::CapabilityInt8);
             scalar = builder.makeInt8Constant(zero ? 0 : consts[nextConst].getI8Const(), specConstant);
             break;
-        case glslang::EbtUint8:
+        case qglslang::EbtUint8:
             builder.addCapability(spv::CapabilityInt8);
             scalar = builder.makeUint8Constant(zero ? 0 : consts[nextConst].getU8Const(), specConstant);
             break;
-        case glslang::EbtInt16:
+        case qglslang::EbtInt16:
             builder.addCapability(spv::CapabilityInt16);
             scalar = builder.makeInt16Constant(zero ? 0 : consts[nextConst].getI16Const(), specConstant);
             break;
-        case glslang::EbtUint16:
+        case qglslang::EbtUint16:
             builder.addCapability(spv::CapabilityInt16);
             scalar = builder.makeUint16Constant(zero ? 0 : consts[nextConst].getU16Const(), specConstant);
             break;
-        case glslang::EbtInt64:
+        case qglslang::EbtInt64:
             scalar = builder.makeInt64Constant(zero ? 0 : consts[nextConst].getI64Const(), specConstant);
             break;
-        case glslang::EbtUint64:
+        case qglslang::EbtUint64:
             scalar = builder.makeUint64Constant(zero ? 0 : consts[nextConst].getU64Const(), specConstant);
             break;
-        case glslang::EbtDouble:
+        case qglslang::EbtDouble:
             scalar = builder.makeDoubleConstant(zero ? 0.0 : consts[nextConst].getDConst(), specConstant);
             break;
-        case glslang::EbtFloat16:
+        case qglslang::EbtFloat16:
             builder.addCapability(spv::CapabilityFloat16);
             scalar = builder.makeFloat16Constant(zero ? 0.0F : (float)consts[nextConst].getDConst(), specConstant);
             break;
-        case glslang::EbtReference:
+        case qglslang::EbtReference:
             scalar = builder.makeUint64Constant(zero ? 0 : consts[nextConst].getU64Const(), specConstant);
             scalar = builder.createUnaryOp(spv::OpBitcast, typeId, scalar);
             break;
 #endif
-        case glslang::EbtString:
+        case qglslang::EbtString:
             scalar = builder.getStringId(consts[nextConst].getSConst()->c_str());
             break;
         default:
@@ -9235,7 +9235,7 @@ spv::Id TGlslangToSpvTraverser::createSpvConstantFromConstUnionArray(const glsla
 
 // Return true if the node is a constant or symbol whose reading has no
 // non-trivial observable cost or effect.
-bool TGlslangToSpvTraverser::isTrivialLeaf(const glslang::TIntermTyped* node)
+bool TGlslangToSpvTraverser::isTrivialLeaf(const qglslang::TIntermTyped* node)
 {
     // don't know what this is
     if (node == nullptr)
@@ -9251,13 +9251,13 @@ bool TGlslangToSpvTraverser::isTrivialLeaf(const glslang::TIntermTyped* node)
 
     // a symbol, depends on what's being read
     switch (node->getType().getQualifier().storage) {
-    case glslang::EvqTemporary:
-    case glslang::EvqGlobal:
-    case glslang::EvqIn:
-    case glslang::EvqInOut:
-    case glslang::EvqConst:
-    case glslang::EvqConstReadOnly:
-    case glslang::EvqUniform:
+    case qglslang::EvqTemporary:
+    case qglslang::EvqGlobal:
+    case qglslang::EvqIn:
+    case qglslang::EvqInOut:
+    case qglslang::EvqConst:
+    case qglslang::EvqConstReadOnly:
+    case qglslang::EvqUniform:
         return true;
     default:
         return false;
@@ -9268,13 +9268,13 @@ bool TGlslangToSpvTraverser::isTrivialLeaf(const glslang::TIntermTyped* node)
 // HLSL (and/or vectors) are always trivial, as it does not short circuit.
 // Otherwise, error on the side of saying non-trivial.
 // Return true if trivial.
-bool TGlslangToSpvTraverser::isTrivial(const glslang::TIntermTyped* node)
+bool TGlslangToSpvTraverser::isTrivial(const qglslang::TIntermTyped* node)
 {
     if (node == nullptr)
         return false;
 
     // count non scalars as trivial, as well as anything coming from HLSL
-    if (! node->getType().isScalarOrVec1() || glslangIntermediate->getSource() == glslang::EShSourceHlsl)
+    if (! node->getType().isScalarOrVec1() || glslangIntermediate->getSource() == qglslang::EShSourceHlsl)
         return true;
 
     // symbols and constants are trivial
@@ -9284,8 +9284,8 @@ bool TGlslangToSpvTraverser::isTrivial(const glslang::TIntermTyped* node)
     // otherwise, it needs to be a simple operation or one or two leaf nodes
 
     // not a simple operation
-    const glslang::TIntermBinary* binaryNode = node->getAsBinaryNode();
-    const glslang::TIntermUnary* unaryNode = node->getAsUnaryNode();
+    const qglslang::TIntermBinary* binaryNode = node->getAsBinaryNode();
+    const qglslang::TIntermUnary* unaryNode = node->getAsUnaryNode();
     if (binaryNode == nullptr && unaryNode == nullptr)
         return false;
 
@@ -9298,22 +9298,22 @@ bool TGlslangToSpvTraverser::isTrivial(const glslang::TIntermTyped* node)
     }
 
     switch (node->getAsOperator()->getOp()) {
-    case glslang::EOpLogicalNot:
-    case glslang::EOpConvIntToBool:
-    case glslang::EOpConvUintToBool:
-    case glslang::EOpConvFloatToBool:
-    case glslang::EOpConvDoubleToBool:
-    case glslang::EOpEqual:
-    case glslang::EOpNotEqual:
-    case glslang::EOpLessThan:
-    case glslang::EOpGreaterThan:
-    case glslang::EOpLessThanEqual:
-    case glslang::EOpGreaterThanEqual:
-    case glslang::EOpIndexDirect:
-    case glslang::EOpIndexDirectStruct:
-    case glslang::EOpLogicalXor:
-    case glslang::EOpAny:
-    case glslang::EOpAll:
+    case qglslang::EOpLogicalNot:
+    case qglslang::EOpConvIntToBool:
+    case qglslang::EOpConvUintToBool:
+    case qglslang::EOpConvFloatToBool:
+    case qglslang::EOpConvDoubleToBool:
+    case qglslang::EOpEqual:
+    case qglslang::EOpNotEqual:
+    case qglslang::EOpLessThan:
+    case qglslang::EOpGreaterThan:
+    case qglslang::EOpLessThanEqual:
+    case qglslang::EOpGreaterThanEqual:
+    case qglslang::EOpIndexDirect:
+    case qglslang::EOpIndexDirectStruct:
+    case qglslang::EOpLogicalXor:
+    case qglslang::EOpAny:
+    case qglslang::EOpAll:
         return true;
     default:
         return false;
@@ -9322,8 +9322,8 @@ bool TGlslangToSpvTraverser::isTrivial(const glslang::TIntermTyped* node)
 
 // Emit short-circuiting code, where 'right' is never evaluated unless
 // the left side is true (for &&) or false (for ||).
-spv::Id TGlslangToSpvTraverser::createShortCircuit(glslang::TOperator op, glslang::TIntermTyped& left,
-    glslang::TIntermTyped& right)
+spv::Id TGlslangToSpvTraverser::createShortCircuit(qglslang::TOperator op, qglslang::TIntermTyped& left,
+    qglslang::TIntermTyped& right)
 {
     spv::Id boolTypeId = builder.makeBoolType();
 
@@ -9344,7 +9344,7 @@ spv::Id TGlslangToSpvTraverser::createShortCircuit(glslang::TOperator op, glslan
     //
     // TODO: this runtime "not" for || could be avoided by adding functionality
     // to 'builder' to have an "else" without an "then"
-    if (op == glslang::EOpLogicalOr)
+    if (op == qglslang::EOpLogicalOr)
         leftId = builder.createUnaryOp(spv::OpLogicalNot, boolTypeId, leftId);
 
     // make an "if" based on the left value
@@ -9384,7 +9384,7 @@ spv::Id TGlslangToSpvTraverser::getExtBuiltins(const char* name)
 
 };  // end anonymous namespace
 
-namespace glslang {
+namespace qglslang {
 
 void GetSpirvVersion(std::string& version)
 {
@@ -9514,4 +9514,4 @@ void GlslangToSpv(const TIntermediate& intermediate, std::vector<unsigned int>&
     GetThreadPoolAllocator().pop();
 }
 
-}; // end namespace glslang
+}; // end namespace qglslang
diff --git a/src/3rdparty/glslang/SPIRV/GlslangToSpv.h b/src/3rdparty/glslang/SPIRV/GlslangToSpv.h
index 3907be43..e368ba65 100644
--- a/src/3rdparty/glslang/SPIRV/GlslangToSpv.h
+++ b/src/3rdparty/glslang/SPIRV/GlslangToSpv.h
@@ -47,13 +47,13 @@
 
 #include "Logger.h"
 
-namespace glslang {
+namespace qglslang {
 
 void GetSpirvVersion(std::string&);
 int GetSpirvGeneratorVersion();
-void GlslangToSpv(const glslang::TIntermediate& intermediate, std::vector<unsigned int>& spirv,
+void GlslangToSpv(const qglslang::TIntermediate& intermediate, std::vector<unsigned int>& spirv,
                   SpvOptions* options = nullptr);
-void GlslangToSpv(const glslang::TIntermediate& intermediate, std::vector<unsigned int>& spirv,
+void GlslangToSpv(const qglslang::TIntermediate& intermediate, std::vector<unsigned int>& spirv,
                   spv::SpvBuildLogger* logger, SpvOptions* options = nullptr);
 void OutputSpvBin(const std::vector<unsigned int>& spirv, const char* baseName);
 void OutputSpvHex(const std::vector<unsigned int>& spirv, const char* baseName, const char* varName);
diff --git a/src/3rdparty/glslang/SPIRV/SpvTools.cpp b/src/3rdparty/glslang/SPIRV/SpvTools.cpp
index 8cc17cca..7daa9f9b 100644
--- a/src/3rdparty/glslang/SPIRV/SpvTools.cpp
+++ b/src/3rdparty/glslang/SPIRV/SpvTools.cpp
@@ -45,7 +45,7 @@
 #include "SpvTools.h"
 #include "spirv-tools/optimizer.hpp"
 
-namespace glslang {
+namespace qglslang {
 
 // Translate glslang's view of target versioning to what SPIRV-Tools uses.
 spv_target_env MapToSpirvToolsEnv(const SpvVersion& spvVersion, spv::SpvBuildLogger* logger)
@@ -242,6 +242,6 @@ void SpirvToolsStripDebugInfo(const glslang::TIntermediate& intermediate,
     optimizer.Run(spirv.data(), spirv.size(), &spirv, spvOptOptions);
 }
 
-}; // end namespace glslang
+}; // end namespace qglslang
 
 #endif
diff --git a/src/3rdparty/glslang/SPIRV/SpvTools.h b/src/3rdparty/glslang/SPIRV/SpvTools.h
index 3fb3cbac..21a6fdad 100644
--- a/src/3rdparty/glslang/SPIRV/SpvTools.h
+++ b/src/3rdparty/glslang/SPIRV/SpvTools.h
@@ -50,7 +50,7 @@
 #include "glslang/MachineIndependent/localintermediate.h"
 #include "Logger.h"
 
-namespace glslang {
+namespace qglslang {
 
 struct SpvOptions {
     SpvOptions() : generateDebugInfo(false), stripDebugInfo(false), disableOptimizer(true),
@@ -88,6 +88,6 @@ void SpirvToolsStripDebugInfo(const glslang::TIntermediate& intermediate,
 
 #endif
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // GLSLANG_SPV_TOOLS_H
diff --git a/src/3rdparty/glslang/SPIRV/disassemble.cpp b/src/3rdparty/glslang/SPIRV/disassemble.cpp
index 74dd6054..0488a943 100644
--- a/src/3rdparty/glslang/SPIRV/disassemble.cpp
+++ b/src/3rdparty/glslang/SPIRV/disassemble.cpp
@@ -509,7 +509,7 @@ void SpirvStream::disassembleInstruction(Id resultId, Id /*typeId*/, Op opCode,
                 } else if (strcmp(spv::E_SPV_NV_sample_mask_override_coverage, name) == 0 ||
                           strcmp(spv::E_SPV_NV_geometry_shader_passthrough, name) == 0 ||
                           strcmp(spv::E_SPV_NV_viewport_array2, name) == 0 ||
-                          strcmp(spv::E_SPV_NVX_multiview_per_view_attributes, name) == 0 || 
+                          strcmp(spv::E_SPV_NVX_multiview_per_view_attributes, name) == 0 ||
                           strcmp(spv::E_SPV_NV_fragment_shader_barycentric, name) == 0 ||
                           strcmp(spv::E_SPV_NV_mesh_shader, name) == 0) {
                     extInstSet = GLSLextNVInst;
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.cpp
index 0cc0d3f4..d4054141 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.cpp
@@ -36,7 +36,7 @@
 #include "hlslAttributes.h"
 #include "hlslParseHelper.h"
 
-namespace glslang {
+namespace qglslang {
     // Map the given string to an attribute enum from TAttributeType,
     // or EatNone if invalid.
     TAttributeType HlslParseContext::attributeFromName(const TString& nameSpace, const TString& name) const
@@ -146,4 +146,4 @@ namespace glslang {
             return EatNone;
     }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.h b/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.h
index 62faa5b8..3844fbdd 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslAttributes.h
@@ -43,7 +43,7 @@
 #include "../MachineIndependent/SymbolTable.h"
 #include "hlslScanContext.h"
 
-namespace glslang {
+namespace qglslang {
 
     class TFunctionDeclarator {
     public:
@@ -54,6 +54,6 @@ namespace glslang {
         TVector<HlslToken>* body;
     };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // HLSLATTRIBUTES_H_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.cpp
index bd4af922..74b3bf94 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.cpp
@@ -55,7 +55,7 @@
 #include "hlslGrammar.h"
 #include "hlslAttributes.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Root entry point to this recursive decent parser.
 // Return true if compilation unit was successfully accepted.
@@ -4189,4 +4189,4 @@ const char* HlslGrammar::getTypeString(EHlslTokenClass tokenClass) const
     }
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.h b/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.h
index 27706b2b..e0aed4cd 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslGrammar.h
@@ -41,7 +41,7 @@
 #include "hlslOpMap.h"
 #include "hlslTokenStream.h"
 
-namespace glslang {
+namespace qglslang {
 
     class TFunctionDeclarator;
 
@@ -137,6 +137,6 @@ namespace glslang {
         TIntermNode* unitNode;
     };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // HLSLGRAMMAR_H_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.cpp
index ebe6fbd9..826b740d 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.cpp
@@ -38,7 +38,7 @@
 
 #include "hlslOpMap.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Map parsing tokens that could be assignments into assignment operators.
 TOperator HlslOpMap::assignment(EHlslTokenClass op)
@@ -170,4 +170,4 @@ PrecedenceLevel HlslOpMap::precedenceLevel(TOperator op)
     }
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.h b/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.h
index 4e783f3f..7746e4d9 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslOpMap.h
@@ -38,7 +38,7 @@
 
 #include "hlslScanContext.h"
 
-namespace glslang {
+namespace qglslang {
 
     enum PrecedenceLevel {
         PlBad,
@@ -64,6 +64,6 @@ namespace glslang {
         static PrecedenceLevel precedenceLevel(TOperator);
     };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // HLSLOPMAP_H_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.cpp
index ffa1d7a6..52cb5bee 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.cpp
@@ -51,7 +51,7 @@
 #include <array>
 #include <set>
 
-namespace glslang {
+namespace qglslang {
 
 HlslParseContext::HlslParseContext(TSymbolTable& symbolTable, TIntermediate& interm, bool parsingBuiltins,
                                    int version, EProfile profile, const SpvVersion& spvVersion, EShLanguage language,
@@ -10251,4 +10251,4 @@ void HlslParseContext::finish()
     TParseContextBase::finish();
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.h b/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.h
index 8bebb0e2..dd8bd1e9 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslParseHelper.h
@@ -42,7 +42,7 @@
 
 #include <array>
 
-namespace glslang {
+namespace qglslang {
 
 class TFunctionDeclarator;
 
@@ -510,6 +510,6 @@ protected:
 // require changing the scanner.
 #define BUILTIN_PREFIX "__BI_"
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // HLSL_PARSE_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslParseables.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslParseables.cpp
index 15918dc3..07a89449 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslParseables.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslParseables.cpp
@@ -384,7 +384,7 @@ inline void FindVectorMatrixBounds(const char* argOrder, int fixedVecSize, int&
 
 } // end anonymous namespace
 
-namespace glslang {
+namespace qglslang {
 
 TBuiltInParseablesHlsl::TBuiltInParseablesHlsl()
 {
@@ -1256,4 +1256,4 @@ void TBuiltInParseablesHlsl::identifyBuiltIns(int /*version*/, EProfile /*profil
 {
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslParseables.h b/src/3rdparty/glslang/glslang/HLSL/hlslParseables.h
index a4aef6c3..463965d6 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslParseables.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslParseables.h
@@ -38,7 +38,7 @@
 
 #include "../MachineIndependent/Initialize.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // This is an HLSL specific derivation of TBuiltInParseables.  See comment
@@ -59,6 +59,6 @@ private:
     void createMatTimesMat();
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _HLSLPARSEABLES_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.cpp
index fc62672f..5a0cbf59 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.cpp
@@ -85,7 +85,7 @@ std::unordered_map<const char*, glslang::TBuiltInVariable, str_hash, str_eq>* Se
 
 };
 
-namespace glslang {
+namespace qglslang {
 
 void HlslScanContext::fillInKeywordMap()
 {
@@ -900,4 +900,4 @@ EHlslTokenClass HlslScanContext::reservedWord()
     return EHTokNone;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.h b/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.h
index 3b191e48..b4f391bc 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslScanContext.h
@@ -44,7 +44,7 @@
 #include "../MachineIndependent/ParseHelper.h"
 #include "hlslTokens.h"
 
-namespace glslang {
+namespace qglslang {
 
 class TPpContext;
 class TPpToken;
@@ -104,6 +104,6 @@ protected:
     EHlslTokenClass keyword;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // HLSLSCANCONTEXT_H_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.cpp b/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.cpp
index 5d9311cf..91b6aba8 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.cpp
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.cpp
@@ -35,7 +35,7 @@
 
 #include "hlslTokenStream.h"
 
-namespace glslang {
+namespace qglslang {
 
 void HlslTokenStream::pushPreToken(const HlslToken& tok)
 {
@@ -147,4 +147,4 @@ bool HlslTokenStream::acceptTokenClass(EHlslTokenClass tokenClass)
     return false;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.h b/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.h
index cb6c9e72..14fc0daf 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslTokenStream.h
@@ -38,7 +38,7 @@
 
 #include "hlslScanContext.h"
 
-namespace glslang {
+namespace qglslang {
 
     class HlslTokenStream {
     public:
@@ -91,6 +91,6 @@ namespace glslang {
         HlslToken popTokenBuffer();
     };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // HLSLTOKENSTREAM_H_
diff --git a/src/3rdparty/glslang/glslang/HLSL/hlslTokens.h b/src/3rdparty/glslang/glslang/HLSL/hlslTokens.h
index 4426bcce..71927805 100644
--- a/src/3rdparty/glslang/glslang/HLSL/hlslTokens.h
+++ b/src/3rdparty/glslang/glslang/HLSL/hlslTokens.h
@@ -37,7 +37,7 @@
 #ifndef EHLSLTOKENS_H_
 #define EHLSLTOKENS_H_
 
-namespace glslang {
+namespace qglslang {
 
 enum EHlslTokenClass {
     EHTokNone = 0,
@@ -369,6 +369,6 @@ enum EHlslTokenClass {
     EHTokQuestion,
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // EHLSLTOKENS_H_
diff --git a/src/3rdparty/glslang/glslang/Include/BaseTypes.h b/src/3rdparty/glslang/glslang/Include/BaseTypes.h
index 3eec5973..11b9fab0 100644
--- a/src/3rdparty/glslang/glslang/Include/BaseTypes.h
+++ b/src/3rdparty/glslang/glslang/Include/BaseTypes.h
@@ -39,7 +39,7 @@
 #ifndef _BASICTYPES_INCLUDED_
 #define _BASICTYPES_INCLUDED_
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Basic type.  Arrays, vectors, sampler details, etc., are orthogonal to this.
@@ -589,6 +589,6 @@ __inline int getTypeRank(TBasicType type)
     return res;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _BASICTYPES_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/Common.h b/src/3rdparty/glslang/glslang/Include/Common.h
index 9042a1aa..5c0a8d8e 100644
--- a/src/3rdparty/glslang/glslang/Include/Common.h
+++ b/src/3rdparty/glslang/glslang/Include/Common.h
@@ -124,7 +124,7 @@ std::string to_string(const T& val) {
     void operator delete[](void*) { }                                 \
     void operator delete[](void *, void *) { }
 
-namespace glslang {
+namespace qglslang {
 
     //
     // Pool version of string.
@@ -132,13 +132,13 @@ namespace glslang {
     typedef pool_allocator<char> TStringAllocator;
     typedef std::basic_string <char, std::char_traits<char>, TStringAllocator> TString;
 
-} // end namespace glslang
+} // end namespace qglslang
 
 // Repackage the std::hash for use by unordered map/set with a TString key.
 namespace std {
 
-    template<> struct hash<glslang::TString> {
-        std::size_t operator()(const glslang::TString& s) const
+    template<> struct hash<qglslang::TString> {
+        std::size_t operator()(const qglslang::TString& s) const
         {
             const unsigned _FNV_offset_basis = 2166136261U;
             const unsigned _FNV_prime = 16777619U;
@@ -156,7 +156,7 @@ namespace std {
     };
 }
 
-namespace glslang {
+namespace qglslang {
 
 inline TString* NewPoolTString(const char* s)
 {
@@ -335,6 +335,6 @@ inline bool IsNan(double x) {
 #endif
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _COMMON_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/ConstantUnion.h b/src/3rdparty/glslang/glslang/Include/ConstantUnion.h
index c4ffb857..a1ef7261 100644
--- a/src/3rdparty/glslang/glslang/Include/ConstantUnion.h
+++ b/src/3rdparty/glslang/glslang/Include/ConstantUnion.h
@@ -41,7 +41,7 @@
 #include "../Include/Common.h"
 #include "../Include/BaseTypes.h"
 
-namespace glslang {
+namespace qglslang {
 
 class TConstUnion {
 public:
@@ -969,6 +969,6 @@ protected:
     TConstUnionVector* unionArray;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _CONSTANT_UNION_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/InfoSink.h b/src/3rdparty/glslang/glslang/Include/InfoSink.h
index dceb603c..40625777 100644
--- a/src/3rdparty/glslang/glslang/Include/InfoSink.h
+++ b/src/3rdparty/glslang/glslang/Include/InfoSink.h
@@ -38,7 +38,7 @@
 #include "../Include/Common.h"
 #include <cmath>
 
-namespace glslang {
+namespace qglslang {
 
 //
 // TPrefixType is used to centralize how info log messages start.
@@ -133,12 +133,12 @@ protected:
     int outputStream;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 class TInfoSink {
 public:
-    glslang::TInfoSinkBase info;
-    glslang::TInfoSinkBase debug;
+    qglslang::TInfoSinkBase info;
+    qglslang::TInfoSinkBase debug;
 };
 
 #endif // _INFOSINK_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/InitializeGlobals.h b/src/3rdparty/glslang/glslang/Include/InitializeGlobals.h
index 95d0a40e..795c3bfc 100644
--- a/src/3rdparty/glslang/glslang/Include/InitializeGlobals.h
+++ b/src/3rdparty/glslang/glslang/Include/InitializeGlobals.h
@@ -35,10 +35,10 @@
 #ifndef __INITIALIZE_GLOBALS_INCLUDED_
 #define __INITIALIZE_GLOBALS_INCLUDED_
 
-namespace glslang {
+namespace qglslang {
 
 bool InitializePoolIndex();
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // __INITIALIZE_GLOBALS_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/PoolAlloc.h b/src/3rdparty/glslang/glslang/Include/PoolAlloc.h
index 1f5cac76..1a2ebdfb 100644
--- a/src/3rdparty/glslang/glslang/Include/PoolAlloc.h
+++ b/src/3rdparty/glslang/glslang/Include/PoolAlloc.h
@@ -65,7 +65,7 @@
 #include <cstring>
 #include <vector>
 
-namespace glslang {
+namespace qglslang {
 
 // If we are using guard blocks, we must track each individual
 // allocation.  If we aren't using guard blocks, these
@@ -313,6 +313,6 @@ protected:
     TPoolAllocator& allocator;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _POOLALLOC_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/ShHandle.h b/src/3rdparty/glslang/glslang/Include/ShHandle.h
index df07bd8e..0159e9df 100644
--- a/src/3rdparty/glslang/glslang/Include/ShHandle.h
+++ b/src/3rdparty/glslang/glslang/Include/ShHandle.h
@@ -56,14 +56,14 @@ class TUniformMap;
 //
 class TShHandleBase {
 public:
-    TShHandleBase() { pool = new glslang::TPoolAllocator; }
+    TShHandleBase() { pool = new qglslang::TPoolAllocator; }
     virtual ~TShHandleBase() { delete pool; }
     virtual TCompiler* getAsCompiler() { return 0; }
     virtual TLinker* getAsLinker() { return 0; }
     virtual TUniformMap* getAsUniformMap() { return 0; }
-    virtual glslang::TPoolAllocator* getPool() const { return pool; }
+    virtual qglslang::TPoolAllocator* getPool() const { return pool; }
 private:
-    glslang::TPoolAllocator* pool;
+    qglslang::TPoolAllocator* pool;
 };
 
 //
@@ -109,8 +109,8 @@ protected:
 //
 // Link operations are based on a list of compile results...
 //
-typedef glslang::TVector<TCompiler*> TCompilerList;
-typedef glslang::TVector<TShHandleBase*> THandleList;
+typedef qglslang::TVector<TCompiler*> TCompilerList;
+typedef qglslang::TVector<TShHandleBase*> THandleList;
 
 //
 // The base class for the machine dependent linker to derive from
diff --git a/src/3rdparty/glslang/glslang/Include/SpirvIntrinsics.h b/src/3rdparty/glslang/glslang/Include/SpirvIntrinsics.h
index 3c7d72ce..bb30c67e 100644
--- a/src/3rdparty/glslang/glslang/Include/SpirvIntrinsics.h
+++ b/src/3rdparty/glslang/glslang/Include/SpirvIntrinsics.h
@@ -42,7 +42,7 @@
 //
 #include "Common.h"
 
-namespace glslang {
+namespace qglslang {
 
 class TIntermTyped;
 class TIntermConstantUnion;
@@ -123,6 +123,6 @@ struct TSpirvType {
     TSpirvTypeParameters typeParams;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // GLSLANG_WEB
diff --git a/src/3rdparty/glslang/glslang/Include/Types.h b/src/3rdparty/glslang/glslang/Include/Types.h
index 682d124c..61238702 100644
--- a/src/3rdparty/glslang/glslang/Include/Types.h
+++ b/src/3rdparty/glslang/glslang/Include/Types.h
@@ -48,7 +48,7 @@
 
 #include <algorithm>
 
-namespace glslang {
+namespace qglslang {
 
 class TIntermAggregate;
 
@@ -2759,7 +2759,7 @@ public:
     unsigned int getBufferReferenceAlignment() const
     {
 #ifndef GLSLANG_WEB
-        if (getBasicType() == glslang::EbtReference) {
+        if (getBasicType() == qglslang::EbtReference) {
             return getReferentType()->getQualifier().hasBufferReferenceAlign() ?
                         (1u << getReferentType()->getQualifier().layoutBufferReferenceAlign) : 16u;
         }
@@ -2860,6 +2860,6 @@ protected:
 #endif
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _TYPES_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/arrays.h b/src/3rdparty/glslang/glslang/Include/arrays.h
index 7f047d9f..cd499280 100644
--- a/src/3rdparty/glslang/glslang/Include/arrays.h
+++ b/src/3rdparty/glslang/glslang/Include/arrays.h
@@ -43,7 +43,7 @@
 
 #include <algorithm>
 
-namespace glslang {
+namespace qglslang {
 
 // This is used to mean there is no size yet (unsized), it is waiting to get a size from somewhere else.
 const int UnsizedArraySize = 0;
@@ -336,6 +336,6 @@ protected:
     bool variablyIndexed;  // true if array is indexed with a non compile-time constant
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _ARRAYS_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/Include/intermediate.h b/src/3rdparty/glslang/glslang/Include/intermediate.h
index a64ed683..cc09e0dd 100644
--- a/src/3rdparty/glslang/glslang/Include/intermediate.h
+++ b/src/3rdparty/glslang/glslang/Include/intermediate.h
@@ -50,14 +50,14 @@
 
 #if defined(_MSC_VER) && _MSC_VER >= 1900
     #pragma warning(disable : 4464) // relative include path contains '..'
-    #pragma warning(disable : 5026) // 'glslang::TIntermUnary': move constructor was implicitly defined as deleted
+    #pragma warning(disable : 5026) // 'qglslang::TIntermUnary': move constructor was implicitly defined as deleted
 #endif
 
 #include "../Include/Common.h"
 #include "../Include/Types.h"
 #include "../Include/ConstantUnion.h"
 
-namespace glslang {
+namespace qglslang {
 
 class TIntermediate;
 
@@ -1066,7 +1066,7 @@ class TIntermMethod;
 class TIntermSymbol;
 class TIntermLoop;
 
-} // end namespace glslang
+} // end namespace qglslang
 
 //
 // Base class for the tree nodes
@@ -1075,46 +1075,46 @@ class TIntermLoop;
 //
 class TIntermNode {
 public:
-    POOL_ALLOCATOR_NEW_DELETE(glslang::GetThreadPoolAllocator())
+    POOL_ALLOCATOR_NEW_DELETE(qglslang::GetThreadPoolAllocator())
 
     TIntermNode() { loc.init(); }
-    virtual const glslang::TSourceLoc& getLoc() const { return loc; }
-    virtual void setLoc(const glslang::TSourceLoc& l) { loc = l; }
-    virtual void traverse(glslang::TIntermTraverser*) = 0;
-    virtual       glslang::TIntermTyped*         getAsTyped()               { return 0; }
-    virtual       glslang::TIntermOperator*      getAsOperator()            { return 0; }
-    virtual       glslang::TIntermConstantUnion* getAsConstantUnion()       { return 0; }
-    virtual       glslang::TIntermAggregate*     getAsAggregate()           { return 0; }
-    virtual       glslang::TIntermUnary*         getAsUnaryNode()           { return 0; }
-    virtual       glslang::TIntermBinary*        getAsBinaryNode()          { return 0; }
-    virtual       glslang::TIntermSelection*     getAsSelectionNode()       { return 0; }
-    virtual       glslang::TIntermSwitch*        getAsSwitchNode()          { return 0; }
-    virtual       glslang::TIntermMethod*        getAsMethodNode()          { return 0; }
-    virtual       glslang::TIntermSymbol*        getAsSymbolNode()          { return 0; }
-    virtual       glslang::TIntermBranch*        getAsBranchNode()          { return 0; }
-    virtual       glslang::TIntermLoop*          getAsLoopNode()            { return 0; }
-
-    virtual const glslang::TIntermTyped*         getAsTyped()         const { return 0; }
-    virtual const glslang::TIntermOperator*      getAsOperator()      const { return 0; }
-    virtual const glslang::TIntermConstantUnion* getAsConstantUnion() const { return 0; }
-    virtual const glslang::TIntermAggregate*     getAsAggregate()     const { return 0; }
-    virtual const glslang::TIntermUnary*         getAsUnaryNode()     const { return 0; }
-    virtual const glslang::TIntermBinary*        getAsBinaryNode()    const { return 0; }
-    virtual const glslang::TIntermSelection*     getAsSelectionNode() const { return 0; }
-    virtual const glslang::TIntermSwitch*        getAsSwitchNode()    const { return 0; }
-    virtual const glslang::TIntermMethod*        getAsMethodNode()    const { return 0; }
-    virtual const glslang::TIntermSymbol*        getAsSymbolNode()    const { return 0; }
-    virtual const glslang::TIntermBranch*        getAsBranchNode()    const { return 0; }
-    virtual const glslang::TIntermLoop*          getAsLoopNode()      const { return 0; }
+    virtual const qglslang::TSourceLoc& getLoc() const { return loc; }
+    virtual void setLoc(const qglslang::TSourceLoc& l) { loc = l; }
+    virtual void traverse(qglslang::TIntermTraverser*) = 0;
+    virtual       qglslang::TIntermTyped*         getAsTyped()               { return 0; }
+    virtual       qglslang::TIntermOperator*      getAsOperator()            { return 0; }
+    virtual       qglslang::TIntermConstantUnion* getAsConstantUnion()       { return 0; }
+    virtual       qglslang::TIntermAggregate*     getAsAggregate()           { return 0; }
+    virtual       qglslang::TIntermUnary*         getAsUnaryNode()           { return 0; }
+    virtual       qglslang::TIntermBinary*        getAsBinaryNode()          { return 0; }
+    virtual       qglslang::TIntermSelection*     getAsSelectionNode()       { return 0; }
+    virtual       qglslang::TIntermSwitch*        getAsSwitchNode()          { return 0; }
+    virtual       qglslang::TIntermMethod*        getAsMethodNode()          { return 0; }
+    virtual       qglslang::TIntermSymbol*        getAsSymbolNode()          { return 0; }
+    virtual       qglslang::TIntermBranch*        getAsBranchNode()          { return 0; }
+    virtual       qglslang::TIntermLoop*          getAsLoopNode()            { return 0; }
+
+    virtual const qglslang::TIntermTyped*         getAsTyped()         const { return 0; }
+    virtual const qglslang::TIntermOperator*      getAsOperator()      const { return 0; }
+    virtual const qglslang::TIntermConstantUnion* getAsConstantUnion() const { return 0; }
+    virtual const qglslang::TIntermAggregate*     getAsAggregate()     const { return 0; }
+    virtual const qglslang::TIntermUnary*         getAsUnaryNode()     const { return 0; }
+    virtual const qglslang::TIntermBinary*        getAsBinaryNode()    const { return 0; }
+    virtual const qglslang::TIntermSelection*     getAsSelectionNode() const { return 0; }
+    virtual const qglslang::TIntermSwitch*        getAsSwitchNode()    const { return 0; }
+    virtual const qglslang::TIntermMethod*        getAsMethodNode()    const { return 0; }
+    virtual const qglslang::TIntermSymbol*        getAsSymbolNode()    const { return 0; }
+    virtual const qglslang::TIntermBranch*        getAsBranchNode()    const { return 0; }
+    virtual const qglslang::TIntermLoop*          getAsLoopNode()      const { return 0; }
     virtual ~TIntermNode() { }
 
 protected:
     TIntermNode(const TIntermNode&);
     TIntermNode& operator=(const TIntermNode&);
-    glslang::TSourceLoc loc;
+    qglslang::TSourceLoc loc;
 };
 
-namespace glslang {
+namespace qglslang {
 
 //
 // This is just to help yacc.
@@ -1777,7 +1777,7 @@ enum TVisit
 //
 class TIntermTraverser {
 public:
-    POOL_ALLOCATOR_NEW_DELETE(glslang::GetThreadPoolAllocator())
+    POOL_ALLOCATOR_NEW_DELETE(qglslang::GetThreadPoolAllocator())
     TIntermTraverser(bool preVisit = true, bool inVisit = false, bool postVisit = false, bool rightToLeft = false) :
             preVisit(preVisit),
             inVisit(inVisit),
@@ -1840,6 +1840,6 @@ inline bool SameSpecializationConstants(TIntermTyped* node1, TIntermTyped* node2
            node1->getAsSymbolNode()->getId() == node2->getAsSymbolNode()->getId();
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // __INTERMEDIATE_H
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Constant.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/Constant.cpp
index 5fc61dbb..49e45b85 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Constant.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Constant.cpp
@@ -44,14 +44,14 @@
 
 namespace {
 
-using namespace glslang;
+using namespace qglslang;
 
 const double pi = 3.1415926535897932384626433832795;
 
 } // end anonymous namespace
 
 
-namespace glslang {
+namespace qglslang {
 
 //
 // The fold functions see if an operation on a constant can be done in place,
@@ -1395,4 +1395,4 @@ TIntermTyped* TIntermediate::foldSwizzle(TIntermTyped* node, TSwizzleSelectors<T
     return result;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/InfoSink.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/InfoSink.cpp
index d00c4225..d781158b 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/InfoSink.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/InfoSink.cpp
@@ -36,7 +36,7 @@
 
 #include <cstring>
 
-namespace glslang {
+namespace qglslang {
 
 void TInfoSinkBase::append(const char* s)
 {
@@ -110,4 +110,4 @@ void TInfoSinkBase::append(const TString& t)
         fprintf(stdout, "%s", t.c_str());
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.cpp
index b18b2575..7eb532ed 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.cpp
@@ -54,7 +54,7 @@
 #include "../Include/intermediate.h"
 #include "Initialize.h"
 
-namespace glslang {
+namespace qglslang {
 
 // TODO: ARB_Compatability: do full extension support
 const bool ARBCompatibility = true;
@@ -9795,4 +9795,4 @@ void TBuiltIns::identifyBuiltIns(int version, EProfile profile, const SpvVersion
 #endif
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.h b/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.h
index ac8ec33e..202e47fe 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Initialize.h
@@ -43,7 +43,7 @@
 #include "SymbolTable.h"
 #include "Versions.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // This is made to hold parseable strings for almost all the built-in
@@ -107,6 +107,6 @@ protected:
     int dimMap[EsdNumDims];
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _INITIALIZE_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/IntermTraverse.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/IntermTraverse.cpp
index 553b1b5f..469ad0de 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/IntermTraverse.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/IntermTraverse.cpp
@@ -37,7 +37,7 @@
 
 #include "../Include/intermediate.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Traverse the intermediate representation tree, and
@@ -306,4 +306,4 @@ void TIntermSwitch::traverse(TIntermTraverser* it)
         it->visitSwitch(EvPostVisit, this);
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Intermediate.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/Intermediate.cpp
index 14fd053a..485722c4 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Intermediate.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Intermediate.cpp
@@ -49,7 +49,7 @@
 #include <utility>
 #include <tuple>
 
-namespace glslang {
+namespace qglslang {
 
 ////////////////////////////////////////////////////////////////////////////
 //
@@ -88,7 +88,7 @@ TIntermSymbol* TIntermediate::addSymbol(const TIntermSymbol& intermSymbol)
 
 TIntermSymbol* TIntermediate::addSymbol(const TVariable& variable)
 {
-    glslang::TSourceLoc loc; // just a null location
+    qglslang::TSourceLoc loc; // just a null location
     loc.init();
 
     return addSymbol(variable, loc);
@@ -2789,7 +2789,7 @@ bool TIntermediate::postProcess(TIntermNode* root, EShLanguage /*language*/)
 
 #ifndef GLSLANG_WEB
     // Propagate 'noContraction' label in backward from 'precise' variables.
-    glslang::PropagateNoContraction(*this);
+    qglslang::PropagateNoContraction(*this);
 
     switch (textureSamplerTransformMode) {
     case EShTexSampTransKeep:
@@ -4024,4 +4024,4 @@ const char* TIntermediate::getResourceName(TResourceType res)
 }
 
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/LiveTraverser.h b/src/3rdparty/glslang/glslang/MachineIndependent/LiveTraverser.h
index 9b39b598..8432b74f 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/LiveTraverser.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/LiveTraverser.h
@@ -44,7 +44,7 @@
 #include <list>
 #include <unordered_set>
 
-namespace glslang {
+namespace qglslang {
 
 //
 // The traverser: mostly pass through, except
@@ -165,4 +165,4 @@ private:
     TLiveTraverser& operator=(TLiveTraverser&);
 };
 
-} // namespace glslang
+} // namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/ParseContextBase.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/ParseContextBase.cpp
index 616580f9..df9db2d5 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/ParseContextBase.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/ParseContextBase.cpp
@@ -40,9 +40,9 @@
 
 #include "ParseHelper.h"
 
-extern int yyparse(glslang::TParseContext*);
+extern int yyparse(qglslang::TParseContext*);
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Used to output syntax, parsing, and semantic errors.
@@ -735,4 +735,4 @@ void TParseContextBase::finish()
     intermediate.addSymbolLinkageNodes(linkage, getLanguage(), symbolTable);
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.cpp
index 45a72d93..ccc0d4e4 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.cpp
@@ -45,9 +45,9 @@
 
 #include "preprocessor/PpContext.h"
 
-extern int yyparse(glslang::TParseContext*);
+extern int yyparse(qglslang::TParseContext*);
 
-namespace glslang {
+namespace qglslang {
 
 TParseContext::TParseContext(TSymbolTable& symbolTable, TIntermediate& interm, bool parsingBuiltins,
                              int version, EProfile profile, const SpvVersion& spvVersion, EShLanguage language,
@@ -409,7 +409,7 @@ void TParseContext::handlePragma(const TSourceLoc& loc, const TVector<TString>&
     } else if (spvVersion.spv > 0 && tokens[0].compare("use_variable_pointers") == 0) {
         if (tokens.size() != 1)
             error(loc, "extra tokens", "#pragma", "");
-        if (spvVersion.spv < glslang::EShTargetSpv_1_3)
+        if (spvVersion.spv < qglslang::EShTargetSpv_1_3)
             error(loc, "requires SPIR-V 1.3", "#pragma use_variable_pointers", "");
         intermediate.setUseVariablePointers();
     } else if (tokens[0].compare("once") == 0) {
@@ -3694,7 +3694,7 @@ void TParseContext::transparentOpaqueCheck(const TSourceLoc& loc, const TType& t
 //
 // Qualifier checks knowing the qualifier and that it is a member of a struct/block.
 //
-void TParseContext::memberQualifierCheck(glslang::TPublicType& publicType)
+void TParseContext::memberQualifierCheck(qglslang::TPublicType& publicType)
 {
     globalQualifierFixCheck(publicType.loc, publicType.qualifier, true);
     checkNoShaderLayouts(publicType.loc, publicType.shaderQualifiers);
@@ -4194,7 +4194,7 @@ void TParseContext::arraySizeCheck(const TSourceLoc& loc, TIntermTyped* expr, TA
             if (symbol && symbol->getConstArray().size() > 0)
                 size = symbol->getConstArray()[0].getIConst();
         } else if (expr->getAsUnaryNode() &&
-                   expr->getAsUnaryNode()->getOp() == glslang::EOpArrayLength &&
+                   expr->getAsUnaryNode()->getOp() == qglslang::EOpArrayLength &&
                    expr->getAsUnaryNode()->getOperand()->getType().isCoopMat()) {
             isConst = true;
             size = 1;
@@ -7765,7 +7765,7 @@ TIntermTyped* TParseContext::constructBuiltIn(const TType& type, TOperator op, T
     // the recursive call work, and avoids the most egregious case of creating integer matrices.
     if (node->getType().isMatrix() && (type.isScalar() || type.isVector()) &&
             type.isFloatingDomain() != node->getType().isFloatingDomain()) {
-        TType transitionType(node->getBasicType(), glslang::EvqTemporary, type.getVectorSize(), 0, 0, node->isVector());
+        TType transitionType(node->getBasicType(), qglslang::EvqTemporary, type.getVectorSize(), 0, 0, node->isVector());
         TOperator transitionOp = intermediate.mapTypeToConstructorOp(transitionType);
         node = constructBuiltIn(transitionType, transitionOp, node, loc, false);
     }
@@ -9353,5 +9353,5 @@ const TTypeList* TParseContext::recordStructCopy(TStructRecord& record, const TT
     return originStruct;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.h b/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.h
index 885fd908..51478097 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/ParseHelper.h
@@ -55,7 +55,7 @@
 #include "Scan.h"
 #include "attribute.h"
 
-namespace glslang {
+namespace qglslang {
 
 struct TPragma {
     TPragma(bool o, bool d) : optimize(o), debug(d) { }
@@ -392,7 +392,7 @@ public:
     void atomicUintCheck(const TSourceLoc&, const TType&, const TString& identifier);
     void accStructCheck(const TSourceLoc & loc, const TType & type, const TString & identifier);
     void transparentOpaqueCheck(const TSourceLoc&, const TType&, const TString& identifier);
-    void memberQualifierCheck(glslang::TPublicType&);
+    void memberQualifierCheck(qglslang::TPublicType&);
     void globalQualifierFixCheck(const TSourceLoc&, TQualifier&, bool isMemberCheck = false);
     void globalQualifierTypeCheck(const TSourceLoc&, const TQualifier&, const TPublicType&);
     bool structQualifierErrorCheck(const TSourceLoc&, const TPublicType& pType);
@@ -583,6 +583,6 @@ protected:
 #endif
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _PARSER_HELPER_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/PoolAlloc.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/PoolAlloc.cpp
index 84c40f4e..b14ce11d 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/PoolAlloc.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/PoolAlloc.cpp
@@ -38,7 +38,7 @@
 #include "../Include/InitializeGlobals.h"
 #include "../OSDependent/osinclude.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Process-wide TLS index
 OS_TLSIndex PoolIndex;
@@ -312,4 +312,4 @@ void TAllocation::checkAllocList() const
         alloc->check();
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.cpp
index 1d33bfd2..bca453e1 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.cpp
@@ -37,7 +37,7 @@
 #include "../Include/intermediate.h"
 #include "RemoveTree.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Code to recursively delete the intermediate tree.
@@ -115,4 +115,4 @@ void RemoveAllTreeNodes(TIntermNode* root)
     root->traverse(&it);
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.h b/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.h
index 1ed01562..ed61aa72 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/RemoveTree.h
@@ -34,8 +34,8 @@
 
 #pragma once
 
-namespace glslang {
+namespace qglslang {
 
 void RemoveAllTreeNodes(TIntermNode*);
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Scan.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/Scan.cpp
index f53677f9..a856b6f6 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Scan.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Scan.cpp
@@ -58,9 +58,9 @@
 #include "preprocessor/PpTokens.h"
 
 // Required to avoid missing prototype warnings for some compilers
-int yylex(YYSTYPE*, glslang::TParseContext&);
+int yylex(YYSTYPE*, qglslang::TParseContext&);
 
-namespace glslang {
+namespace qglslang {
 
 // read past any white space
 void TInputScanner::consumeWhiteSpace(bool& foundNonSpaceTab)
@@ -286,12 +286,12 @@ protected:
     TParserToken& operator=(TParserToken&);
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 // This is the function the glslang parser (i.e., bison) calls to get its next token
-int yylex(YYSTYPE* glslangTokenDesc, glslang::TParseContext& parseContext)
+int yylex(YYSTYPE* glslangTokenDesc, qglslang::TParseContext& parseContext)
 {
-    glslang::TParserToken token(*glslangTokenDesc);
+    qglslang::TParserToken token(*glslangTokenDesc);
 
     return parseContext.getScanContext()->tokenize(parseContext.getPpContext(), token);
 }
@@ -330,7 +330,7 @@ std::unordered_set<const char*, str_hash, str_eq>* ReservedSet = nullptr;
 
 };
 
-namespace glslang {
+namespace qglslang {
 
 void TScanContext::fillInKeywordMap()
 {
@@ -1956,4 +1956,4 @@ int TScanContext::secondGenerationImage()
     return identifierOrType();
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Scan.h b/src/3rdparty/glslang/glslang/MachineIndependent/Scan.h
index 24b75cf7..39f95d71 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Scan.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Scan.h
@@ -38,7 +38,7 @@
 
 #include "Versions.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Use a global end-of-input character, so no translation is needed across
 // layers of encapsulation.  Characters are all 8 bit, and positive, so there is
@@ -271,6 +271,6 @@ protected:
     bool endOfFileReached;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _GLSLANG_SCAN_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/ScanContext.h b/src/3rdparty/glslang/glslang/MachineIndependent/ScanContext.h
index 74b2b3c7..aa07a133 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/ScanContext.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/ScanContext.h
@@ -42,7 +42,7 @@
 
 #include "ParseHelper.h"
 
-namespace glslang {
+namespace qglslang {
 
 class TPpContext;
 class TPpToken;
@@ -90,4 +90,4 @@ protected:
     int keyword;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/ShaderLang.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/ShaderLang.cpp
index 3f7a4675..55bdebfe 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/ShaderLang.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/ShaderLang.cpp
@@ -81,7 +81,7 @@ namespace { // anonymous namespace for file-local functions and symbols
 // Shared global; access should be protected by a global mutex/critical section.
 int NumberOfClients = 0;
 
-using namespace glslang;
+using namespace qglslang;
 
 // Create a language specific version of parseables.
 TBuiltInParseables* CreateBuiltInParseables(TInfoSink& infoSink, EShSource source)
@@ -437,7 +437,7 @@ void SetupBuiltinSymbolTable(int version, EProfile profile, const SpvVersion& sp
     TInfoSink infoSink;
 
     // Make sure only one thread tries to do this at a time
-    glslang::GetGlobalLock();
+    qglslang::GetGlobalLock();
 
     // See if it's already been done for this version/profile combination
     int versionIndex = MapVersionToIndex(version);
@@ -445,7 +445,7 @@ void SetupBuiltinSymbolTable(int version, EProfile profile, const SpvVersion& sp
     int profileIndex = MapProfileToIndex(profile);
     int sourceIndex = MapSourceToIndex(source);
     if (CommonSymbolTable[versionIndex][spvVersionIndex][profileIndex][sourceIndex][EPcGeneral]) {
-        glslang::ReleaseGlobalLock();
+        qglslang::ReleaseGlobalLock();
 
         return;
     }
@@ -496,7 +496,7 @@ void SetupBuiltinSymbolTable(int version, EProfile profile, const SpvVersion& sp
     delete builtInPoolAllocator;
     SetThreadPoolAllocator(&previousAllocator);
 
-    glslang::ReleaseGlobalLock();
+    qglslang::ReleaseGlobalLock();
 }
 
 // Function to Print all builtins
@@ -875,7 +875,7 @@ bool ProcessDeferred(
     // First, without using the preprocessor or parser, find the #version, so we know what
     // symbol tables, processing rules, etc. to set up.  This does not need the extra strings
     // outlined above, just the user shader, after the system and user preambles.
-    glslang::TInputScanner userInput(numStrings, &strings[numPre], &lengths[numPre]);
+    qglslang::TInputScanner userInput(numStrings, &strings[numPre], &lengths[numPre]);
     int version = 0;
     EProfile profile = ENoProfile;
     bool versionNotFirstToken = false;
@@ -981,7 +981,7 @@ bool ProcessDeferred(
     TPpContext ppContext(*parseContext, names[numPre] ? names[numPre] : "", includer);
 
     // only GLSL (bison triggered, really) needs an externally set scan context
-    glslang::TScanContext scanContext(*parseContext);
+    qglslang::TScanContext scanContext(*parseContext);
     if (source == EShSourceGlsl)
         parseContext->setScanContext(&scanContext);
 
@@ -1108,7 +1108,7 @@ struct DoPreprocessing {
         // This is a list of tokens that do not require a space before or after.
         static const std::string unNeededSpaceTokens = ";()[]";
         static const std::string noSpaceBeforeTokens = ",";
-        glslang::TPpToken ppToken;
+        qglslang::TPpToken ppToken;
 
         parseContext.setScanner(&input);
         ppContext.setInput(input, versionWillBeError);
@@ -1164,7 +1164,7 @@ struct DoPreprocessing {
             });
 
         parseContext.setPragmaCallback([&lineSync, &outputBuffer](
-            int line, const glslang::TVector<glslang::TString>& ops) {
+            int line, const qglslang::TVector<qglslang::TString>& ops) {
                 lineSync.syncToLine(line);
                 outputBuffer += "#pragma ";
                 for(size_t i = 0; i < ops.size(); ++i) {
@@ -1342,23 +1342,23 @@ bool CompileDeferred(
 //
 int ShInitialize()
 {
-    glslang::InitGlobalLock();
+    qglslang::InitGlobalLock();
 
     if (! InitProcess())
         return 0;
 
-    glslang::GetGlobalLock();
+    qglslang::GetGlobalLock();
     ++NumberOfClients;
 
     if (PerProcessGPA == nullptr)
         PerProcessGPA = new TPoolAllocator();
 
-    glslang::TScanContext::fillInKeywordMap();
+    qglslang::TScanContext::fillInKeywordMap();
 #ifdef ENABLE_HLSL
-    glslang::HlslScanContext::fillInKeywordMap();
+    qglslang::HlslScanContext::fillInKeywordMap();
 #endif
 
-    glslang::ReleaseGlobalLock();
+    qglslang::ReleaseGlobalLock();
     return 1;
 }
 
@@ -1417,12 +1417,12 @@ void ShDestruct_Qt(ShHandle handle)
 //
 int ShFinalize_Qt()
 {
-    glslang::GetGlobalLock();
+    qglslang::GetGlobalLock();
     --NumberOfClients;
     assert(NumberOfClients >= 0);
     bool finalize = NumberOfClients == 0;
     if (! finalize) {
-        glslang::ReleaseGlobalLock();
+        qglslang::ReleaseGlobalLock();
         return 1;
     }
 
@@ -1457,12 +1457,12 @@ int ShFinalize_Qt()
         PerProcessGPA = nullptr;
     }
 
-    glslang::TScanContext::deleteKeywordMap();
+    qglslang::TScanContext::deleteKeywordMap();
 #ifdef ENABLE_HLSL
-    glslang::HlslScanContext::deleteKeywordMap();
+    qglslang::HlslScanContext::deleteKeywordMap();
 #endif
 
-    glslang::ReleaseGlobalLock();
+    qglslang::ReleaseGlobalLock();
     return 1;
 }
 
@@ -1716,7 +1716,7 @@ int ShGetUniformLocation(const ShHandle handle, const char* name)
 // See more detailed comment in ShaderLang.h
 //
 
-namespace glslang {
+namespace qglslang {
 
 Version GetVersion()
 {
@@ -2252,4 +2252,4 @@ bool TProgram::mapIO(TIoMapResolver* pResolver, TIoMapper* pIoMapper)
 
 #endif // !GLSLANG_WEB && !GLSLANG_ANGLE
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/SpirvIntrinsics.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/SpirvIntrinsics.cpp
index 6650f7d9..af68fcf0 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/SpirvIntrinsics.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/SpirvIntrinsics.cpp
@@ -43,7 +43,7 @@
 #include "../Include/Types.h"
 #include "ParseHelper.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Handle SPIR-V requirements
@@ -345,6 +345,6 @@ TSpirvInstruction* TParseContext::mergeSpirvInstruction(const TSourceLoc& loc, T
     return spirvInst1;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // GLSLANG_WEB
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.cpp
index a3ffa0c4..59490630 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.cpp
@@ -44,7 +44,7 @@
 
 #include "SymbolTable.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // TType helper function needs a place to live.
@@ -474,4 +474,4 @@ void TSymbolTable::copyTable(const TSymbolTable& copyOf)
         table.push_back(copyOf.table[i]->clone());
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.h b/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.h
index 31312ecb..e4391e81 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/SymbolTable.h
@@ -69,7 +69,7 @@
 #include "../Include/intermediate.h"
 #include "../Include/InfoSink.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Symbol base class.  (Can build functions or variables out of these...)
@@ -950,6 +950,6 @@ protected:
     unsigned int adoptedLevels;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _SYMBOL_TABLE_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Versions.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/Versions.cpp
index 52c1e1cc..888d8f43 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Versions.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Versions.cpp
@@ -149,7 +149,7 @@
 #include "parseVersions.h"
 #include "localintermediate.h"
 
-namespace glslang {
+namespace qglslang {
 
 #ifndef GLSLANG_WEB
 
@@ -1349,4 +1349,4 @@ void TParseVersions::requireSpv(const TSourceLoc& loc, const char *op, unsigned
 #endif
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/Versions.h b/src/3rdparty/glslang/glslang/MachineIndependent/Versions.h
index c411f5b6..ae1d7418 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/Versions.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/Versions.h
@@ -62,7 +62,7 @@ typedef enum : unsigned {
     LAST_ELEMENT_MARKER(EProfileCount),
 } EProfile;
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Map from profile enum to externally readable text name.
@@ -344,6 +344,6 @@ const int Num_AEP_texture_buffer = sizeof(AEP_texture_buffer)/sizeof(AEP_texture
 const char* const AEP_texture_cube_map_array[] = { E_GL_EXT_texture_cube_map_array, E_GL_OES_texture_cube_map_array };
 const int Num_AEP_texture_cube_map_array = sizeof(AEP_texture_cube_map_array)/sizeof(AEP_texture_cube_map_array[0]);
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _VERSIONS_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/attribute.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/attribute.cpp
index df7fdc2a..9b79ebbc 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/attribute.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/attribute.cpp
@@ -40,7 +40,7 @@
 #include "../Include/intermediate.h"
 #include "ParseHelper.h"
 
-namespace glslang {
+namespace qglslang {
 
 // extract integers out of attribute arguments stored in attribute aggregate
 bool TAttributeArgs::getInt(int& value, int argNum) const 
@@ -366,6 +366,6 @@ void TParseContext::handleFunctionAttributes(const TSourceLoc& loc, const TAttri
     }
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // GLSLANG_WEB
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/attribute.h b/src/3rdparty/glslang/glslang/MachineIndependent/attribute.h
index c5b29176..6a322be2 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/attribute.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/attribute.h
@@ -40,7 +40,7 @@
 #include "../Include/Common.h"
 #include "../Include/ConstantUnion.h"
 
-namespace glslang {
+namespace qglslang {
 
     enum TAttributeType {
         EatNone,
@@ -145,6 +145,6 @@ namespace glslang {
 
     typedef TList<TAttributeArgs> TAttributes;
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _ATTRIBUTE_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/glslang.y b/src/3rdparty/glslang/glslang/MachineIndependent/glslang.y
index d77c8315..b5e396fe 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/glslang.y
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/glslang.y
@@ -96,9 +96,9 @@ using namespace glslang;
 
 %union {
     struct {
-        glslang::TSourceLoc loc;
+        qglslang::TSourceLoc loc;
         union {
-            glslang::TString *string;
+            qglslang::TString *string;
             int i;
             unsigned int u;
             long long i64;
@@ -106,30 +106,30 @@ using namespace glslang;
             bool b;
             double d;
         };
-        glslang::TSymbol* symbol;
+        qglslang::TSymbol* symbol;
     } lex;
     struct {
-        glslang::TSourceLoc loc;
-        glslang::TOperator op;
+        qglslang::TSourceLoc loc;
+        qglslang::TOperator op;
         union {
             TIntermNode* intermNode;
-            glslang::TIntermNodePair nodePair;
-            glslang::TIntermTyped* intermTypedNode;
-            glslang::TAttributes* attributes;
-            glslang::TSpirvRequirement* spirvReq;
-            glslang::TSpirvInstruction* spirvInst;
-            glslang::TSpirvTypeParameters* spirvTypeParams;
+            qglslang::TIntermNodePair nodePair;
+            qglslang::TIntermTyped* intermTypedNode;
+            qglslang::TAttributes* attributes;
+            qglslang::TSpirvRequirement* spirvReq;
+            qglslang::TSpirvInstruction* spirvInst;
+            qglslang::TSpirvTypeParameters* spirvTypeParams;
         };
         union {
-            glslang::TPublicType type;
-            glslang::TFunction* function;
-            glslang::TParameter param;
-            glslang::TTypeLoc typeLine;
-            glslang::TTypeList* typeList;
-            glslang::TArraySizes* arraySizes;
-            glslang::TIdentifierList* identifierList;
+            qglslang::TPublicType type;
+            qglslang::TFunction* function;
+            qglslang::TParameter param;
+            qglslang::TTypeLoc typeLine;
+            qglslang::TTypeList* typeList;
+            qglslang::TArraySizes* arraySizes;
+            qglslang::TIdentifierList* identifierList;
         };
-        glslang::TArraySizes* typeParameters;
+        qglslang::TArraySizes* typeParameters;
     } interm;
 }
 
@@ -149,7 +149,7 @@ extern int yylex(YYSTYPE*, TParseContext&);
 
 %}
 
-%parse-param {glslang::TParseContext* pParseContext}
+%parse-param {qglslang::TParseContext* pParseContext}
 %lex-param {parseContext}
 %pure-parser  // enable thread safety
 %expect 1     // One shift reduce conflict because of if | else
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp
index 4e4768ea..9395e6ea 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp
@@ -90,7 +90,7 @@ Jutta Degener, 1995
 #include "../Public/ShaderLang.h"
 #include "attribute.h"
 
-using namespace glslang;
+using namespace qglslang;
 
 
 #line 97 "MachineIndependent/glslang_tab.cpp"
@@ -4507,7 +4507,7 @@ do {                                                                      \
 
 static void
 yy_symbol_value_print (FILE *yyo,
-                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, glslang::TParseContext* pParseContext)
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, qglslang::TParseContext* pParseContext)
 {
   FILE *yyoutput = yyo;
   YYUSE (yyoutput);
@@ -4530,7 +4530,7 @@ yy_symbol_value_print (FILE *yyo,
 
 static void
 yy_symbol_print (FILE *yyo,
-                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, glslang::TParseContext* pParseContext)
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, qglslang::TParseContext* pParseContext)
 {
   YYFPRINTF (yyo, "%s %s (",
              yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
@@ -4569,7 +4569,7 @@ do {                                                            \
 
 static void
 yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
-                 int yyrule, glslang::TParseContext* pParseContext)
+                 int yyrule, qglslang::TParseContext* pParseContext)
 {
   int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
@@ -4898,7 +4898,7 @@ yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
 
 static void
 yydestruct (const char *yymsg,
-            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, glslang::TParseContext* pParseContext)
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, qglslang::TParseContext* pParseContext)
 {
   YYUSE (yyvaluep);
   YYUSE (pParseContext);
@@ -4921,7 +4921,7 @@ yydestruct (const char *yymsg,
 `----------*/
 
 int
-yyparse (glslang::TParseContext* pParseContext)
+yyparse (qglslang::TParseContext* pParseContext)
 {
 /* Lookahead token kind.  */
 int yychar;
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp.h b/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp.h
index a6871b31..5be6f012 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/glslang_tab.cpp.h
@@ -518,9 +518,9 @@ union YYSTYPE
 #line 97 "MachineIndependent/glslang.y"
 
     struct {
-        glslang::TSourceLoc loc;
+        qglslang::TSourceLoc loc;
         union {
-            glslang::TString *string;
+            qglslang::TString *string;
             int i;
             unsigned int u;
             long long i64;
@@ -528,30 +528,30 @@ union YYSTYPE
             bool b;
             double d;
         };
-        glslang::TSymbol* symbol;
+        qglslang::TSymbol* symbol;
     } lex;
     struct {
-        glslang::TSourceLoc loc;
-        glslang::TOperator op;
+        qglslang::TSourceLoc loc;
+        qglslang::TOperator op;
         union {
             TIntermNode* intermNode;
-            glslang::TIntermNodePair nodePair;
-            glslang::TIntermTyped* intermTypedNode;
-            glslang::TAttributes* attributes;
-            glslang::TSpirvRequirement* spirvReq;
-            glslang::TSpirvInstruction* spirvInst;
-            glslang::TSpirvTypeParameters* spirvTypeParams;
+            qglslang::TIntermNodePair nodePair;
+            qglslang::TIntermTyped* intermTypedNode;
+            qglslang::TAttributes* attributes;
+            qglslang::TSpirvRequirement* spirvReq;
+            qglslang::TSpirvInstruction* spirvInst;
+            qglslang::TSpirvTypeParameters* spirvTypeParams;
         };
         union {
-            glslang::TPublicType type;
-            glslang::TFunction* function;
-            glslang::TParameter param;
-            glslang::TTypeLoc typeLine;
-            glslang::TTypeList* typeList;
-            glslang::TArraySizes* arraySizes;
-            glslang::TIdentifierList* identifierList;
+            qglslang::TPublicType type;
+            qglslang::TFunction* function;
+            qglslang::TParameter param;
+            qglslang::TTypeLoc typeLine;
+            qglslang::TTypeList* typeList;
+            qglslang::TArraySizes* arraySizes;
+            qglslang::TIdentifierList* identifierList;
         };
-        glslang::TArraySizes* typeParameters;
+        qglslang::TArraySizes* typeParameters;
     } interm;
 
 #line 558 "MachineIndependent/glslang_tab.cpp.h"
@@ -564,6 +564,6 @@ typedef union YYSTYPE YYSTYPE;
 
 
 
-int yyparse (glslang::TParseContext* pParseContext);
+int yyparse (qglslang::TParseContext* pParseContext);
 
 #endif /* !YY_YY_MACHINEINDEPENDENT_GLSLANG_TAB_CPP_H_INCLUDED  */
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/intermOut.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/intermOut.cpp
index d8a3aab5..86ed8d32 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/intermOut.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/intermOut.cpp
@@ -49,7 +49,7 @@
 #include <cstdint>
 
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Two purposes:
@@ -1556,6 +1556,6 @@ void TIntermediate::output(TInfoSink& infoSink, bool tree)
     treeRoot->traverse(&it);
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // !GLSLANG_WEB && !GLSLANG_ANGLE
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.cpp
index 4250e92d..502322dd 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.cpp
@@ -60,7 +60,7 @@
 //    c. implicit dead bindings are left un-bound.
 //
 
-namespace glslang {
+namespace qglslang {
 
 class TVarGatherTraverser : public TLiveTraverser {
 public:
@@ -468,7 +468,7 @@ struct TSymbolValidater
                 auto ent2 = outVarMaps[preStage]->find(name);
                 uint32_t location = base->getType().getQualifier().layoutLocation;
                 if (ent2 == outVarMaps[preStage]->end() &&
-                    location != glslang::TQualifier::layoutLocationEnd) {
+                    location != qglslang::TQualifier::layoutLocationEnd) {
                     for (auto var = outVarMaps[preStage]->begin(); var != ent2; var++) {
                         if (var->second.symbol->getType().getQualifier().layoutLocation == location) {
                             ent2 = var;
@@ -511,7 +511,7 @@ struct TSymbolValidater
                         if (type1.getBasicType() == EbtBlock &&
                             type1.isStruct() && !type2.isStruct()) {
                             // Iterate through block members tracking layout
-                            glslang::TString name;
+                            qglslang::TString name;
                             type1.getStruct()->begin()->type->appendMangledName(name);
                             if (name == mangleName2
                                 && type1.getQualifier().layoutLocation == type2.getQualifier().layoutLocation) return;
@@ -519,7 +519,7 @@ struct TSymbolValidater
                         if (type2.getBasicType() == EbtBlock &&
                             type2.isStruct() && !type1.isStruct()) {
                             // Iterate through block members tracking layout
-                            glslang::TString name;
+                            qglslang::TString name;
                             type2.getStruct()->begin()->type->appendMangledName(name);
                             if (name == mangleName1
                                 && type1.getQualifier().layoutLocation == type2.getQualifier().layoutLocation) return;
@@ -912,7 +912,7 @@ uint32_t TDefaultIoResolverBase::computeTypeLocationSize(const TType& type, EShL
 }
 
 //TDefaultGlslIoResolver
-TResourceType TDefaultGlslIoResolver::getResourceType(const glslang::TType& type) {
+TResourceType TDefaultGlslIoResolver::getResourceType(const qglslang::TType& type) {
     if (isImageType(type)) {
         return EResImage;
     }
@@ -1262,7 +1262,7 @@ void TDefaultGlslIoResolver::reserverResourceSlot(TVarEntryInfo& ent, TInfoSink&
 //TDefaultGlslIoResolver end
 
 /*
- * Basic implementation of glslang::TIoMapResolver that replaces the
+ * Basic implementation of qglslang::TIoMapResolver that replaces the
  * previous offset behavior.
  * It does the same, uses the offsets for the corresponding uniform
  * types. Also respects the EOptionAutoMapBindings flag and binds
@@ -1276,7 +1276,7 @@ struct TDefaultIoResolver : public TDefaultIoResolverBase {
 
     bool validateBinding(EShLanguage /*stage*/, TVarEntryInfo& /*ent*/) override { return true; }
 
-    TResourceType getResourceType(const glslang::TType& type) override {
+    TResourceType getResourceType(const qglslang::TType& type) override {
         if (isImageType(type)) {
             return EResImage;
         }
@@ -1364,7 +1364,7 @@ struct TDefaultHlslIoResolver : public TDefaultIoResolverBase {
 
     bool validateBinding(EShLanguage /*stage*/, TVarEntryInfo& /*ent*/) override { return true; }
 
-    TResourceType getResourceType(const glslang::TType& type) override {
+    TResourceType getResourceType(const qglslang::TType& type) override {
         if (isUavType(type)) {
             return EResUav;
         }
@@ -1708,6 +1708,6 @@ bool TGlslIoMapper::doMap(TIoMapResolver* resolver, TInfoSink& infoSink) {
     }
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // !GLSLANG_WEB && !GLSLANG_ANGLE
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.h b/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.h
index ba7bc3bb..6271eb07 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/iomapper.h
@@ -48,7 +48,7 @@
 
 class TInfoSink;
 
-namespace glslang {
+namespace qglslang {
 
 class TIntermediate;
 struct TVarEntryInfo {
@@ -128,7 +128,7 @@ struct TVarEntryInfo {
 };
 
 // Base class for shared TIoMapResolver services, used by several derivations.
-struct TDefaultIoResolverBase : public glslang::TIoMapResolver {
+struct TDefaultIoResolverBase : public qglslang::TIoMapResolver {
 public:
     TDefaultIoResolverBase(const TIntermediate& intermediate);
     typedef std::vector<int> TSlotSet;
@@ -147,7 +147,7 @@ public:
     void reserverStorageSlot(TVarEntryInfo& /*ent*/, TInfoSink& /*infoSink*/) override {}
     int getBaseBinding(EShLanguage stage, TResourceType res, unsigned int set) const;
     const std::vector<std::string>& getResourceSetBinding(EShLanguage stage) const;
-    virtual TResourceType getResourceType(const glslang::TType& type) = 0;
+    virtual TResourceType getResourceType(const qglslang::TType& type) = 0;
     bool doAutoBindingMapping() const;
     bool doAutoLocationMapping() const;
     TSlotSet::iterator findSlot(int set, int slot);
@@ -186,44 +186,44 @@ protected:
         return descriptorSetBase != -1 ? descriptorSetBase : base;
     }
 
-    static int getLayoutSet(const glslang::TType& type) {
+    static int getLayoutSet(const qglslang::TType& type) {
         if (type.getQualifier().hasSet())
             return type.getQualifier().layoutSet;
         else
             return 0;
     }
 
-    static bool isSamplerType(const glslang::TType& type) {
-        return type.getBasicType() == glslang::EbtSampler && type.getSampler().isPureSampler();
+    static bool isSamplerType(const qglslang::TType& type) {
+        return type.getBasicType() == qglslang::EbtSampler && type.getSampler().isPureSampler();
     }
 
-    static bool isTextureType(const glslang::TType& type) {
-        return (type.getBasicType() == glslang::EbtSampler &&
+    static bool isTextureType(const qglslang::TType& type) {
+        return (type.getBasicType() == qglslang::EbtSampler &&
                 (type.getSampler().isTexture() || type.getSampler().isSubpass()));
     }
 
-    static bool isUboType(const glslang::TType& type) {
+    static bool isUboType(const qglslang::TType& type) {
         return type.getQualifier().storage == EvqUniform;
     }
 
-    static bool isImageType(const glslang::TType& type) {
-        return type.getBasicType() == glslang::EbtSampler && type.getSampler().isImage();
+    static bool isImageType(const qglslang::TType& type) {
+        return type.getBasicType() == qglslang::EbtSampler && type.getSampler().isImage();
     }
 
-    static bool isSsboType(const glslang::TType& type) {
+    static bool isSsboType(const qglslang::TType& type) {
         return type.getQualifier().storage == EvqBuffer;
     }
 
     // Return true if this is a SRV (shader resource view) type:
-    static bool isSrvType(const glslang::TType& type) {
+    static bool isSrvType(const qglslang::TType& type) {
         return isTextureType(type) || type.getQualifier().storage == EvqBuffer;
     }
 
     // Return true if this is a UAV (unordered access view) type:
-    static bool isUavType(const glslang::TType& type) {
+    static bool isUavType(const qglslang::TType& type) {
         if (type.getQualifier().isReadOnly())
             return false;
-        return (type.getBasicType() == glslang::EbtSampler && type.getSampler().isImage()) ||
+        return (type.getBasicType() == qglslang::EbtSampler && type.getSampler().isImage()) ||
                 (type.getQualifier().storage == EvqBuffer);
     }
 };
@@ -235,7 +235,7 @@ public:
     typedef std::map<int, TVarSlotMap> TSlotMap; // <resourceKey, TVarSlotMap>
     TDefaultGlslIoResolver(const TIntermediate& intermediate);
     bool validateBinding(EShLanguage /*stage*/, TVarEntryInfo& /*ent*/) override { return true; }
-    TResourceType getResourceType(const glslang::TType& type) override;
+    TResourceType getResourceType(const qglslang::TType& type) override;
     int resolveInOutLocation(EShLanguage stage, TVarEntryInfo& ent) override;
     int resolveUniformLocation(EShLanguage /*stage*/, TVarEntryInfo& ent) override;
     int resolveBinding(EShLanguage /*stage*/, TVarEntryInfo& ent) override;
@@ -354,7 +354,7 @@ private:
     TLayoutPacking autoPushConstantBlockPacking;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _IOMAPPER_INCLUDED
 
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/limits.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/limits.cpp
index 39157057..0633305b 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/limits.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/limits.cpp
@@ -53,7 +53,7 @@
 
 #include "ParseHelper.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // The inductive loop-body traverser.
@@ -197,4 +197,4 @@ void TParseContext::constantIndexExpressionCheck(TIntermNode* index)
 #endif
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/linkValidate.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/linkValidate.cpp
index 6e60155a..d4866c2f 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/linkValidate.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/linkValidate.cpp
@@ -50,7 +50,7 @@
 #include "../Include/InfoSink.h"
 #include "SymbolTable.h"
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Link-time error emitter.
@@ -640,7 +640,7 @@ void TIntermediate::mergeBlockDefinitions(TInfoSink& infoSink, TIntermSymbol* bl
             : newSymbol(newSym), unitType(nullptr), unit(nullptr), memberIndexUpdates(nullptr)
         {
         }
-        TMergeBlockTraverser(const TIntermSymbol* newSym, const glslang::TType* unitType, glslang::TIntermediate* unit,
+        TMergeBlockTraverser(const TIntermSymbol* newSym, const qglslang::TType* unitType, qglslang::TIntermediate* unit,
                              const std::map<unsigned int, unsigned int>* memberIdxUpdates)
             : TIntermTraverser(false, true), newSymbol(newSym), unitType(unitType), unit(unit), memberIndexUpdates(memberIdxUpdates)
         {
@@ -648,8 +648,8 @@ void TIntermediate::mergeBlockDefinitions(TInfoSink& infoSink, TIntermSymbol* bl
         virtual ~TMergeBlockTraverser() {}
 
         const TIntermSymbol* newSymbol;
-        const glslang::TType* unitType; // copy of original type
-        glslang::TIntermediate* unit;   // intermediate that is being updated
+        const qglslang::TType* unitType; // copy of original type
+        qglslang::TIntermediate* unit;   // intermediate that is being updated
         const std::map<unsigned int, unsigned int>* memberIndexUpdates;
 
         virtual void visitSymbol(TIntermSymbol* symbol)
@@ -662,7 +662,7 @@ void TIntermediate::mergeBlockDefinitions(TInfoSink& infoSink, TIntermSymbol* bl
             }
         }
 
-        virtual bool visitBinary(TVisit, glslang::TIntermBinary* node)
+        virtual bool visitBinary(TVisit, qglslang::TIntermBinary* node)
         {
             if (!unit || !unitType || !memberIndexUpdates || memberIndexUpdates->empty())
                 return true;
@@ -673,7 +673,7 @@ void TIntermediate::mergeBlockDefinitions(TInfoSink& infoSink, TIntermSymbol* bl
                 // right index
                 assert(node->getRight()->getAsConstantUnion());
 
-                glslang::TIntermConstantUnion* constNode = node->getRight()->getAsConstantUnion();
+                qglslang::TIntermConstantUnion* constNode = node->getRight()->getAsConstantUnion();
                 unsigned int memberIdx = constNode->getConstArray()[0].getUConst();
                 unsigned int newIdx = memberIndexUpdates->at(memberIdx);
                 TIntermTyped* newConstNode = unit->addConstantUnion(newIdx, node->getRight()->getLoc());
@@ -1165,8 +1165,8 @@ void TIntermediate::sharedBlockCheck(TInfoSink& infoSink)
     for (size_t i = 0; i < linkObjects.size(); ++i) {
         const TType& type = linkObjects[i]->getAsTyped()->getType();
         const TQualifier& qualifier = type.getQualifier();
-        if (qualifier.storage == glslang::EvqShared) {
-            if (type.getBasicType() == glslang::EbtBlock)
+        if (qualifier.storage == qglslang::EvqShared) {
+            if (type.getBasicType() == qglslang::EbtBlock)
                 has_shared_block = true;
             else
                 has_shared_non_block = true;
@@ -1461,8 +1461,8 @@ void TIntermediate::checkCallGraphBodies(TInfoSink& infoSink, bool keepUncalled)
     TIntermSequence &functionSequence = getTreeRoot()->getAsAggregate()->getSequence();
     std::vector<bool> reachable(functionSequence.size(), true); // so that non-functions are reachable
     for (int f = 0; f < (int)functionSequence.size(); ++f) {
-        glslang::TIntermAggregate* node = functionSequence[f]->getAsAggregate();
-        if (node && (node->getOp() == glslang::EOpFunction)) {
+        qglslang::TIntermAggregate* node = functionSequence[f]->getAsAggregate();
+        if (node && (node->getOp() == qglslang::EOpFunction)) {
             if (node->getName().compare(getEntryPointMangledName().c_str()) != 0)
                 reachable[f] = false; // so that function bodies are unreachable, until proven otherwise
             for (TGraph::iterator call = callGraph.begin(); call != callGraph.end(); ++call) {
@@ -2031,7 +2031,7 @@ int TIntermediate::getBaseAlignment(const TType& type, int& size, int& stride, T
 {
     int alignment;
 
-    bool std140 = layoutPacking == glslang::ElpStd140;
+    bool std140 = layoutPacking == qglslang::ElpStd140;
     // When using the std140 storage layout, structures will be laid out in buffer
     // storage with its members stored in monotonically increasing order based on their
     // location in the declaration. A structure and each structure member have a base
@@ -2252,7 +2252,7 @@ int TIntermediate::getScalarAlignment(const TType& type, int& size, int& stride,
 
 int TIntermediate::getMemberAlignment(const TType& type, int& size, int& stride, TLayoutPacking layoutPacking, bool rowMajor)
 {
-    if (layoutPacking == glslang::ElpScalar) {
+    if (layoutPacking == qglslang::ElpScalar) {
         return getScalarAlignment(type, size, stride, rowMajor);
     } else {
         return getBaseAlignment(type, size, stride, layoutPacking, rowMajor);
@@ -2343,4 +2343,4 @@ bool TIntermediate::isIoResizeArray(const TType& type, EShLanguage language) {
 }
 #endif // not GLSLANG_WEB
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/localintermediate.h b/src/3rdparty/glslang/glslang/MachineIndependent/localintermediate.h
index 581e9aa2..7e503219 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/localintermediate.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/localintermediate.h
@@ -51,7 +51,7 @@
 
 class TInfoSink;
 
-namespace glslang {
+namespace qglslang {
 
 struct TMatrixSelector {
     int coord1;  // stay agnostic about column/row; this is parse order
@@ -1200,6 +1200,6 @@ private:
     void operator=(TIntermediate&); // prevent assignments
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _LOCAL_INTERMEDIATE_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/parseConst.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/parseConst.cpp
index 6c182991..b9c13c38 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/parseConst.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/parseConst.cpp
@@ -39,7 +39,7 @@
 
 #include "ParseHelper.h"
 
-namespace glslang {
+namespace qglslang {
 
 class TConstTraverser : public TIntermTraverser {
 public:
@@ -210,4 +210,4 @@ bool TIntermediate::parseConstTree(TIntermNode* root, TConstUnionArray unionArra
         return false;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/parseVersions.h b/src/3rdparty/glslang/glslang/MachineIndependent/parseVersions.h
index 7248354e..37ce083f 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/parseVersions.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/parseVersions.h
@@ -45,7 +45,7 @@
 
 #include <map>
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Base class for parse helpers.
@@ -240,6 +240,6 @@ private:
     TParseVersions& operator=(const TParseVersions&);
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _PARSE_VERSIONS_INCLUDED_
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp
index aa1e0d74..3bdb15ef 100755
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/Pp.cpp
@@ -90,7 +90,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "PpContext.h"
 #include "PpTokens.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Handle #define
 int TPpContext::CPPdefine(TPpToken* ppToken)
@@ -1343,4 +1343,4 @@ MacroExpandResult TPpContext::MacroExpand(TPpToken* ppToken, bool expandUndef, b
     return MacroExpandStarted;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpAtom.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpAtom.cpp
index 06c2333e..ac635586 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpAtom.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpAtom.cpp
@@ -89,7 +89,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 namespace {
 
-using namespace glslang;
+using namespace qglslang;
 
 const struct {
     int val;
@@ -151,7 +151,7 @@ const struct {
 
 } // end anonymous namespace
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Initialize the atom table.
@@ -178,4 +178,4 @@ TStringAtomMap::TStringAtomMap()
     nextAtom = PpAtomLast;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp
index 1363ce2b..8a38a272 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.cpp
@@ -82,7 +82,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "PpContext.h"
 
-namespace glslang {
+namespace qglslang {
 
 TPpContext::TPpContext(TParseContextBase& pc, const std::string& rootFileName, TShader::Includer& inclr) :
     preamble(0), strings(0), previous_token('\n'), parseContext(pc), includer(inclr), inComment(false),
@@ -117,4 +117,4 @@ void TPpContext::setInput(TInputScanner& input, bool versionWillBeError)
     versionSeen = false;
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.h b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.h
index 714b5ead..4638908e 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpContext.h
@@ -91,7 +91,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     #pragma warning(disable : 4127)
 #endif
 
-namespace glslang {
+namespace qglslang {
 
 class TPpToken {
 public:
@@ -698,6 +698,6 @@ protected:
     bool disableEscapeSequences;
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif  // PPCONTEXT_H
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp
index ad117920..582f0f70 100755
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpScanner.cpp
@@ -90,7 +90,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "PpTokens.h"
 #include "../Scan.h"
 
-namespace glslang {
+namespace qglslang {
 
 ///////////////////////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////// Floating point constants: /////////////////////////////////
@@ -1314,4 +1314,4 @@ void TPpContext::missingEndifCheck()
         parseContext.ppError(parseContext.getCurrentLoc(), "missing #endif", "", "");
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp
index 7ed58703..63b6b181 100755
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.cpp
@@ -97,7 +97,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "PpContext.h"
 #include "PpTokens.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Add a token (including backing string) to the end of a macro
 // token stream, for later playback.
@@ -218,4 +218,4 @@ void TPpContext::UngetToken(int token, TPpToken* ppToken)
     pushInput(new tUngotTokenInput(this, token, ppToken));
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.h b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.h
index 7b0f8155..8f030ffd 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/preprocessor/PpTokens.h
@@ -78,7 +78,7 @@ NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef PARSER_H
 #define PARSER_H
 
-namespace glslang {
+namespace qglslang {
 
 // Multi-character tokens
 enum EFixedAtoms {
@@ -174,6 +174,6 @@ enum EFixedAtoms {
     PpAtomLast,
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif /* not PARSER_H */
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.cpp
index 9def592b..4aea79f2 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.cpp
@@ -68,31 +68,31 @@ const char ObjectAccesschainDelimiter = '/';
 
 // Mapping from Symbol IDs of symbol nodes, to their defining operation
 // nodes.
-typedef std::unordered_multimap<ObjectAccessChain, glslang::TIntermOperator*> NodeMapping;
+typedef std::unordered_multimap<ObjectAccessChain, qglslang::TIntermOperator*> NodeMapping;
 // Mapping from object nodes to their access chain info string.
-typedef std::unordered_map<glslang::TIntermTyped*, ObjectAccessChain> AccessChainMapping;
+typedef std::unordered_map<qglslang::TIntermTyped*, ObjectAccessChain> AccessChainMapping;
 
 // Set of object IDs.
 typedef std::unordered_set<ObjectAccessChain> ObjectAccesschainSet;
 // Set of return branch nodes.
-typedef std::unordered_set<glslang::TIntermBranch*> ReturnBranchNodeSet;
+typedef std::unordered_set<qglslang::TIntermBranch*> ReturnBranchNodeSet;
 
 // A helper function to tell whether a node is 'noContraction'. Returns true if
 // the node has 'noContraction' qualifier, otherwise false.
-bool isPreciseObjectNode(glslang::TIntermTyped* node)
+bool isPreciseObjectNode(qglslang::TIntermTyped* node)
 {
     return node->getType().getQualifier().isNoContraction();
 }
 
 // Returns true if the opcode is a dereferencing one.
-bool isDereferenceOperation(glslang::TOperator op)
+bool isDereferenceOperation(qglslang::TOperator op)
 {
     switch (op) {
-    case glslang::EOpIndexDirect:
-    case glslang::EOpIndexDirectStruct:
-    case glslang::EOpIndexIndirect:
-    case glslang::EOpVectorSwizzle:
-    case glslang::EOpMatrixSwizzle:
+    case qglslang::EOpIndexDirect:
+    case qglslang::EOpIndexDirectStruct:
+    case qglslang::EOpIndexIndirect:
+    case qglslang::EOpVectorSwizzle:
+    case qglslang::EOpMatrixSwizzle:
         return true;
     default:
         return false;
@@ -100,29 +100,29 @@ bool isDereferenceOperation(glslang::TOperator op)
 }
 
 // Returns true if the opcode leads to an assignment operation.
-bool isAssignOperation(glslang::TOperator op)
+bool isAssignOperation(qglslang::TOperator op)
 {
     switch (op) {
-    case glslang::EOpAssign:
-    case glslang::EOpAddAssign:
-    case glslang::EOpSubAssign:
-    case glslang::EOpMulAssign:
-    case glslang::EOpVectorTimesMatrixAssign:
-    case glslang::EOpVectorTimesScalarAssign:
-    case glslang::EOpMatrixTimesScalarAssign:
-    case glslang::EOpMatrixTimesMatrixAssign:
-    case glslang::EOpDivAssign:
-    case glslang::EOpModAssign:
-    case glslang::EOpAndAssign:
-    case glslang::EOpLeftShiftAssign:
-    case glslang::EOpRightShiftAssign:
-    case glslang::EOpInclusiveOrAssign:
-    case glslang::EOpExclusiveOrAssign:
-
-    case glslang::EOpPostIncrement:
-    case glslang::EOpPostDecrement:
-    case glslang::EOpPreIncrement:
-    case glslang::EOpPreDecrement:
+    case qglslang::EOpAssign:
+    case qglslang::EOpAddAssign:
+    case qglslang::EOpSubAssign:
+    case qglslang::EOpMulAssign:
+    case qglslang::EOpVectorTimesMatrixAssign:
+    case qglslang::EOpVectorTimesScalarAssign:
+    case qglslang::EOpMatrixTimesScalarAssign:
+    case qglslang::EOpMatrixTimesMatrixAssign:
+    case qglslang::EOpDivAssign:
+    case qglslang::EOpModAssign:
+    case qglslang::EOpAndAssign:
+    case qglslang::EOpLeftShiftAssign:
+    case qglslang::EOpRightShiftAssign:
+    case qglslang::EOpInclusiveOrAssign:
+    case qglslang::EOpExclusiveOrAssign:
+
+    case qglslang::EOpPostIncrement:
+    case qglslang::EOpPostDecrement:
+    case qglslang::EOpPreIncrement:
+    case qglslang::EOpPreDecrement:
         return true;
     default:
         return false;
@@ -131,7 +131,7 @@ bool isAssignOperation(glslang::TOperator op)
 
 // A helper function to get the unsigned int from a given constant union node.
 // Note the node should only hold a uint scalar.
-unsigned getStructIndexFromConstantUnion(glslang::TIntermTyped* node)
+unsigned getStructIndexFromConstantUnion(qglslang::TIntermTyped* node)
 {
     assert(node->getAsConstantUnion() && node->getAsConstantUnion()->isScalar());
     unsigned struct_dereference_index = node->getAsConstantUnion()->getConstArray()[0].getUConst();
@@ -139,7 +139,7 @@ unsigned getStructIndexFromConstantUnion(glslang::TIntermTyped* node)
 }
 
 // A helper function to generate symbol_label.
-ObjectAccessChain generateSymbolLabel(glslang::TIntermSymbol* node)
+ObjectAccessChain generateSymbolLabel(qglslang::TIntermSymbol* node)
 {
     ObjectAccessChain symbol_id =
         std::to_string(node->getId()) + "(" + node->getName().c_str() + ")";
@@ -148,39 +148,39 @@ ObjectAccessChain generateSymbolLabel(glslang::TIntermSymbol* node)
 
 // Returns true if the operation is an arithmetic operation and valid for
 // the 'NoContraction' decoration.
-bool isArithmeticOperation(glslang::TOperator op)
+bool isArithmeticOperation(qglslang::TOperator op)
 {
     switch (op) {
-    case glslang::EOpAddAssign:
-    case glslang::EOpSubAssign:
-    case glslang::EOpMulAssign:
-    case glslang::EOpVectorTimesMatrixAssign:
-    case glslang::EOpVectorTimesScalarAssign:
-    case glslang::EOpMatrixTimesScalarAssign:
-    case glslang::EOpMatrixTimesMatrixAssign:
-    case glslang::EOpDivAssign:
-    case glslang::EOpModAssign:
-
-    case glslang::EOpNegative:
-
-    case glslang::EOpAdd:
-    case glslang::EOpSub:
-    case glslang::EOpMul:
-    case glslang::EOpDiv:
-    case glslang::EOpMod:
-
-    case glslang::EOpVectorTimesScalar:
-    case glslang::EOpVectorTimesMatrix:
-    case glslang::EOpMatrixTimesVector:
-    case glslang::EOpMatrixTimesScalar:
-    case glslang::EOpMatrixTimesMatrix:
-
-    case glslang::EOpDot:
-
-    case glslang::EOpPostIncrement:
-    case glslang::EOpPostDecrement:
-    case glslang::EOpPreIncrement:
-    case glslang::EOpPreDecrement:
+    case qglslang::EOpAddAssign:
+    case qglslang::EOpSubAssign:
+    case qglslang::EOpMulAssign:
+    case qglslang::EOpVectorTimesMatrixAssign:
+    case qglslang::EOpVectorTimesScalarAssign:
+    case qglslang::EOpMatrixTimesScalarAssign:
+    case qglslang::EOpMatrixTimesMatrixAssign:
+    case qglslang::EOpDivAssign:
+    case qglslang::EOpModAssign:
+
+    case qglslang::EOpNegative:
+
+    case qglslang::EOpAdd:
+    case qglslang::EOpSub:
+    case qglslang::EOpMul:
+    case qglslang::EOpDiv:
+    case qglslang::EOpMod:
+
+    case qglslang::EOpVectorTimesScalar:
+    case qglslang::EOpVectorTimesMatrix:
+    case qglslang::EOpMatrixTimesVector:
+    case qglslang::EOpMatrixTimesScalar:
+    case qglslang::EOpMatrixTimesMatrix:
+
+    case qglslang::EOpDot:
+
+    case qglslang::EOpPostIncrement:
+    case qglslang::EOpPostDecrement:
+    case qglslang::EOpPreIncrement:
+    case qglslang::EOpPreDecrement:
         return true;
     default:
         return false;
@@ -233,18 +233,18 @@ ObjectAccessChain getSubAccessChainAfterPrefix(const ObjectAccessChain& chain,
 //  1) A mapping from symbol nodes' IDs to their defining operation nodes.
 //  2) A set of access chains of the initial precise object nodes.
 //
-class TSymbolDefinitionCollectingTraverser : public glslang::TIntermTraverser {
+class TSymbolDefinitionCollectingTraverser : public qglslang::TIntermTraverser {
 public:
     TSymbolDefinitionCollectingTraverser(NodeMapping* symbol_definition_mapping,
                                          AccessChainMapping* accesschain_mapping,
                                          ObjectAccesschainSet* precise_objects,
                                          ReturnBranchNodeSet* precise_return_nodes);
 
-    bool visitUnary(glslang::TVisit, glslang::TIntermUnary*) override;
-    bool visitBinary(glslang::TVisit, glslang::TIntermBinary*) override;
-    void visitSymbol(glslang::TIntermSymbol*) override;
-    bool visitAggregate(glslang::TVisit, glslang::TIntermAggregate*) override;
-    bool visitBranch(glslang::TVisit, glslang::TIntermBranch*) override;
+    bool visitUnary(qglslang::TVisit, qglslang::TIntermUnary*) override;
+    bool visitBinary(qglslang::TVisit, qglslang::TIntermBinary*) override;
+    void visitSymbol(qglslang::TIntermSymbol*) override;
+    bool visitAggregate(qglslang::TVisit, qglslang::TIntermAggregate*) override;
+    bool visitBranch(qglslang::TVisit, qglslang::TIntermBranch*) override;
 
 protected:
     TSymbolDefinitionCollectingTraverser& operator=(const TSymbolDefinitionCollectingTraverser&);
@@ -267,13 +267,13 @@ protected:
     // The pointer to the Function Definition node, so we can get the
     // preciseness of the return expression from it when we traverse the
     // return branch node.
-    glslang::TIntermAggregate* current_function_definition_node_;
+    qglslang::TIntermAggregate* current_function_definition_node_;
 };
 
 TSymbolDefinitionCollectingTraverser::TSymbolDefinitionCollectingTraverser(
     NodeMapping* symbol_definition_mapping, AccessChainMapping* accesschain_mapping,
     ObjectAccesschainSet* precise_objects,
-    std::unordered_set<glslang::TIntermBranch*>* precise_return_nodes)
+    std::unordered_set<qglslang::TIntermBranch*>* precise_return_nodes)
     : TIntermTraverser(true, false, false), symbol_definition_mapping_(*symbol_definition_mapping),
       precise_objects_(*precise_objects), precise_return_nodes_(*precise_return_nodes),
       current_object_(), accesschain_mapping_(*accesschain_mapping),
@@ -283,28 +283,28 @@ TSymbolDefinitionCollectingTraverser::TSymbolDefinitionCollectingTraverser(
 // current node symbol ID, and record a mapping from this node to the current
 // current_object_, which is the just obtained symbol
 // ID.
-void TSymbolDefinitionCollectingTraverser::visitSymbol(glslang::TIntermSymbol* node)
+void TSymbolDefinitionCollectingTraverser::visitSymbol(qglslang::TIntermSymbol* node)
 {
     current_object_ = generateSymbolLabel(node);
     accesschain_mapping_[node] = current_object_;
 }
 
 // Visits an aggregate node, traverses all of its children.
-bool TSymbolDefinitionCollectingTraverser::visitAggregate(glslang::TVisit,
-                                                          glslang::TIntermAggregate* node)
+bool TSymbolDefinitionCollectingTraverser::visitAggregate(qglslang::TVisit,
+                                                          qglslang::TIntermAggregate* node)
 {
     // This aggregate node might be a function definition node, in which case we need to
     // cache this node, so we can get the preciseness information of the return value
     // of this function later.
-    StateSettingGuard<glslang::TIntermAggregate*> current_function_definition_node_setting_guard(
+    StateSettingGuard<qglslang::TIntermAggregate*> current_function_definition_node_setting_guard(
         &current_function_definition_node_);
-    if (node->getOp() == glslang::EOpFunction) {
+    if (node->getOp() == qglslang::EOpFunction) {
         // This is function definition node, we need to cache this node so that we can
         // get the preciseness of the return value later.
         current_function_definition_node_setting_guard.setState(node);
     }
     // Traverse the items in the sequence.
-    glslang::TIntermSequence& seq = node->getSequence();
+    qglslang::TIntermSequence& seq = node->getSequence();
     for (int i = 0; i < (int)seq.size(); ++i) {
         current_object_.clear();
         seq[i]->traverse(this);
@@ -312,10 +312,10 @@ bool TSymbolDefinitionCollectingTraverser::visitAggregate(glslang::TVisit,
     return false;
 }
 
-bool TSymbolDefinitionCollectingTraverser::visitBranch(glslang::TVisit,
-                                                       glslang::TIntermBranch* node)
+bool TSymbolDefinitionCollectingTraverser::visitBranch(qglslang::TVisit,
+                                                       qglslang::TIntermBranch* node)
 {
-    if (node->getFlowOp() == glslang::EOpReturn && node->getExpression() &&
+    if (node->getFlowOp() == qglslang::EOpReturn && node->getExpression() &&
         current_function_definition_node_ &&
         current_function_definition_node_->getType().getQualifier().noContraction) {
         // This node is a return node with an expression, and its function has a
@@ -328,8 +328,8 @@ bool TSymbolDefinitionCollectingTraverser::visitBranch(glslang::TVisit,
 }
 
 // Visits a unary node. This might be an implicit assignment like i++, i--. etc.
-bool TSymbolDefinitionCollectingTraverser::visitUnary(glslang::TVisit /* visit */,
-                                                      glslang::TIntermUnary* node)
+bool TSymbolDefinitionCollectingTraverser::visitUnary(qglslang::TVisit /* visit */,
+                                                      qglslang::TIntermUnary* node)
 {
     current_object_.clear();
     node->getOperand()->traverse(this);
@@ -358,8 +358,8 @@ bool TSymbolDefinitionCollectingTraverser::visitUnary(glslang::TVisit /* visit *
 
 // Visits a binary node and updates the mapping from symbol IDs to the definition
 // nodes. Also collects the access chains for the initial precise objects.
-bool TSymbolDefinitionCollectingTraverser::visitBinary(glslang::TVisit /* visit */,
-                                                       glslang::TIntermBinary* node)
+bool TSymbolDefinitionCollectingTraverser::visitBinary(qglslang::TVisit /* visit */,
+                                                       qglslang::TIntermBinary* node)
 {
     // Traverses the left node to build the access chain info for the object.
     current_object_.clear();
@@ -393,7 +393,7 @@ bool TSymbolDefinitionCollectingTraverser::visitBinary(glslang::TVisit /* visit
         // The left node (parent node) is a struct type object. We need to
         // record the access chain information of the current node into its
         // object id.
-        if (node->getOp() == glslang::EOpIndexDirectStruct) {
+        if (node->getOp() == qglslang::EOpIndexDirectStruct) {
             unsigned struct_dereference_index = getStructIndexFromConstantUnion(node->getRight());
             current_object_.push_back(ObjectAccesschainDelimiter);
             current_object_.append(std::to_string(struct_dereference_index));
@@ -417,7 +417,7 @@ bool TSymbolDefinitionCollectingTraverser::visitBinary(glslang::TVisit /* visit
 // 3) a set of access chains of precise objects.
 // 4) a set of return nodes with precise expressions.
 std::tuple<NodeMapping, AccessChainMapping, ObjectAccesschainSet, ReturnBranchNodeSet>
-getSymbolToDefinitionMappingAndPreciseSymbolIDs(const glslang::TIntermediate& intermediate)
+getSymbolToDefinitionMappingAndPreciseSymbolIDs(const qglslang::TIntermediate& intermediate)
 {
     auto result_tuple = std::make_tuple(NodeMapping(), AccessChainMapping(), ObjectAccesschainSet(),
                                         ReturnBranchNodeSet());
@@ -453,7 +453,7 @@ getSymbolToDefinitionMappingAndPreciseSymbolIDs(const glslang::TIntermediate& in
 //  the access chain of the given 'precise' object along with the traversal to
 //  tell if the node to be defined is 'precise' or not.
 //
-class TNoContractionAssigneeCheckingTraverser : public glslang::TIntermTraverser {
+class TNoContractionAssigneeCheckingTraverser : public qglslang::TIntermTraverser {
 
     enum DecisionStatus {
         // The object node to be assigned to may contain 'precise' objects and also not 'precise' objects.
@@ -484,13 +484,13 @@ public:
     //  assignee is 'precise'. Otherwise it shows the path to the nested
     //  precise object.
     std::tuple<bool, ObjectAccessChain>
-    getPrecisenessAndRemainedAccessChain(glslang::TIntermOperator* node,
+    getPrecisenessAndRemainedAccessChain(qglslang::TIntermOperator* node,
                                          const ObjectAccessChain& precise_object)
     {
         assert(isAssignOperation(node->getOp()));
         precise_object_ = &precise_object;
         ObjectAccessChain assignee_object;
-        if (glslang::TIntermBinary* BN = node->getAsBinaryNode()) {
+        if (qglslang::TIntermBinary* BN = node->getAsBinaryNode()) {
             // This is a binary assignment node, we need to check the
             // preciseness of the left node.
             assert(accesschain_mapping_.count(BN->getLeft()));
@@ -508,7 +508,7 @@ public:
             // of the assignee object with the given precise object.
             assignee_object = accesschain_mapping_.at(BN->getLeft());
 
-        } else if (glslang::TIntermUnary* UN = node->getAsUnaryNode()) {
+        } else if (qglslang::TIntermUnary* UN = node->getAsUnaryNode()) {
             // This is a unary assignment node, we need to check the
             // preciseness of the operand node. For unary assignment node, the
             // operand node should always be an object node.
@@ -555,8 +555,8 @@ public:
 protected:
     TNoContractionAssigneeCheckingTraverser& operator=(const TNoContractionAssigneeCheckingTraverser&);
 
-    bool visitBinary(glslang::TVisit, glslang::TIntermBinary* node) override;
-    void visitSymbol(glslang::TIntermSymbol* node) override;
+    bool visitBinary(qglslang::TVisit, qglslang::TIntermBinary* node) override;
+    void visitSymbol(qglslang::TIntermSymbol* node) override;
 
     // A map from object nodes to their access chain string (used as object ID).
     const AccessChainMapping& accesschain_mapping_;
@@ -570,8 +570,8 @@ protected:
 // Visits a binary node. If the node is an object node, it must be a dereference
 // node. In such cases, if the left node is 'precise', this node should also be
 // 'precise'.
-bool TNoContractionAssigneeCheckingTraverser::visitBinary(glslang::TVisit,
-                                                          glslang::TIntermBinary* node)
+bool TNoContractionAssigneeCheckingTraverser::visitBinary(qglslang::TVisit,
+                                                          qglslang::TIntermBinary* node)
 {
     // Traverses the left so that we transfer the 'precise' from nesting object
     // to its nested object.
@@ -596,7 +596,7 @@ bool TNoContractionAssigneeCheckingTraverser::visitBinary(glslang::TVisit,
 
 // Visits a symbol node, if the symbol node ID (its access chain string) matches
 // with the given precise object, this node should be 'precise'.
-void TNoContractionAssigneeCheckingTraverser::visitSymbol(glslang::TIntermSymbol* node)
+void TNoContractionAssigneeCheckingTraverser::visitSymbol(qglslang::TIntermSymbol* node)
 {
     // A symbol node should always be an object node, and should have been added
     // to the map from object nodes to their access chain strings.
@@ -615,7 +615,7 @@ void TNoContractionAssigneeCheckingTraverser::visitSymbol(glslang::TIntermSymbol
 // 2) Find the object which should be marked as 'precise' in the right and
 //    update the 'precise' object work list.
 //
-class TNoContractionPropagator : public glslang::TIntermTraverser {
+class TNoContractionPropagator : public qglslang::TIntermTraverser {
 public:
     TNoContractionPropagator(ObjectAccesschainSet* precise_objects,
                              const AccessChainMapping& accesschain_mapping)
@@ -627,17 +627,17 @@ public:
     // access chain record from the assignee node to a 'precise' object it
     // contains.
     void
-    propagateNoContractionInOneExpression(glslang::TIntermTyped* defining_node,
+    propagateNoContractionInOneExpression(qglslang::TIntermTyped* defining_node,
                                           const ObjectAccessChain& assignee_remained_accesschain)
     {
         remained_accesschain_ = assignee_remained_accesschain;
-        if (glslang::TIntermBinary* BN = defining_node->getAsBinaryNode()) {
+        if (qglslang::TIntermBinary* BN = defining_node->getAsBinaryNode()) {
             assert(isAssignOperation(BN->getOp()));
             BN->getRight()->traverse(this);
             if (isArithmeticOperation(BN->getOp())) {
                 BN->getWritableType().getQualifier().noContraction = true;
             }
-        } else if (glslang::TIntermUnary* UN = defining_node->getAsUnaryNode()) {
+        } else if (qglslang::TIntermUnary* UN = defining_node->getAsUnaryNode()) {
             assert(isAssignOperation(UN->getOp()));
             UN->getOperand()->traverse(this);
             if (isArithmeticOperation(UN->getOp())) {
@@ -647,10 +647,10 @@ public:
     }
 
     // Propagates 'precise' in a given precise return node.
-    void propagateNoContractionInReturnNode(glslang::TIntermBranch* return_node)
+    void propagateNoContractionInReturnNode(qglslang::TIntermBranch* return_node)
     {
         remained_accesschain_ = "";
-        assert(return_node->getFlowOp() == glslang::EOpReturn && return_node->getExpression());
+        assert(return_node->getFlowOp() == qglslang::EOpReturn && return_node->getExpression());
         return_node->getExpression()->traverse(this);
     }
 
@@ -661,9 +661,9 @@ protected:
     // case we need to find the 'precise' or 'precise' containing object node
     // with the access chain record. In other cases, just need to traverse all
     // the children nodes.
-    bool visitAggregate(glslang::TVisit, glslang::TIntermAggregate* node) override
+    bool visitAggregate(qglslang::TVisit, qglslang::TIntermAggregate* node) override
     {
-        if (!remained_accesschain_.empty() && node->getOp() == glslang::EOpConstructStruct) {
+        if (!remained_accesschain_.empty() && node->getOp() == qglslang::EOpConstructStruct) {
             // This is a struct initializer node, and the remained
             // access chain is not empty, we need to refer to the
             // assignee_remained_access_chain_ to find the nested
@@ -675,7 +675,7 @@ protected:
                 getFrontElement(remained_accesschain_);
             unsigned precise_accesschain_index = (unsigned)strtoul(precise_accesschain_index_str.c_str(), nullptr, 10);
             // Gets the node pointed by the access chain index extracted before.
-            glslang::TIntermTyped* potential_precise_node =
+            qglslang::TIntermTyped* potential_precise_node =
                 node->getSequence()[precise_accesschain_index]->getAsTyped();
             assert(potential_precise_node);
             // Pop the front access chain index from the path, and visit the nested node.
@@ -697,7 +697,7 @@ protected:
     // an object node. If the binary node does not represent an object node, it should
     // go on to traverse its children nodes and if it is an arithmetic operation node, this
     // operation should be marked as 'noContraction'.
-    bool visitBinary(glslang::TVisit, glslang::TIntermBinary* node) override
+    bool visitBinary(qglslang::TVisit, qglslang::TIntermBinary* node) override
     {
         if (isDereferenceOperation(node->getOp())) {
             // This binary node is an object node. Need to update the precise
@@ -720,7 +720,7 @@ protected:
             return false;
         }
         // If this is an arithmetic operation, marks this node as 'noContraction'.
-        if (isArithmeticOperation(node->getOp()) && node->getBasicType() != glslang::EbtInt) {
+        if (isArithmeticOperation(node->getOp()) && node->getBasicType() != qglslang::EbtInt) {
             node->getWritableType().getQualifier().noContraction = true;
         }
         // As this node is not an object node, need to traverse the children nodes.
@@ -729,7 +729,7 @@ protected:
 
     // Visits a unary node. A unary node can not be an object node. If the operation
     // is an arithmetic operation, need to mark this node as 'noContraction'.
-    bool visitUnary(glslang::TVisit /* visit */, glslang::TIntermUnary* node) override
+    bool visitUnary(qglslang::TVisit /* visit */, qglslang::TIntermUnary* node) override
     {
         // If this is an arithmetic operation, marks this with 'noContraction'
         if (isArithmeticOperation(node->getOp())) {
@@ -743,7 +743,7 @@ protected:
     // nodes to access chains.  As an object node, a symbol node can be either
     // 'precise' or containing 'precise' objects according to unused
     // access chain information we have when we visit this node.
-    void visitSymbol(glslang::TIntermSymbol* node) override
+    void visitSymbol(qglslang::TIntermSymbol* node) override
     {
         // Symbol nodes are object nodes and should always have an
         // access chain collected before matches with it.
@@ -781,9 +781,9 @@ protected:
 };
 }
 
-namespace glslang {
+namespace qglslang {
 
-void PropagateNoContraction(const glslang::TIntermediate& intermediate)
+void PropagateNoContraction(const qglslang::TIntermediate& intermediate)
 {
     // First, traverses the AST, records symbols with their defining operations
     // and collects the initial set of precise symbols (symbol nodes that marked
@@ -826,7 +826,7 @@ void PropagateNoContraction(const glslang::TIntermediate& intermediate)
     // objects in the return expression should be added to the precise object
     // access chain set.
     while (!precise_return_nodes.empty()) {
-        glslang::TIntermBranch* precise_return_node = *precise_return_nodes.begin();
+        qglslang::TIntermBranch* precise_return_node = *precise_return_nodes.begin();
         propagator.propagateNoContractionInReturnNode(precise_return_node);
         precise_return_nodes.erase(precise_return_node);
     }
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.h b/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.h
index 8521ad7d..aa4b6fb2 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/propagateNoContraction.h
@@ -41,7 +41,7 @@
 
 #include "../Include/intermediate.h"
 
-namespace glslang {
+namespace qglslang {
 
 // Propagates the 'precise' qualifier for objects (objects marked with
 // 'noContraction' qualifier) from the shader source specified 'precise'
@@ -51,5 +51,5 @@ namespace glslang {
 // and arithmetic operation nodes, but has different meaning. For object nodes,
 // 'noContraction' means the object is 'precise'; and for arithmetic operation
 // nodes, it means the operation should not be contracted.
-void PropagateNoContraction(const glslang::TIntermediate& intermediate);
+void PropagateNoContraction(const qglslang::TIntermediate& intermediate);
 };
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/reflection.cpp b/src/3rdparty/glslang/glslang/MachineIndependent/reflection.cpp
index 9ea48c45..df038b28 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/reflection.cpp
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/reflection.cpp
@@ -65,7 +65,7 @@
 // there wasn't exactly one entry point.
 //
 
-namespace glslang {
+namespace qglslang {
 
 //
 // The traverser: mostly pass through, except
@@ -1175,7 +1175,7 @@ bool TReflection::addStage(EShLanguage stage, const TIntermediate& intermediate)
 
     for (auto& sequnence : intermediate.getTreeRoot()->getAsAggregate()->getSequence()) {
         if (sequnence->getAsAggregate() != nullptr) {
-            if (sequnence->getAsAggregate()->getOp() == glslang::EOpLinkerObjects) {
+            if (sequnence->getAsAggregate()->getOp() == qglslang::EOpLinkerObjects) {
                 it.updateStageMasks = false;
                 TIntermAggregate* linkerObjects = sequnence->getAsAggregate();
                 for (auto& sequnence : linkerObjects->getSequence()) {
@@ -1269,6 +1269,6 @@ void TReflection::dump()
     // printf("\n");
 }
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // !GLSLANG_WEB && !GLSLANG_ANGLE
diff --git a/src/3rdparty/glslang/glslang/MachineIndependent/reflection.h b/src/3rdparty/glslang/glslang/MachineIndependent/reflection.h
index 5af4467c..920b39fa 100644
--- a/src/3rdparty/glslang/glslang/MachineIndependent/reflection.h
+++ b/src/3rdparty/glslang/glslang/MachineIndependent/reflection.h
@@ -48,7 +48,7 @@
 // A reflection database and its interface, consistent with the OpenGL API reflection queries.
 //
 
-namespace glslang {
+namespace qglslang {
 
 class TIntermediate;
 class TIntermAggregate;
@@ -172,7 +172,7 @@ public:
     void dump();
 
 protected:
-    friend class glslang::TReflectionTraverser;
+    friend class qglslang::TReflectionTraverser;
 
     void buildCounterIndices(const TIntermediate&);
     void buildUniformStageMask(const TIntermediate& intermediate);
@@ -216,7 +216,7 @@ protected:
     unsigned int localSize[3];
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _REFLECTION_INCLUDED
 
diff --git a/src/3rdparty/glslang/glslang/OSDependent/Unix/ossource.cpp b/src/3rdparty/glslang/glslang/OSDependent/Unix/ossource.cpp
index e5f7c661..56dda2c2 100644
--- a/src/3rdparty/glslang/glslang/OSDependent/Unix/ossource.cpp
+++ b/src/3rdparty/glslang/glslang/OSDependent/Unix/ossource.cpp
@@ -50,7 +50,7 @@
 #include <sys/resource.h>
 #endif
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Thread cleanup
@@ -210,4 +210,4 @@ void OS_DumpMemoryCounters()
 #endif
 }
 
-} // end namespace glslang
+} // end namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/OSDependent/Windows/ossource.cpp b/src/3rdparty/glslang/glslang/OSDependent/Windows/ossource.cpp
index 870840c5..4ef98faf 100644
--- a/src/3rdparty/glslang/glslang/OSDependent/Windows/ossource.cpp
+++ b/src/3rdparty/glslang/glslang/OSDependent/Windows/ossource.cpp
@@ -51,7 +51,7 @@
 #error Trying to build a windows specific file in a non windows build.
 #endif
 
-namespace glslang {
+namespace qglslang {
 
 inline OS_TLSIndex ToGenericTLSIndex (DWORD handle)
 {
@@ -144,4 +144,4 @@ void OS_DumpMemoryCounters()
 #endif
 }
 
-} // namespace glslang
+} // namespace qglslang
diff --git a/src/3rdparty/glslang/glslang/OSDependent/osinclude.h b/src/3rdparty/glslang/glslang/OSDependent/osinclude.h
index 218abe4f..6bec0db9 100644
--- a/src/3rdparty/glslang/glslang/OSDependent/osinclude.h
+++ b/src/3rdparty/glslang/glslang/OSDependent/osinclude.h
@@ -35,7 +35,7 @@
 #ifndef __OSINCLUDE_H
 #define __OSINCLUDE_H
 
-namespace glslang {
+namespace qglslang {
 
 //
 // Thread Local Storage Operations
@@ -58,6 +58,6 @@ void OS_CleanupThreadData(void);
 
 void OS_DumpMemoryCounters();
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // __OSINCLUDE_H
diff --git a/src/3rdparty/glslang/glslang/Public/ShaderLang.h b/src/3rdparty/glslang/glslang/Public/ShaderLang.h
index b55ed599..d7793f32 100755
--- a/src/3rdparty/glslang/glslang/Public/ShaderLang.h
+++ b/src/3rdparty/glslang/glslang/Public/ShaderLang.h
@@ -137,7 +137,7 @@ typedef enum : unsigned {
     LAST_ELEMENT_MARKER(EShLanguageMaskCount),
 } EShLanguageMask;
 
-namespace glslang {
+namespace qglslang {
 
 class TType;
 
@@ -214,7 +214,7 @@ struct TEnvironment {
 
 GLSLANG_EXPORT const char* StageName(EShLanguage);
 
-} // end namespace glslang
+} // end namespace qglslang
 
 //
 // Types of output the linker will create.
@@ -396,7 +396,7 @@ GLSLANG_EXPORT int ShGetUniformLocation(const ShHandle uniformMap, const char* n
 class TCompiler;
 class TInfoSink;
 
-namespace glslang {
+namespace qglslang {
 
 struct Version {
     int major;
@@ -498,7 +498,7 @@ public:
     GLSLANG_EXPORT void setNoStorageFormat(bool useUnknownFormat);
     GLSLANG_EXPORT void setNanMinMaxClamp(bool nanMinMaxClamp);
     GLSLANG_EXPORT void setTextureSamplerTransformMode(EShTextureSamplerTransformMode mode);
-    GLSLANG_EXPORT void addBlockStorageOverride(const char* nameStr, glslang::TBlockStorageClass backing);
+    GLSLANG_EXPORT void addBlockStorageOverride(const char* nameStr, qglslang::TBlockStorageClass backing);
 
     GLSLANG_EXPORT void setGlobalUniformBlockName(const char* name);
     GLSLANG_EXPORT void setAtomicCounterBlockName(const char* name);
@@ -977,6 +977,6 @@ private:
     TProgram& operator=(TProgram&);
 };
 
-} // end namespace glslang
+} // end namespace qglslang
 
 #endif // _COMPILER_INTERFACE_INCLUDED_
diff --git a/src/shadertools/qspirvcompiler.cpp b/src/shadertools/qspirvcompiler.cpp
index f1525b98..209e9053 100644
--- a/src/shadertools/qspirvcompiler.cpp
+++ b/src/shadertools/qspirvcompiler.cpp
@@ -152,7 +152,7 @@ bool QSpirvCompilerPrivate::readFile(const QString &fn)
     return true;
 }
 
-class Includer : public glslang::TShader::Includer
+class Includer : public qglslang::TShader::Includer
 {
 public:
     IncludeResult *includeLocal(const char *headerName,
@@ -183,7 +183,7 @@ private:
     IncludeResult *readFile(const char *headerName, const char *includerName);
 };
 
-glslang::TShader::Includer::IncludeResult *Includer::readFile(const char *headerName, const char *includerName)
+qglslang::TShader::Includer::IncludeResult *Includer::readFile(const char *headerName, const char *includerName)
 {
     // Just treat the included name as relative to the includer:
     //   Take the path from the includer, append the included name, remove redundancies.
@@ -212,8 +212,8 @@ glslang::TShader::Includer::IncludeResult *Includer::readFile(const char *header
 class GlobalInit
 {
 public:
-    GlobalInit() { glslang::InitializeProcess(); }
-    ~GlobalInit() { glslang::FinalizeProcess(); }
+    GlobalInit() { qglslang::InitializeProcess(); }
+    ~GlobalInit() { qglslang::FinalizeProcess(); }
 };
 
 bool QSpirvCompilerPrivate::compile()
@@ -227,7 +227,7 @@ bool QSpirvCompilerPrivate::compile()
 
     static GlobalInit globalInit;
 
-    glslang::TShader shader(stage);
+    qglslang::TShader shader(stage);
     const QByteArray fn = sourceFileName.toUtf8();
     const char *fnStr = fn.constData();
     const char *srcStr = actualSource->constData();
@@ -239,9 +239,9 @@ bool QSpirvCompilerPrivate::compile()
         shader.setPreamble(preamble.constData());
     }
 
-    shader.setEnvInput(glslang::EShSourceGlsl, stage, glslang::EShClientVulkan, 100);
-    shader.setEnvClient(glslang::EShClientVulkan, glslang::EShTargetVulkan_1_0);
-    shader.setEnvTarget(glslang::EshTargetSpv, glslang::EShTargetSpv_1_0);
+    shader.setEnvInput(qglslang::EShSourceGlsl, stage, qglslang::EShClientVulkan, 100);
+    shader.setEnvClient(qglslang::EShClientVulkan, qglslang::EShTargetVulkan_1_0);
+    shader.setEnvTarget(qglslang::EshTargetSpv, qglslang::EShTargetSpv_1_0);
 
     int messages = EShMsgDefault;
     if (flags.testFlag(QSpirvCompiler::FullDebugInfo)) // embed source
@@ -254,7 +254,7 @@ bool QSpirvCompilerPrivate::compile()
         return false;
     }
 
-    glslang::TProgram program;
+    qglslang::TProgram program;
     program.addShader(&shader);
     if (!program.link(EShMsgDefault)) {
         qWarning("QSpirvCompiler: Link failed");
@@ -264,11 +264,11 @@ bool QSpirvCompilerPrivate::compile()
 
     // The only interesting option here is the debug info, optimizations and
     // such do not happen at this level.
-    glslang::SpvOptions options;
+    qglslang::SpvOptions options;
     options.generateDebugInfo = flags.testFlag(QSpirvCompiler::FullDebugInfo);
 
     std::vector<unsigned int> spv;
-    glslang::GlslangToSpv(*program.getIntermediate(stage), spv, &options);
+    qglslang::GlslangToSpv(*program.getIntermediate(stage), spv, &options);
     if (!spv.size()) {
         qWarning("Failed to generate SPIR-V");
         return false;
-- 
2.36.1.windows.1

